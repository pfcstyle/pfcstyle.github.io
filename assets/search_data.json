

[
  
  
    {
      "title"    : "页面没有找到",
      "url"      : "https://pfcstyle.github.io/404.html",
      "keywords" : "404"
    } ,
  
  
  
    {
      "title"    : "About",
      "url"      : "https://pfcstyle.github.io/about/",
      "keywords" : "Yawei Wang, PfCStyle, Will, Zhuang Ma, 王亚威"
    } ,
  
  
  
    {
      "title"    : "归档",
      "url"      : "https://pfcstyle.github.io/archives/",
      "keywords" : "归档"
    } ,
  
  
  
    {
      "title"    : "Categories",
      "url"      : "https://pfcstyle.github.io/categories/",
      "keywords" : "分类"
    } ,
  
  
  
  
  
    {
      "title"    : "Links",
      "url"      : "https://pfcstyle.github.io/links/",
      "keywords" : "友情链接"
    } ,
  
  
  
    {
      "title"    : "mindmap",
      "url"      : "https://pfcstyle.github.io/mindmap-viewer/",
      "keywords" : "mindmap"
    } ,
  
  
  
    {
      "title"    : "Open Source Projects",
      "url"      : "https://pfcstyle.github.io/open-source/",
      "keywords" : "开源,open-source,GitHub,开源项目"
    } ,
  
  
  
  
  
    {
      "title"    : "Wiki",
      "url"      : "https://pfcstyle.github.io/wiki/",
      "keywords" : "维基, Wiki"
    } ,
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
    {
      "title"    : "",
      "category" : "",
      "content": " It’s My First Blog! Go down 这是我第一次自己搭建博客，以前虽然在CSDN上写过，但跟这个比显然有些索然无味了。我使用的这个模板是基于@Hux 分享的模板进行修改替换的，非常感谢！ 第一篇博文写什么呢？最后还是决定把自己搭建的过程记录下来。虽然网上已经有很多类似的了，但我仍觉得有些细节需要总结的，不废话了，Begin! 从Github开始 GitHub Pages是免费的静态站点，三个特点：免费托管、自带主题、支持自制页面和Jekyll。本博客即是建立在Github上的，所以下面介绍的也是基于Github的。 拥有一个Github账号 首先大家应该有一个Github账号，作为一个程序员，如果你还没有加入Github,那么你显然out了！当然这不是为了赶时髦，github现在已经是全球最大的开源社区了，所以，加入的必要性就不言而喻了。 怎么注册账号呢？呃，这个不写了，推荐一篇博文：创建GitHub技术博客全攻略 好吧，推荐了这篇博文之后感觉基本什么都不用写了。但是我还是有一些自己经验的补充（耍无赖:)）。 创建个人博文仓库 Github是这样规定的，以 username.github.io 命名的仓库才可以作为自己的个人（公司）主页，并且此时你的主页代码等等都是在master分支中的，浏览器访问地址是username.github.io (比如我的是：pfcstyle.github.io)。如果你想要为自己的某个项目写文章的话，那么你需要在项目中新建gh-pages分支，浏览器访问地址：username.github.io/yourRepName。  自己DIY才有感情吧，也更有成就感噻！ 没错，正如你所理解的那样，上面推荐的那篇博文里介绍了如何github帮助你自动生成一个博文分支（包括个人的master和项目的gh-pages），但是，这些都是完全自己新建，自己写代码，自己写样式，自己……总之完全可以自定义咯。 本地Git配置 远程的配置好了，该配置本地的了。我这里只介绍windows平台上的，linux/unix步骤也是差不多的。windows上最简单的应该就是这个github for windows 了，直接下载安装就好。但是这个显然不是我介绍的重点，看下面。 1.安装Git 使用命令行的好处，大概就是装逼了。。。但是我觉得命令行更原生，更能看到一些本质。好了，不装了，来这里 下载吧。版本你自己选，这个也是有界面的，但是，真的是丑陋无比，反正我是从来没有用过，都是直接用命令行。 安装好就是配置了，你可以添加环境变量，比如我的是D:  Program Files  Git  bin。其实我并没有配置环境变量，因为我觉得根本不需要，安装好之后根目录下有一个git-bash，哪里需要，哪里运行，尤其是自动添加了右键菜单，还有高亮显示，很是方便。 2.配置本地ssh到github 首先你要生成自己本地的sshkey，打开git-bash //邮箱地址后面的是指定生成公钥的文件名，不过不指定，默认生成~/.ssh/id_rsa.pub ssh-keygen -t rsa -C 邮箱地址 -f ~/.ssh/githug_blog_keys 回车之后还会让你设置提交用户名、密码，可以直接跳过，如图： 生成之后，打开你的pub文件（我的是githug_blog_keys.pub，一般在C:  Users  用户名.ssh  目录下），全选复制里面的内容,来到github进行配置： 如果你已经使用github生成好了，那么来到你想存放的目录下，右键打开git-bash，clone下来就好了： git clone 上图中的ssh 如果你是完全自定义的……那我相信你一定会搞的 Jekyll的安装与配置 Jekyll是一种简单的、适用于博客的、静态网站生成引擎。它使用一个模板目录作为网站布局的基础框架，支持Markdown、Textile等标记语言的解析，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。说白了就是，只要安装Jekyll的规范和结构，不用写html，就可以生成网站。[ jekyll介绍 ] [ jekyll on Github ][ jekyllbootstrap ] Jekyll使用Liquid模板语言，{{page.title}}表示文章标题，{{content}}表示文章内容。我们可以用两种Liquid标记语言：输出标记（output markup）和标签标记 (tag markup)。输出标记会输出文本（如果被引用的变量存在），而标签标记不会。输出标记是用双花括号分隔，而标签标记是用花括号-百分号对分隔[ Liquid模板语言 ][ Liquid模板变量参考 ] jekyll与github的关系：GitHub Pages一个由 GitHub 提供的用于托管项目主页或博客的服务，jekyll是后台所运行的引擎。 jekyll安装之前需要先安装DevKit,DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby,先下载RubyInstaller ,直接安装就好了，设置环境变量，path中配置C:  Ruby193  bin目录，然后在命令行终端下输入 gem update --system 来升级gem。这里有可能会遇到问题,因为被墙原因导致ssl错误，这时可以替换一下gem软件源： //查看当前所有软件源 gem sources -l //自带的源是https://rubygems.org/ 删除 gem source -r https://rubygems.org/ //添加新源 gem source -a http://rubygems.org/ 网上许多解决此问题是通过替换淘宝源http://ruby.taobao.org/成功的，刚开始笔者也是这样干的，但是并没有卵用，最后还是去掉了’s’成功的。还有一点需要注意的是，在添加源的时候，你不能在git-bash中添加，会提示： ERROR: While executing gem ... (Gem::OperationNotSupportedError)  Not connected to a tty and no default specified 这是说连接不到终端，所以，你需要使用cmd或者是微软新出的windows powershell来添加源才可以。 然后下载DevKit ，跟ruby在同一个下载页面。安装后找到DevKit目录，输入以下命令： ruby dk.rb init ruby dk.rb install 这里需要说明的是，你在dk初始化之后,会提示你查看config.yml中的根目录是否正确，而事实上这个文件里根本就没有配置，你需要添加上自己的ruby目录，如下： --- - D:  Ruby22-x64 然后才去执行下面的install命令。 好啦，接下来就可以安装jekyll了： //安装 注意，jekyll都是小写，大小写是敏感的 gem install jekyll //查看版本号，以确定是否安装成功 jekyll --version 安装Jekyll-Bootstrap： 来到你的本地仓库目录，打开git-bash: git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com cd USERNAME.github.com git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git git push origin master 启动jekyll服务 jekyll server --port 4000//4000是默认端口号 激动人心的时刻到啦，现在去浏览器输入：http://127.0.0.1:4000 ，看看自己的本地博客吧。 不过还没结束呢，激动之余，是不是感觉还有点乱呢？分析一下目录：  _posts: _posts中的数据文档，通过注入_layouts定义的模板，通过jekyll server最终生成的静态页面在_sites目录。目录是用来存放你的文章的，一般以日期的形式书写标题。 _layouts： _layouts中的模板一般指向了_includes/themes中的模板。目录是用来存放模板的，在这里你可以定义页面中不同的头部和底部。 _includes： _includes/JB中有一些常用的工具，用于列表显示、评论等； _includes/themes中可参看主题的相关html文档。 _includes/themes中的主题一般包含default.html、post.html和page.html三个文档。default.html定义了网站的最上层框架（模板），post.html和page.html是其子框架（模板） 生成好的html子页面通过default.html的{{ content }}变量调用，生成整个页面。 asset: 渲染页面的CSS和JS文档在assets/themes中。 _config.yml: 站点生成需要用到_config.yml配置文件，站点的全局变量在_config.yml中定义，用site.访问；页面的变量在YAML Front Matter中定义，用page.访问，更多的模板变量可参考模板数据。jekyll配置详解 当然，并不是一定要这样做，只是一个习惯而已，如果你完全是自定义的，那么你可能都没有这些东西。 第一篇博客开始之前 其实博客开始前的工作基本算是说完了，可是我觉得还是要对这个layout进行补充一下： 去网上找现成的layout layout即是你的blog的样式和布局，网上有许多精美的主题供下载 自己定义layout 从头自定义的话，无疑很是费劲,所以我建议也像我一样，找到现成的模板，慢慢修改。 写第一篇博客 直接使用markdown来写好了，唯一需要说一下的的是文件头的声明格式： --- layout: t tpost title: t tCreate and Open My Blog description tHello Blog date: t t2016-03-20 17:45:00 author: t tPfCStyle keywords  t- Github  t- Blog  t- Jekyll  t- Markdown  t- CDName  t- layout --- 看意思应该都明白是什么，不再赘述了，但是，需要提醒大家的是这些不是固定的，不同的layout是有不同参数的。再来张图吧： 最后是找个自己的域名 首先是购买一个域名，域名购买之后，要先设置解析，你购买域名的地方都是可以设置的，过程大致相似： 最后还需要在你的博客分支根目录下添加CNAME文件，里面放上你的域名就可以了，github就会为你自动跳转。 ok,大功告成！ ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-03-20-Hello-Blog/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 工欲善其事，必先利其器 相信使用过eclipse的朋友们都体验过eclipse每次装插件都装不上的痛苦，尤其是配置adt，最是让人头痛，因为还面临着adt和sdk版本不匹配的问题，特别是每次google发布新的sdk，adt就必须跟着升级才行，实在是苦不堪言。终于，历时两年，google终于推出了android studio,完善的插件体统，以及对eclipse等工程的兼容，还有方便的sdk管理，最后再集成了Gradle项目管理，真是处处体现了android studio的强大与方便。 android studio的安装我相信不用多说，我们直接从hello world开始。 Hello World 如果你是刚刚装好了Android Studio,你应该是在欢迎界面，点击Create New Project,或者你已经打开或者导入过项目了，那就选择File&gt;New&gt;New Project,然后你会看到下图的界面。在Application name中填上Hello World，这里建议是以大写字母开头。Company Domain就是公司域名，Package name是反转的Company Domain加上Application Name。最后修改你的工程路径，本次修改后，路径会记录，下次如果不想修改就不用管了，感觉这个比设置默认的工作路径要方便很多。 next之后是硬件选择界面，Phone and Tablet(手机和平板)是默认被选中的，下面依次是Wear(手表)、TV(电视)、Android Auto(车载应用)、Glass(眼镜),他们每一项都要求设定最低支持的SDK版本，你们可以根据自己的需求来设定，如果自己无法确定，下面还有一个Help me choose,他可以向你展示android各个版本的市场份额，可以帮助你确定你的需求。 next之后是模板选择界面，我们这里选择empty Activity next之后是设置activity的名称这些，我们就使用默认的就好了。 点击完成，我们的hello world就创建成功了！ 使用虚拟机运行Hello World Android虚拟设备管理器允许你创建Android虚拟设备（AVDs），然后你可以在你的电脑上运行模拟器。模拟和仿真有一个很重要但是微妙的区别。模拟意味着虚拟设备只有一个外形，模拟实际的物理设备如何运作，但是不针对特定的操作系统。IOS开发环境使用模拟器，对于有限数量的设备的平台的IOS来说可能是一个不错的选择。 然而对于仿真器而言，你的电脑留出一块内存去复制基于仿真器正在仿真设备上的环境。Android Studio使用仿真器，这意味着Android虚拟设备管理器启动一个 Linux内核的大沙箱和整个Android栈为了仿真基于Android物理设备的环境。尽管仿真器提供了一个比模拟器更可靠的环境来测试你的应用程序，但是启动一个AVD需要数分钟，这取决于你电脑的速度。好消息是你的仿真器仍然活跃在内存中，它仍然是有响应的。然而，如果你有Android手机或者平板电脑，我们建议使用物理设备来测试你的应用程序，而不是使用AVD。也就是说，我们首先使用Android虚拟设备管理器创建一个AVD，在后来的章节我们将想你展示如何连接你的物理设备,当然如果你有的话。 下面我们将创建一个仿真器，选择工具栏中的avd manager 打开之后，点击左下角的Create Virtual Device,选择Galaxy Nexus，然后点击Next。下一个界面允许你选择一个系统镜像。选择Lollopop（或最新的API）和x86_64的API,如果你没有，那么点击download下载就好了，android studio会自动为你配置好的。点击Next 接下来是虚拟机的具体的一些配置参数，点击show Advanced Settings会显示出更多的高级选项。下图中会详细标出，点击finish，恭喜你，你的第一个虚拟机已经创建成功了。 点击绿色按钮运行，选择你刚刚创建的虚拟机，你将会看到hello world。 使用真机运行Hello World 使用真机调试的关键是要让你的电脑连接上你的手机，你可能需要安装与你的手机匹配的USB驱动，你可以自己去找一下，也可以让360之类的手机助手帮你安装，现在已经不是问题了。此外，你还需要打开开发人员选项并确保USB调试框被选中。当你成功连接真机之后，你可以在android device monitor中查看你的真机是否出现，并且状态为online，如下图： 接下来，直接点击运行就好了，Hello World应该成功出现在你的手机上了。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-03-26-Android-Studio1/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 困难总是需要克服的 这两天一直在搭建驱动开发环境，本来是VS2010的，后来网上找了一下，配置起来比较麻烦，就没有去搞，直接换了VS2015了，然而，事情并没有想象中的那么简单。 从VS2015开始 刚开始我很自然的就去了微软的官网，也找到了VS2015,而且和WDK10在一起，于是我很开心的下载了下来，当然，只是一个安装器而已，于是，就苦逼的在线开始下载安装，然而，等来的却全是失败。 每次安装失败的都不一样，我去网上搜，也找到了各种答案(?),但没有一个可以解决我的问题。于是乎，好吧，找到了VS2015离线安装包，直接安装，什么问题也没有了。但是值得提醒的是你要记得在安装的时候选择自定义，然后把C++相关的装上，不然WDK安装的时候会提示你安装。然后，你应该和我一样，没有什么问题了。 WDK 和 SDK 的安装 WDK和SDK同样也是可以从微软官网找到的，我就不提供链接了，为什么？没有用啊，下载的只是下载器，等待的仍然是失败！我就只好提供WDK10和SDK10的百度云了。直接安装就好了，相信不会有任何问题。 另外提一下啊，如果你还想研究xp的话，那么你需要下载WDK7 好吧，想不到折磨了我好几天，甚至让我重装了一次系统的问题，三言两语就写完了，洗过了，睡了。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-03-27-VS-WDK-SDK/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 小记 下面是C盘可以清理的路径： - C盘搜索FileRepository,这是windows自动推送的驱动更新，全选，删除。如果有些删不掉就跳过。 - C:  Windows  SoftwareDistribution  Download - C:  Users  **user**  AppData  Local  Temp ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-03-28-Clean-DiskC/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 透过现象看本质 先跟大家推荐一个网站,这里提供了可以翻墙的hosts，毕竟google,大家都懂得。 最近想看看android的源码，于是就去google下载，google提供了具体的环境需求和下载方式，大家可以参考这里,但是，google官方提供的这种方式只能用于linux,因为它提供的repo是一个python脚本，里面一些模块是linux特有的，windows无法安装。 一种变通的方式是在windows上安装Cygwin，这是一个模拟linux环境的软件，安装好后再按照google官网说的搭建环境，下载源码即可。 但是我觉得上面的过程都太复杂了，用起来很不方便，后来我看了下google官方提供的repo文件，发现其本质就是先使用git clone下来android源码的清单文件,所以，你需要先安装git,git的安装就不说了，我之前的博客已经有介绍过了。假设你已经装好了git,找到你想要放android源码的目录，执行： git clone https://android.googlesource.com/platform/manifest cd manifest 接下来执行: //列出android各个分支版本 git tag //使用git checkout 切换到你想要的源码的分支，名称就是git tag列出的名称，比如android4.4.2 git checkout android-4.4.2_r1 这里所谓的切换分支只是切换到了对应分支的manifest清单文件，接下来，我们将使用清单文件进行源码下来，下面，有请python出场。下载安装python，具体过程我就不说了，很简单。建议安装python2.7，比较稳定。 这里提供一个根据manifest清单文件下载的python脚本，我在网上找到了下载的基础代码，自己添加了断点续传，方便大家使用。 import xml.dom.minidom import os from subprocess import call import stat #downloaded source path rootdir = F:/Documents/android_src/AndroidCode #git program path git = D:/Git/bin/git.exe dom = xml.dom.minidom.parse(F:/Documents/android_src/AndroidCode/manifest/default.xml) root = dom.documentElement prefix = git + clone https://aosp.tuna.tsinghua.edu.cn/ suffix = .git if not os.path.exists(rootdir):  os.mkdir(rootdir) def rmtree(top):  for root, dirs, files in os.walk(top, topdown=False):  for name in files:   filename = os.path.join(root, name)   os.chmod(filename, stat.S_IWUSR)   os.remove(filename)  for name in dirs:   os.rmdir(os.path.join(root, name))  os.rmdir(top) lastPath_pre = None lastName = None lastPath_all = None for node in root.getElementsByTagName(project):  os.chdir(rootdir)  d_all = node.getAttribute(path)  last = d_all.rfind(/)  if last != -1:  d_per = rootdir + / + d_all[:last]  d_all = rootdir + / + d_all  else:  d_per = rootdir + /  d_all = rootdir + / + d_all  print d_per  if os.path.exists(d_all):  lastPath_all = d_all  lastPath_pre = d_per  lastName = node.getAttribute(name)  else:  if not lastPath_all == None:   rmtree(lastPath_all)   os.chdir(lastPath_pre)   cmd = prefix + lastName + suffix   call(cmd)   lastPath_all = None  if not os.path.exists(d_per):   os.makedirs(d_per)  os.chdir(d_per)  cmd = prefix + node.getAttribute(name) + suffix  call(cmd)  需要注意的是要将里面的git和存放源代码路径都替换为你自己的。上面我使用的是清华的镜像，速度很快，推荐使用，如果不放心，可以自己替换为google的https://android.googlesource.com/，但是表示速度难以忍受。。。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-03-29-Android-sources-download/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 工欲善其事，必先利其器 今天说一下代码方面常用的设置，以及快捷键。 常用快捷键记录  Ctrl + N 使用输入类名对话框快速打开类文件 Ctrl + Shift + N 搜索所有的文件名 Ctrl + Shift + A 动作或选项搜索框，如搜索show line numbers就会自动列出显示行数的开关，支持模糊查询 Ctrl + Shift + F/R 全局搜索/替换，可以搜索/替换文件内容，还可以设置过滤 Ctrl + G 以行和列导航单个文件，如果只输入一个数字，就是调到行 Ctrl + Alt + Home 列出与当前文件相关联的文件，如：xml Ctrl + Shift + Backspace 移动到最后编辑位置 Ctrl + ‘+’(数字键盘的) 展开代码块 Ctrl + ‘-‘(数字键盘的) 收缩代码块 Ctrl + Space 基本代码补全功能，附带javadoc展示 Ctrl + Shift + Space 智能代码补全，比基本代码补全范围更广 Ctrl + ‘/’ 行注释 Ctrl + Shift + ‘/’ 块注释 Ctrl + z 撤销 Ctrl + Shift + z 恢复撤销 Ctrl + J 调用动态模板，这是打出了缩略词之后调用 Ctrl + Alt + J 显示出动态模板列表 Ctrl + Shift + Down 向下移动代码块 Ctrl + Shift + Up 向上移动代码块 Ctrl + Alt + L 自动格式化代码 Ctrl + Alt + I 自动缩进代码 Code ➤ Rearrange 自动整理代码 Ctrl + Alt + T 环绕代码 如try/catch,if/else等等 Ctrl + Shift +Delete 删除环绕代码 Ctrl + E 查看最近打开过的文件 默认最多记录50个 Ctrl + Alt + 左箭头 遍历导航操作，上一个导航 Ctrl + Alt + 右箭头 遍历导航操作，下一个导航 Alt + ‘/’ 循环扩展 Alt + ‘F1’ 打开导航列表 Alt + Insert 生成代码，包括构造器，getter,setter等等 Shift + Tab 取消缩进 常用设置 代码生成设置 恰当的使用代码生成功能，这一特色将为你节约大量的时间，代码生成是生成各种方法的的强大功能，包括了构造，getters, setters, equals()，hashCode(), toString()方法等等。在你使用代码生成之前，确认Android Studio 是配置好了，可以忽略成员名称的前缀，如m和s（因为我们一般遵循成员变量前加’m’，静态变量前加’s’的规则），点击File ➤ Settings ➤ Code Style ➤ Java ➤ Code Generation将得到设置对话框，将会出现代码生成的标签页，如果域和静态域文本框不包含m和s，则键入他们，并点击”应用“和”确定“，如图 在模板中保存自己常用的代码 Android Studio有很多模板,允许您将预定义的代码直接插入到你的源文件中。在许多ide,生成的代码只是从模板中粘贴，而从来不考虑作用域;但是Android Studion的模板是对作用域敏感的,也可以集成变量数据。在你开始使用Android Studio的动态模板之前,让我们探索动态模板和自定义模板。导航到File ➤ Settings ➤ Live Templates。选择普通模板组。现在在右上角单击绿色加号按钮并选择住模板。如图，填充好缩写、描述和模板文本字段。在这个模板可以应用之前,您必须单击Define按钮,这看起来像一个蓝色的超文本链接，位于窗口的底部。现在选择Java和选择所有范围(语句,表达式,声明等等)。单击Apply 图中的$selection$意思是你选择的内容，你先选择一段文字，然后按Ctrl + Alt + J，选择cb模板，就会自动出现上图中定义的内容了。 定义你自己的代码风格 代码风格规范在不断发展。没有固定的规则，你应该在你的方法之后放置空格的数量，还是左括号应该出现在同一行作为方法签名或略低于它。组织倾向于定义自己的代码风格,但每个程序员的代码风格也各不相同,你也可能有你习惯的代码风格。幸运的是,Android Studio很简单就能样式化和组织你的代码。在开始样式化代码之前，让我们检查一下代码风格的设置。选择File ➤ Settings ➤ Code Style弹出设置对话框,如图所示。Java和XML是我们在Android中最感兴趣的语言。在左窗格中切换打开代码风格选项,选择Java,并检查在设置窗口的每个选项卡 代码风格的定义选项非常多，建议大家自己点击多试试，在右侧的代码框中会即时响应你的修改。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-03-30-Android-Studio2/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 工欲善其事，必先利其器 今天大致的介绍一下Gradle 为什么要用Gradle  一个像Ant一样灵活且通用的构建工具。 一种可切换的，像Maven一样的基于约定的构建框架，却又从不约束你（约定优于配置）。 对多项目构建的强力支持。 对依赖管理的强力支持（基于Apache Ivy）。 对已有的Maven和Ivy仓库有着全面的支持。 支持可传递性的依赖管理，而不需要远程仓库或者pom.xml和ivy.xml配置文件。 Gradle能够很好地支持Ant任务和构建 。（有更好的翻译欢迎提议） 支持用Groovy语言编写Gradle的脚本。 拥有丰富的领域模型来构建你的脚本。 Gradle的核心是一个丰富的可扩展的基于Groovy的领域特定语言(DSL)。Gradle通过提供说明性语言元素将说明性构建推到下一层，您可以组装。这些元素也提供build-by-convention支持Java、Groovy、OSGi、Web和Scala项目。说了这么多，下面我们来一个快速入门。 Gradle快速入门 Gradle安装 Gradle需要安装1.6及以上版本的Java JDK或JRE（使用java -version来查看当前版本）。Gradle拥有自己的Groovy库，因此不需要另行安装Groovy。任何已安装的Groovy都会被Gradle给忽略。Gradle使用环境变量中设置的JDK。 代码生成设置 恰当的使用代码生成功能，这一特色将为你节约大量的时间，代码生成是生成各种方法的的强大功能，包括了构造，getters, setters, equals()，hashCode(), toString()方法等等。在你使用代码生成之前，确认Android Studio 是配置好了，可以忽略成员名称的前缀，如m和s（因为我们一般遵循成员变量前加’m’，静态变量前加’s’的规则），点击File ➤ Settings ➤ Code Style ➤ Java ➤ Code Generation将得到设置对话框，将会出现代码生成的标签页，如果域和静态域文本框不包含m和s，则键入他们，并点击”应用“和”确定“，如图 在模板中保存自己常用的代码 Android Studio有很多模板,允许您将预定义的代码直接插入到你的源文件中。在许多ide,生成的代码只是从模板中粘贴，而从来不考虑作用域;但是Android Studion的模板是对作用域敏感的,也可以集成变量数据。在你开始使用Android Studio的动态模板之前,让我们探索动态模板和自定义模板。导航到File ➤ Settings ➤ Live Templates。选择普通模板组。现在在右上角单击绿色加号按钮并选择住模板。如图，填充好缩写、描述和模板文本字段。在这个模板可以应用之前,您必须单击Define按钮,这看起来像一个蓝色的超文本链接，位于窗口的底部。现在选择Java和选择所有范围(语句,表达式,声明等等)。单击Apply 图中的$selection$意思是你选择的内容，你先选择一段文字，然后按Ctrl + Alt + J，选择cb模板，就会自动出现上图中定义的内容了。 定义你自己的代码风格 代码风格规范在不断发展。没有固定的规则，你应该在你的方法之后放置空格的数量，还是左括号应该出现在同一行作为方法签名或略低于它。组织倾向于定义自己的代码风格,但每个程序员的代码风格也各不相同,你也可能有你习惯的代码风格。幸运的是,Android Studio很简单就能样式化和组织你的代码。在开始样式化代码之前，让我们检查一下代码风格的设置。选择File ➤ Settings ➤ Code Style弹出设置对话框,如图所示。Java和XML是我们在Android中最感兴趣的语言。在左窗格中切换打开代码风格选项,选择Java,并检查在设置窗口的每个选项卡 代码风格的定义选项非常多，建议大家自己点击多试试，在右侧的代码框中会即时响应你的修改。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-04-09-Android-Studio3/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 所有的墙都是纸老虎-PfCStyle 我真是觉得很悲催，眼望着马上要毕业了，我们学校网络中心发了一个通告，从此，每月20元不限流量的舒服日子结束了，以后要根据流量算每月的网费了，再也不能随心所欲的看想看的片了。。。 然而，作为一个崇尚自由的程序猿，面对一切封锁，都要打破！打破！打破！于是我伸展一下那过膝的双臂，准备翻墙了。 大家都知道，大学的ipv6的流量一直是免费的，而我，将要利用的就是这个。下面就是我的翻墙历程。 从VPS开始 首先，我得选择一个免费的VPS进行试验，于是我在网上找呀找，找到了亚马逊的aws, 只要你有一张信用卡，那么，你可以很轻松的获得12个月的免费试用。具体免费套餐内容请浏览这里. 没有信用卡？没有关系，经网友们测试，从淘宝买的虚拟信用卡可以用作激活Amazon AWS，关键词：“虚拟信用卡 amazon”. 注册aws 好的，都准备好了，现在，去亚马逊的aws 注册一个账号。看图：   在这一步一定要注意，因为默认选择的是开发人员选项，要扣40美金的偶，立刻就会扣，没有反应时间。。。好吧，被看出来了，我被扣了– 这一步之后注册就算是完成了，等待几分钟账号就会被激活了，有些人的会等很久才能激活，可能跟前面填写的信息有关系。 开始创建VPS 这个描述起来也是相当麻烦，大家看图吧。    到了这里，已经算是把一个VPS建好了，需要什么服务都可以自己配置了，接下来说如何本地连接到远程VPS,有多种方式，大家可以详细参看官网教程, 我这里只介绍我使用的方式，putty连接。 连接VPS 1.软件准备 从putty下载页面 下载putty和puttygen. putty是用来连接VPS的，但是VPS的连接需要提供秘钥，就是上文要你下载的pem文件。但是putty并不直接支持pem文件，你需要把pem文件转换为ppk文件，这就需要puttygen来完成了，下面，我们来转换。 2.转换秘钥格式  这样就转换好了，接下来我们开始正式连接VPS了： 3.获取连接VPS需要的信息 实例的获取公有DNS信息，如图： 填写信息：Host Name的格式是user_name@public_dns_name，其中user_name是root 或 ec2-user，但是经过测试，root是禁止直接登录的，所以只能使用ec2-user。注意不同的linux系统user_name是不同的，这里说得是Redhat，请到上文提到的官网教程查看具体内容。public_dns_name就是上步获取的公有dns 为了避免每次都重复填写，可以点击save按钮进行配置保存。 配置上文转换过得秘钥 4.连接 点击open启动 现在已经连上了VPS了，大家想干什么就随意吧。 开始配置VPN 使用SoftEther 软件准备 在VPS上下载softEther VPN: 你可以选择下载最新版本的，也可以选择较为稳定的版本。 //首先安装wget sudo yum install wget sudo wget http://www.softether-download.com/files/softether/v4.20-9608-rtm-2016.04.17-tree/Linux/SoftEther_VPN_Server/64bit_-_Intel_x64_or_AMD64/softether-vpnserver-v4.20-9608-rtm-2016.04.17-linux-x64-64bit.tar.gz  这个网上有些教程说下载这个是需要翻墙的，对于国内用户确实是这样，但是，但aws可是在美国呢，嘿嘿，不用担心，直接下就好了，速度杠杠的。还是提供一下百度云下载 插一下，putty经常死机，准确来说，如果你隔了两三分钟没有操作，aws就会把你的连接踢掉，但是如果你一直在使用就不会有什么问题的。死机了就重连好了。 开始安装 好的，下载完成了，解压： tar -zxvf softether-vpnserver-v4.20-9608-rtm-2016.04.17-linux-x64-64bit.tar.gz 接下来开始配置VPN了，是不是想想都要头疼了？但是，史上最简单，可不是白说的，看看一键配置！ cd vpnserver/ ./.install.sh 接下来，它会让你阅读用户协议，然后让你同意，你就连输入3个‘1’就ok了，进入正式安装。oh!出错了，提示缺少gcc，不早说。。。 //安装gcc sudo yum install gcc 安装完毕，再去执行上面的命令，输入3个‘1’，安装成功啦（如果你使用的其他系统，获取其他VPS，可能会缺少其他的依赖，按照错误提示一个个安装即可），好了，试试： ./vpnserver start ./vpnserver stop so easy! 在本地管理VPN 下载管理软件 好吧，还得需要下载 一个管理软件，这个要翻墙了。如图： 这里提供百度云下载。 下载之后解压就可以使用了，打开vpnsmgr.exe。 配置连接 连接VPN server 欧，遇到问题了，为什么会连接不上呢？现在要来说说aws的安全组是怎么一回事了。这个安全组类似于防火墙，你可以配置允许出入的协议和流量，看图： 配置允许访问的端口和协议，这些端口都是softether监听的端口号，在官网可以找到。如果你实在是觉得烦，可以开放所有流量，这个你自己决定吧，不安全偶~ 好的，接下来成功连接 你会进入下面这个界面（刚刚进入，会提示你进行各种配置，全X掉吧，我一步步的展示） 配置VPN 配置L2TPVPN 管理VPN用户配置 这里创建的用户以及密码会在连接vpn时使用。 配置NAT 这个不多解释，按照我的配置来吧。点击确定之后，VPN的所有配置算是完成了。怎么样，全部界面化，是不是非常简单。 连接VPN 接下来就是最激动人心的时刻了，试着连接VPN吧。直接使用windows自带的VPN连接就可以了：    连接成功啦！！！ IPV6配置 好的，现在万事俱备，只欠东风啦。配置一个公网的Ipv6就可以了。到哪里找呢，我只推荐HE, 就是好用，下面看操作。 先注册账号 注册就不多说了，简单。接下来看配置。 申请ipv6地址 申请成功之后就会显示如下界面 Vps配置ipv6地址 转到下图界面，选择自己的系统，通用的linux就是选择下图的linux-net-tools,然后就会出现下面的配置命令了。但是你要记得在添加sudo权限才可以执行 配置ipv6的网络命令 sudo ifconfig sit0 up sudo ifconfig sit0 inet6 tunnel ::【he中Server IPv4 Address】 sudo ifconfig sit1 up sudo ifconfig sit1 inet6 add 【he中Server IPv6 Address】 sudo route -A inet6 add ::/0 dev sit1 配置完毕之后，进行测试，如下图： ping ipv6.baidu.com 好了，接下来就可以尝试使用ipv6进行vpnconnect了： 这个除了主机地址是使用ipv6外，其他都是和ipv4配置相同的。连接就好了，如果你也是在校学生，那么，嘿嘿，我要飞得更高~~ 结束！ PS:说明一下啊，这个aws的流量并不是无限制的，一个月只有15g（上行和下行分别为15g）的，超过要扣费的。其他具体免费套餐内容参见这里. 但是你们可以用aws练手，然后再去网上租VPS,也挺便宜的。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-04-25-VPS-softether/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 如果你不够懒，那么，你就做不好一个程序员。 不说废话，先直接说怎么做吧。 友盟多渠道打包 1.首先是在AndroidManifest.xml里面添加最下面一段： &lt;?xml version=1.0 encoding=utf-8?&gt; &lt;manifest xmlns:android=http://schemas.android.com/apk/res/android   package=me.pfcstyle.helloword&gt; &lt;application  android:allowBackup=true  android:icon=@mipmap/ic_launcher  android:label=@string/app_name  android:supportsRtl=true  android:theme=@style/AppTheme&gt;  &lt;activity android:name=.MainActivity&gt;   &lt;intent-filter&gt;    &lt;action android:name=android.intent.action.MAIN/&gt;   &lt;category android:name=android.intent.category.LAUNCHER/&gt;   &lt;/intent-filter&gt;  &lt;/activity&gt;  &lt;/application&gt;  t&lt;!--这里 --&gt;  &lt;meta-data  android:name=UMENG_CHANNEL  android:value={UMENG_CHANNEL_VALUE} /&gt; &lt;/manifest&gt; 里面的{UMENG_CHANNEL_VALUE}就是渠道指示，我们配置为PlaceHolder,这样可以在build.gradle里设置productFlavors,从而让其在编译时自动变化。 2.在build.gradle设置productFlavors productFlavors {  xiaomi {}  _360 {}  baidu {}  wandoujia {}  } productFlavors.all {  flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]  } 或者这样写也是一样的： productFlavors {  xiaomi {   manifestPlaceholders = [UMENG_CHANNEL_VALUE: xiaomi]  }  _360 {   manifestPlaceholders = [UMENG_CHANNEL_VALUE: _360]  }  baidu {   manifestPlaceholders = [UMENG_CHANNEL_VALUE: baidu]  }  wandoujia {   manifestPlaceholders = [UMENG_CHANNEL_VALUE: wandoujia]  }  }  如果你想确认一下你的productFlavors是否添加成功了，你可以通过下图验证： 然后命令行定位到你的项目的根目录，执行./gradlew assembleRelease，然后就可以静静的等待各渠道打包完成了。 一些可能的问题 如果你在执行./gradlew 的时候，提示你要下载类似gradle-2.10-all(这个版本可能不同)，这个下载比较慢，而且你会发现每一个工程都要安装，这本就很不合理，看解决方法！ 去官网下载对应版本的gradle-v-all.zip，然后到工程根路径-&gt;gradle-&gt;wrapper下找到gradle-wrapper.properties，编辑最后一行的 distributionUrl=https  ://services.gradle.org/distributions/gradle-2.10-all.zip //更改为 distributionUrl=gradle-2.10-all.zip 然后将你下载好的zip包放到工程根路径-&gt;gradle-&gt;wrapper下，如图： 好了，再去执行gradlew -v ok啦，显示如下图： 除此之外 assemble 还能和 Product Flavor 结合创建新的任务，其实 assemble 是和 Build Variants 一起结合使用的，而 Build Variants = Build Type + Product Flavor ， 举个例子大家就明白了： 如果我们想打包wandoujia渠道的release版本，执行如下命令就好了： ./gradlew assembleWandoujiaRelease 如果我们只打wandoujia渠道版本，则： ./gradlew assembleWandoujia 此命令会生成wandoujia渠道的Release和Debug版本 同理我想打全部Release版本： ./gradlew assembleRelease 这条命令会把Product Flavor下的所有渠道的Release版本都打出来。 Gradle管理依赖 gradle最常用的还是管理依赖吧，看看有多简单： dependencies {  compile fileTree(dir: 'libs', include: ['*.jar'])  compile 'com.android.support:appcompat-v7:23.4.0'  compile 'com.android.support.constraint:constraint-layout:1.0.0-alpha1'  testCompile 'junit:junit:4.12'  androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'  androidTestCompile 'com.android.support.test:runner:0.5'  androidTestCompile 'com.android.support:support-annotations:23.4.0' } 直接执行上述的编译，gradle就会自动帮你下载添加到依赖，根本不用管了。这在我们使用第三方的时候就会非常方便，一句话，所有需要的jar包什么的都有了。 Gradle依赖的统一管理 那么，嘿嘿，更简单的来了，下面说一下依赖的统一管理方式。 统一一个依赖管理文件 你要先自己创建一个config.gradle文件来统一管理你的依赖和其他系统版本这些参数，注意，这个文件不是属于某一个工程的，而是属于你个人或者公司的维护的文件，在你的工程中只是引用它。 ext { android = [compileSdkVersion: 23,   buildToolsVersion: 23.0.2,   applicationId : me.storm.ninegag,   minSdkVersion : 14,   targetSdkVersion : 22,   versionCode : 2,   versionName : 1.1.0] dependencies = [support-v4   : 'com.android.support:support-v4:23.1.1',    appcompat-v7   : 'com.android.support:appcompat-v7:23.1.1',    design    : 'com.android.support:design:23.1.1',    cardview-v7   : 'com.android.support:cardview-v7:23.1.1',    recyclerview-v7  : 'com.android.support:recyclerview-v7:23.1.1',    multidex    : com.android.support:multidex:1.0.+,    butterknife   : 'com.jakewharton:butterknife:7.0.1',    volley    : 'com.mcxiaoke.volley:library:1.0.19',    okhttp    : 'com.squareup.okhttp:okhttp:2.7.0',    okhttp-urlconnection  : 'com.squareup.okhttp:okhttp-urlconnection:2.7.0',    leakcanary   : 'com.squareup.leakcanary:leakcanary-android:1.3.1',    glide    : 'com.github.bumptech.glide:glide:3.6.1',    glide-okhttp-integration : 'com.github.bumptech.glide:okhttp-integration:1.3.1',    foldable-layout  : 'com.alexvasilkov:foldable-layout:1.0.1',    etsy-grid   : 'com.etsy.android.grid:library:1.0.5'] } 上面是我的config.gradle文件，你们放你们需要的依赖以及配置其他的参数。 如何引用？ 如下图： 只需在最顶部加上上面一行代码，意思就是所有的子项目或者所有的modules都可以从这个配置文件里读取内容。 最后在到app目录下的build.gradle文件里看下具体如何读取的呢？ android节点下的读取： denpendencies节点下的读取： 参考博客：Gradle依赖的统一管理 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-05-26-Android-Studio4-Gradle/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 之前就知道闷头写项目，在项目中解决了什么问题也不知道记录，现在很是后悔，如今来总结一下，希望能够回忆起一些。 iOS开发的本地存储主要有五种形式  XML属性列表（plist)归档 Preference(偏好设置NSUserDefaults) NSKeyedArchiver归档(NSCoding) SqlLite（本地数据库） CoreData（苹果官方封装的SqlLite数据库操作接口） 上述五种本地的存储方式在我们日常编码中都非常常用，本篇文章先介绍前三种，后两种请参考我的后续博文iOS项目总结(二)-iOS本地持久化总结2 应用沙盒 要想真正了解本地数据存储，你需要先了解什么是应用沙盒。我们都知道，iOS的各个应用的文件夹是对其他应用封闭的，也就是说它的文件系统是隔离的，而这每一个应用的数据文件夹就是应用沙盒。那么，如何获取应用沙盒的路径呢？可以通过打印NSHomeDirectory()来获取应用沙盒路径。 test[15254:733802] 沙盒：/Users/developer/Library/Developer/CoreSimulator/Devices/0360A858-A0E7-45A7-AE71-09D7988C089F/data/Containers/Data/Application/2FB5B4BB-A097-411D-A8BA-6043155C171E 这里需要提醒大家注意的是，如果你是在调试，那么你每次从XCode运行应用，沙盒路径都会发生改变。我之前做项目有一个涉及到管理草稿的，当时在这个坑里跳了一整天才跳出来。。。当然，如果你的应用发布了，那么，沙盒路径就是固定不变的。 接下来我们看一下沙盒的结构，Finder的快捷键shift+com+g可以前往任意路径  Documents: 保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。例如，游戏应用可将游戏存档保存在该目录 Library/Caches: 保存应用运行时生成的需要持久化的数据，iTunes同步设备时不会备份该目录。一般存储体积大、不需要备份的非重要数据 Library/Preference: 保存应用的所有偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置信息。iTunes同步设备时会备份该目录 tmp: 保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录 Document文件夹获取 // NSDocumentDirectory 要查找的文件 枚举 // NSUserDomainMask 代表从用户文件夹下找 枚举 // 最后的Yes代表返回完整路径，No是这样的形式:~/Documents // 在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素 NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; NSString *filePath = [path stringByAppendingPathComponent:@xxx.plist]; 其他的文件夹路径的获取方式我就不一一介绍了。接下来正式说持久化方式 XML属性列表(plist)归档 plist文件只能是数组、字典、数值、字符串、Bool值这几种类型，而根类型必须是数组或者字典。 plist文件的归档 NSString *filePath = [path stringByAppendingPathComponent:@xxx.plist]; // 解档 NSArray *arr = [NSArray arrayWithContentsOfFile:filePath]; NSLog(@%@, arr); plist文件的解档 NSArray *arr = [[NSArray alloc] initWithObjects:@1, @2, nil]; // NSDocumentDirectory 要查找的文件 // NSUserDomainMask 代表从用户文件夹下找 // 在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素 NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; NSString *filePath = [path stringByAppendingPathComponent:@xxx.plist]; [arr writeToFile:filePath atomically:YES]; Preference(偏好设置NSUserDefaults) OC中有一个NSUserDefaults的单例，它可以用来存储用户的偏好设置，例如：用户名，字体的大小，用户的一些设置等。 保存用户偏好设置 // 获取用户偏好设置对象 NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; // 保存用户偏好设置 [defaults setBool:self.one.isOn forKey:@one]; [defaults setBool:self.two.isOn forKey:@two]; // 注意：UserDefaults设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。这应该是iOS7之前的问题 // 出现以上问题，可以通过调用synchornize方法强制写入 // 现在这个版本不用写也会马上写入 不过之前的版本不会 [defaults synchronize]; 读取用户偏好设置 // 读取用户偏好设置 NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; self.one.on = [defaults boolForKey:@one]; self.two.on = [defaults boolForKey:@two]; 但是要注意的是，userDefault支持的类型有限，无法直接归档自定义类型，只能是NSData、NSString、NSNumber、NSDate、NSArray、NSDictionary，所以如果你要归档自定义类型，要先转换成前面的类型才行。 NSKeyedArchiver归档(NSCoding) 只有遵守了NSCoding协议的类才可以用NSKeyedArchiver归档和NSKeyedUnarchiver解档，但如果如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型就不需要了。 下面举的是归档解档一个Account模型 实现encodeWithCoder和initWithCoder方法 @implementation Account - (void)encodeWithCoder:(NSCoder *)encoder {  [encoder encodeObject:_accessToken forKey:@accessToken];  [encoder encodeObject:[NSString stringWithFormat:@%d, _userID] forKey:@user_id]; } - (id)initWithCoder:(NSCoder *)decoder {  if (self = [super init]) {  self.accessToken = [decoder decodeObjectForKey:@accessToken];  self.userID = [[decoder decodeObjectForKey:@user_id] intValue];  }  return self; } @end 归档 _account = [[Account alloc] init]; _account.accessToken = @123456789; _account.userID = 1; [NSKeyedArchiver archiveRootObject:account toFile:kFilePath]; 解档 _account = [NSKeyedUnarchiver unarchiveObjectWithFile:kFilePath]; UserDefault和KeyArchive结合 归档 - (void)saveAccount:(Account *)account { _account = account; NSData *data = [NSKeyedArchiver archivedDataWithRootObject:account]; NSUserDefaults *user = [NSUserDefaults standardUserDefaults]; [user setObject:data forKey:@kAccount]; } 解档 NSUserDefaults *user = [NSUserDefaults standardUserDefaults]; NSData *data = [user objectForKey:@kAccount]; _account = [NSKeyedUnarchiver unarchiveObjectWithData:data]; 嗯，是的，好吧 没有任何优点，反正就是能用userdefault存储了。。。。 参考博文：iOS开发中本地数据存储的总结 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-06-09-iOS-Project-Sumary1/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； iOS开发的本地存储主要有五种形式  XML属性列表（plist)归档 Preference(偏好设置NSUserDefaults) NSKeyedArchiver归档(NSCoding) SqlLite（本地数据库） Core Data（苹果官方封装的SqlLite数据库操作接口） 上述五种本地的存储方式在我们日常编码中都非常常用，前三种已经在上篇博文iOS项目总结(一)-iOS本地持久化总结1中介绍了，今天开始说后两种SqlLite和Core Data. SqlLite（本地数据库） SQLite作为一中小型数据库，主要应用在移动端中，跟前三种保存方式相比，使用相对比较复杂一些，但如果你有数据库基础，这个其实也是小菜一碟了。下面看一下如何使用 1.添加libsqlite3.tbd依赖，并在对应的操作文件中导入#import “sqlite3.h” 2.打开数据库 - (void)openDB{  sqlite3 *db; //声明一个sqlite3数据库 这个其实要全局的 就这样写吧，大家知道就好  ///文件是否存在  NSFileManager* fileManager = [NSFileManager defaultManager];  //这里filePath是自己定义的路径，一般在沙箱的Documents里面操作，不明白沙箱的请移步我的上篇博文  NSString *dbpath=[self filePath];  //文件是否存在  BOOL success = [fileManager fileExistsAtPath:dbpath];  if (!success) {//不存在就复制过来一个  NSString *resourcePath=[[NSBundle mainBundle]resourcePath];  //复制  NSString *sourceDBPath=[resourcePath stringByAppendingPathComponent:@app.bundle/datas.sqlite];  NSError *error;  success = [fileManager copyItemAtPath:sourceDBPath toPath:dbpath error:&amp;error];  if(!success)  NSAssert1(0,@数据库附加失败！'%@'., [error localizedDescription]);  else  NSLog(@数据库附加成功:%@,dbpath);  }  //打开数据库  if (sqlite3_open([[self filePath] UTF8String], &amp;db) != SQLITE_OK) {  sqlite3_close(db);  NSAssert(0, @数据库打开失败。);  } } 3.执行sql语句 sqlite3 *db; //声明一个sqlite3数据库 这个是全局的 跟上同 //这里是模拟写了一个查找所有类型的操作 NSString *sql = @SELECT * FROM km_types; sqlite3_stmt *statement; //执行sql语句 返回成功或者失败 if (sqlite3_prepare_v2(db, [sql UTF8String], -1, &amp;statement, nil) == SQLITE_OK) {  //指针一行行下行  while (sqlite3_step(statement) == SQLITE_ROW) {  KMTypes* k= [[KMTypes alloc]init];  //按照类型取出对应字段  int type_id = (int)sqlite3_column_int(statement,0);  int parent_id = (int)sqlite3_column_int(statement,1);  char *type_title = (char *)sqlite3_column_text(statement, 2);  int type_order = (int)sqlite3_column_int(statement,3);  int topic_count=(int)sqlite3_column_int(statement,4);  //这里注意转换字符串编码  NSString *type_titleStr = [[NSString alloc] initWithUTF8String:type_title];  k.type_title = type_titleStr;  k.type_id=type_id;  k.parent_id = parent_id;  k.type_order = type_order;  k.topic_count=topic_count; [array addObject:k]; } //完成操作 sqlite3_finalize(statement); } //最后一定要关闭数据库 sqlite3_close(db) 这就是SQLite的基础操作了，其实挺简单的，但是可能数据存取，表的创建等还是有点繁琐，我们看下Core Data。 Core Data使用 Core Data实际上是对SQLite的操作封装，让我们更加易用，它完全不需要sql语句，因此，哪怕你没有数据库基础，用起来也是毫不费力。 1.添加实体和模型 首先你在创建项目的时候应该选在使用Core Data，这个就不再贴图了。如果你想在现成的项目中添加Core Data,你需要添加一下CoreData.framework的依赖，在pch文件中添加#import&lt;CoreData/CoreData.h&gt;，然后添加appdelegata的相关内容，你可以自己重新创建一个带有Core Data的工程，直接复制过来就行。最后再手动添加一个Core Data Model文件 创建Data Model文件时需要注意，文件名称要与AppDelegate.m中managedObjectModel方法中提到的文件名称相匹配，一般是你的工程名.momd 有了Data Model文件后，就可以在里面添加实体和关系，实际上就是向数据库中添加表格和建立表格之间的关联。添加实体如图所示： 每个学生有一个所在的班级，每个班级中有多个学生，因此，学生和班级之间可以建立关系。建立关系如图所示： 建立关系之后，可以切换显示的样式，以图表的方式查看实体之间的关系，如图所示： 这样就创建好了表格以及字段了，省却了sql语句。接下来自动创建数据模型类。 2.生成数据模型类 创建好实体后，可以通过添加NSManagedObject subclass文件，系统可以自动添加实体对应的数据模型类，如图所示：  3.CoreData的代码操作 介绍一下appdeldgate中自动生成的代码 - (void)applicationWillTerminate:(UIApplication *)application {  //保存数据到持久层  [self saveContext]; } - (void)saveContext {  NSError *error = nil;  NSManagedObjectContext *managedObjectContext = self.managedObjectContext;  if (managedObjectContext != nil) {  if ([managedObjectContext hasChanges] &amp;&amp; ![managedObjectContext save:&amp;error]) {   NSLog(@Unresolved error %@, %@, error, [error userInfo]);   abort();  } } } - (NSURL *)applicationDocumentsDirectory { //获取Documents的目录路径  return [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject]; } /** *被管理的数据上下文 *初始化的后，必须设置持久化存储助理 */ - (NSManagedObjectContext *)managedObjectContext {  if (__managedObjectContext != nil) {  return __managedObjectContext;  }  NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];  if (coordinator != nil) {  __managedObjectContext = [[NSManagedObjectContext alloc] init];  [__managedObjectContext setPersistentStoreCoordinator:coordinator];  }  return __managedObjectContext; } /** 被管理的数据模型 初始化必须依赖.momd文件路径，而.momd文件由.xcdatamodeld文件编译而来 */ - (NSManagedObjectModel *)managedObjectModel {  if (__managedObjectModel != nil) {  return __managedObjectModel;  }  NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@TestApp withExtension:@momd];  __managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];  return __managedObjectModel; } /** 持久化存储助理 初始化必须依赖NSManagedObjectModel，之后要指定持久化存储的数据类型，默认的是NSSQLiteStoreType，即SQLite数据库；并指定存储路径为Documents目录下，以及数据库名称 */ - (NSPersistentStoreCoordinator *)persistentStoreCoordinator {  if (__persistentStoreCoordinator != nil) {  return __persistentStoreCoordinator;  }  NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@TestApp.sqlite]; NSError *error = nil;  __persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]]; if (![__persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&amp;error]) {  NSLog(@Unresolved error %@, %@, error, [error userInfo]);  abort();  }  return __persistentStoreCoordinator; } 没有生成数据模型类的时候可以使用KVC来插入和查找 插入数据 - (void)insertCoreData {  NSManagedObjectContext *context = [self managedObjectContext]; NSManagedObject *student = [NSEntityDescription insertNewObjectForEntityForName:@Student inManagedObjectContext:context];  [student setValue:@1 forKey:@id];  [student setValue:@name A forKey:@name]; NSManagedObject *Class = [NSEntityDescription insertNewObjectForEntityForName:@Class inManagedObjectContext:context];  [Class setValue:@1 forKey:@id];  [Class setValue:@name B forKey:@name];  [Class setValue:student forKey:@student]; NSError *error;  if(![context save:&amp;error])  {  NSLog(@不能保存：%@,[error localizedDescription]);  } } 查找数据 - (void)dataFetchRequest {  NSManagedObjectContext *context = [self managedObjectContext];  NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];  NSEntityDescription *entity = [NSEntityDescription entityForName:@ContactInfo inManagedObjectContext:context];  [fetchRequest setEntity:entity];  NSError *error;  NSArray *fetchedObjects = [context executeFetchRequest:fetchRequest error:&amp;error];  for (NSManagedObject *info in fetchedObjects) {  NSLog(@name:%@, [info valueForKey:@name]);  } } 生成数据模型类之后 插入数据 - (void)insertCoreData {  NSManagedObjectContext *context = [self managedObjectContext]; Student *student = [NSEntityDescription insertNewObjectForEntityForName:@Student inManagedObjectContext:context];  student.id = 1;  student.name = @name A; Class *class = [NSEntityDescription insertNewObjectForEntityForName:@Class inManagedObjectContext:context];  class.id = 1;  class.name = @name B; class.student = student; NSError *error;  if(![context save:&amp;error])  {  NSLog(@不能保存：%@,[error localizedDescription]);  } } 查找数据也是类似，这里就不再赘述了。 参考博文： IOS 数据存储之 Core Data详解 iphone数据存储之－－ Core Data的使用（一） ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-06-10-iOS-Project-Sumary2/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 前段时间做了一个新加坡的电商项目，要求添加Google和Facebook的第三方登陆支持，我看国内介绍不多，也不够详细，在这里介绍一下。 Facebook 先说下Facebook的，我发现Facebook竟然提供了中文版的新手入门文档，所以大家也不用觉得难啃了，我在这里就简单说一下流程与我遇到的问题，大家参考上面的文档就好了(不要跟我讲翻不了墙，翻不了墙你还是不要集成了，集成了也登陆不上啊。。。)。  下载 SDK 创建 Facebook 应用 应用程序设置 添加 SDK 配置 Xcode 连接应用程序委托 添加应用事件 首先，在下载的SDK中是有一个示例工程的，所以大家如果遇到了什么解决不了的问题，可以去参考里面的示例工程。 仔细想想facebook好像没有遇到什么问题，大家按照上面来吧。如果遇到问题，可以在下面留言。如果大家只是需要集成登陆功能，只需要添加FBSDKCoreKit.framework和FBSDKLoginKit.framework即可。 Google Google没有提供中文文档，我这里详细说一下流程。 下载SDK 首先去下载Googel的最新版SDK。下载完毕了，本页面不要关闭，一会儿还有用。下载的SDK中也是包含有可以直接运行的示例工程的，大家多做参考。 添加SDK 将SDK解压，加入到你的工程中，如下图： 配置Xcode 1.添加下面这些frameworks  AddressBook.framework SafariServices.framework SystemConfiguration.framework libz.tbd 我只能说Google有点坑，libz.tbd在文档中没有提到。。。害得浪费我半天时间。所以还是使用pods好啊，可以自动帮你配置所需的依赖，但是我在使用pods的时候却无法下载Google的sdk,而且我确定我翻墙成功了，如果有朋友知道为什么，还请不吝赐教. 2.添加Objc linker flag到build setting  Other Linker Flags: $(OTHER_LDFLAGS) -ObjC  3.注册你的app到管理中心 4.下载你的app的配置文件 在刚刚下载sdk的页面往下，可以获得你的app的配置文件  那么这个config文件到底是什么的，其实它记录的是你的app的相关信息，其中最重要的是你的app的client_id和reserveclient_id. 5.添加URL scheme到你的项目 好了，至此就算是配置完毕了，接下来可以写代码来调用Google的登陆了。 Google登陆的使用 1.在appdelegate.m中导入#import &lt;GoogleSignIn/GoogleSignIn.h&gt; 2.设置GGLContext - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { NSError* configureError; [[GGLContext sharedInstance] configureWithError: &amp;configureError]; NSAssert(!configureError, @Error configuring Google services: %@, configureError); [GIDSignIn sharedInstance].delegate = self; return YES; } 3.实现回调 - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary *)options {  return [[GIDSignIn sharedInstance] handleURL:url  sourceApplication:options[UIApplicationOpenURLOptionsSourceApplicationKey]  annotation:options[UIApplicationOpenURLOptionsAnnotationKey]]; } //如果你是使用的iOS8或者更老的版本，使用下面的 //这里比较郁闷的是facebook只是提供了老版本的接口。。。没有提供上面的代理实现 //所以我最后都是用的下面的这个 索性没有出问题 - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { return [[GIDSignIn sharedInstance] handleURL:url sourceApplication:sourceApplication annotation:annotation]; } 好的，那么问题来了，当你同时使用Google和Facebook时，如何判断是谁的回调呢？看解决方式 - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation {  if ([url.absoluteString rangeOfString:kGoogleReversedClientID].location != NSNotFound) {  //Google的回调  return [[GIDSignIn sharedInstance] handleURL:url  sourceApplication:sourceApplication  annotation:annotation];  }else{//facebook的回调  return [[FBSDKApplicationDelegate sharedInstance] application:application  openURL:url  sourceApplication:sourceApplication  annotation:annotation  ]; } } sharesdk是不是也是用的这种方式呢？难道被我猜到了？嘿嘿。 4.好了，现在到你的登陆界面，正式使用登陆按钮 //实现代理 @interface ViewController : UIViewController &lt;GIDSignInUIDelegate&gt; //在didload方法中设置代理 - (void)viewDidLoad { [super viewDidLoad]; // TODO(developer) Configure the sign-in button look/feel [GIDSignIn sharedInstance].uiDelegate = self; // 不推荐使用自动登陆 /** When users silently sign in, the Sign-In SDK automatically acquires access tokens and automatically refreshes them when necessary. If you need the access token and want the SDK to automatically handle refreshing it, you can use the getAccessTokenWithHandler: method. To explicitly refresh the access token, call the refreshAccessTokenWithHandler: method. */ //上面这段话是官网上的，大概是说如果你使用了自动登陆，你可以通过getAccessTokenWithHandler: //这个函数获取access token并且让SDK自动更新access token,如果你想要立刻更新，你可以使用 //refreshAccessTokenWithHandler: //[[GIDSignIn sharedInstance] signInSilently]; } 5.实现代理方法 //这些我就不再解释了 很好理解 // Stop the UIActivityIndicatorView animation that was started when the user // pressed the Sign In button - (void)signInWillDispatch:(GIDSignIn *)signIn error:(NSError *)error {  [myActivityIndicator stopAnimating]; } // Present a view that prompts the user to sign in with Google - (void)signIn:(GIDSignIn *)signIn  presentViewController:(UIViewController *)viewController {  [self presentViewController:viewController animated:YES completion:nil]; } // Dismiss the Sign in with Google view - (void)signIn:(GIDSignIn *)signIn  dismissViewController:(UIViewController *)viewController {  [self dismissViewControllerAnimated:YES completion:nil]; } 6.自定义button Google提供的button叫做GIDSignInButton，好吧，扯淡，把我也欺骗了，这货的父类是UIControl,当时知道真相的我眼泪掉下来（我在storyboard里翻了半天啊＝＝）。那么所谓的自定义就是设置这货的属性了。 //好吧 只有这俩属性 具体使用方式你们可以参考示例项目 // The layout style for the sign-in button. // Possible values: // - kGIDSignInButtonStyleStandard: 230 x 48 (default) // - kGIDSignInButtonStyleWide:  312 x 48 // - kGIDSignInButtonStyleIconOnly: 48 x 48 (no text, fixed size) @property(nonatomic, assign) GIDSignInButtonStyle style; // The color scheme for the sign-in button. // Possible values: // - kGIDSignInButtonColorSchemeDark // - kGIDSignInButtonColorSchemeLight (default) @property(nonatomic, assign) GIDSignInButtonColorScheme colorScheme; 当然，我是一直坚信没有无法自定义的view的，请移步iOS一些小技巧及小知识点总结。 PS：后来我发现Google的登录按钮其实可以使用自己的按钮，你只需要在按钮事件中添加[[GIDSignIn sharedInstance] signIn]即可，当然，其他的代理仍然是需要实现的。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-06-11-iOS-Project-Sumary3/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 今天在应用里添加一个异常捕获类，以方便测试人员在没有xcode的情况下也可以直接看到错误日志。先说一下原理： Signal是什么 iOS SDK中提供了一个现成的函数 NSSetUncaughtExceptionHandler 用来做异常处理，但功能非常有限，而引起崩溃的大多数原因如：内存访问错误，重复释放等错误就无能为力了。因为这种错误它抛出的是Signal，所以必须要专门做Signal处理。 在计算机科学中， 信号 （ 英语： Signals）是Unix、类Unix以及其他POSIX兼容的操作系统中进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。 信号处理函数可以通过 signal() 系统调用来设置。如果没有为一个信号设置对应的处理函数，就会使用默认的处理函数，否则信号就被进程截获并调用相应的处理函数。在没有处理函数的情况下，程序可以指定两种行为：忽略这个信号 SIG_IGN 或者用默认的处理函数 SIG_DFL 。但是有两个信号是无法被截获并处理的： SIGKILL、SIGSTOP 。 信号的类型 SIGABRT–程序中止命令中止信号 SIGALRM–程序超时信号 SIGFPE–程序浮点异常信号 SIGILL–程序非法指令信号 SIGHUP–程序终端中止信号 SIGINT–程序键盘中断信号 SIGKILL–程序结束接收中止信号 SIGTERM–程序kill中止信号 SIGSTOP–程序键盘中止信号 SIGSEGV–程序无效内存中止信号 SIGBUS–程序内存字节未对齐中止信号 SIGPIPE–程序Socket发送失败中止信号 如何实现 废话不多说了，直接上代码，不懂的看注释就可以了。 //UncaughtExceptionHandl.h #import &lt;UIKit/UIKit.h&gt; @interface UncaughtExceptionHandl : NSObject{  tBOOL dismissed; } @end void HandleException(NSException *exception); void SignalHandler(int signal); void InstallUncaughtExceptionHandler(void); //UncaughtExceptionHandl.m #import UncaughtExceptionHandl.h #include &lt;libkern/OSAtomic.h&gt; #include &lt;execinfo.h&gt; #import AppDelegate.h NSString * const UncaughtExceptionHandlerSignalExceptionName = @UncaughtExceptionHandlerSignalExceptionName; NSString * const UncaughtExceptionHandlerSignalKey = @UncaughtExceptionHandlerSignalKey; NSString * const UncaughtExceptionHandlerAddressesKey = @UncaughtExceptionHandlerAddressesKey; //当前处理的异常个数 volatile int32_t UncaughtExceptionCount = 0; //能够处理的最大异常个数 const int32_t UncaughtExceptionMaximum = 10; const NSInteger UncaughtExceptionHandlerSkipAddressCount = 4; const NSInteger UncaughtExceptionHandlerReportAddressCount = 5; @interface UncaughtExceptionHandl() //计时器 @property (strong, nonatomic) NSTimer *countDurTimer; @end @implementation UncaughtExceptionHandl + (NSArray *)backtrace {  void* callstack[128];  int frames = backtrace(callstack, 128);  char **strs = backtrace_symbols(callstack, frames);  int i;  NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];  for (  i = UncaughtExceptionHandlerSkipAddressCount;  i &lt; UncaughtExceptionHandlerSkipAddressCount +  UncaughtExceptionHandlerReportAddressCount;  i++)  {  [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];  }  free(strs);  return backtrace; } - (void)alertView:(UIAlertView *)anAlertView clickedButtonAtIndex:(NSInteger)anIndex {  if (anIndex == 0)  {  dismissed = YES;  }else{  dismissed = YES;  AppDelegate *app = [[UIApplication sharedApplication] delegate];  app.mainViewController = [[MainTabBarController alloc] init];  app.window.rootViewController = app.mainViewController;  [app.mainViewController exchangeTabbarHightFromSetSystemTextFont:nil];  } } - (void)validateAndSaveCriticalApplicationData { } //捕获信号后的回调函数 由HandleException调用 - (void)handleException:(NSException *)exception {  [self validateAndSaveCriticalApplicationData];  NSString *reason = [exception reason];  NSString *name = [exception name];  UIAlertView *alert =  [[[UIAlertView alloc]  initWithTitle:@tip  message:[NSString stringWithFormat:@CRASH: %@ name:%@,  Reason: %@,  Stack Trace: %@,  ,exception,name,reason,[exception callStackSymbols]]  delegate:self  cancelButtonTitle:NSLocalizedString(@Quit, nil)  otherButtonTitles:NSLocalizedString(@Continue, nil), nil] autorelease];  [alert show];  //或者直接用代码，输入这个崩溃信息，以便在console中进一步分析错误原因  //当接收到异常处理消息是，让程序开始runloop，防止程序死亡  CFRunLoopRef runLoop = CFRunLoopGetCurrent();  CFArrayRef allModes = CFRunLoopCopyAllModes(runLoop);  while (!dismissed)  {  for (NSString *mode in (NSArray *)allModes)  {   CFRunLoopRunInMode((CFStringRef)mode, 0.001, false);  }  }  CFRelease(allModes);  NSSetUncaughtExceptionHandler(NULL);  signal(SIGABRT, SIG_DFL);  signal(SIGILL, SIG_DFL);  signal(SIGSEGV, SIG_DFL);  signal(SIGFPE, SIG_DFL);  signal(SIGBUS, SIG_DFL);  signal(SIGPIPE, SIG_DFL);  if ([[exception name] isEqual:UncaughtExceptionHandlerSignalExceptionName])  {  kill(getpid(), [[[exception userInfo] objectForKey:UncaughtExceptionHandlerSignalKey] intValue]);  }  else  {  [exception raise];  } } @end //捕获信号后的回调函数 void HandleException(NSException *exception) {  int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount);  if (exceptionCount &gt; UncaughtExceptionMaximum)  {  return;  } NSArray *callStack = [UncaughtExceptionHandl backtrace];  NSMutableDictionary *userInfo =  [NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];  [userInfo  setObject:callStack  forKey:UncaughtExceptionHandlerAddressesKey]; [[[[UncaughtExceptionHandl alloc] init] autorelease]  performSelectorOnMainThread:@selector(handleException:)  withObject:   [NSException    exceptionWithName:[exception name]    reason:[exception reason]    userInfo:userInfo]  waitUntilDone:YES]; } void SignalHandler(int signal) {  int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount);  if (exceptionCount &gt; UncaughtExceptionMaximum)  {  return;  }  NSMutableDictionary *userInfo =  [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];  NSArray *callStack = [UncaughtExceptionHandl backtrace];  [userInfo setObject:callStack forKey:UncaughtExceptionHandlerAddressesKey];  [[[[UncaughtExceptionHandl alloc] init] autorelease] performSelectorOnMainThread:@selector(handleException:) withObject: [NSException  exceptionWithName:UncaughtExceptionHandlerSignalExceptionName  reason:  [NSString stringWithFormat:  NSLocalizedString(@Signal %d was raised., nil),  signal]  userInfo:  [NSDictionary  dictionaryWithObject:[NSNumber numberWithInt:signal]  forKey:UncaughtExceptionHandlerSignalKey]] waitUntilDone:YES]; } //SIGABRT--程序中止命令中止信号 //SIGALRM--程序超时信号 //SIGFPE--程序浮点异常信号 //SIGILL--程序非法指令信号 //SIGHUP--程序终端中止信号 //SIGINT--程序键盘中断信号 //SIGKILL--程序结束接收中止信号 //SIGTERM--程序kill中止信号 //SIGSTOP--程序键盘中止信号 //SIGSEGV--程序无效内存中止信号 //SIGBUS--程序内存字节未对齐中止信号 //SIGPIPE--程序Socket发送失败中止信号 void InstallUncaughtExceptionHandler(void) {  NSSetUncaughtExceptionHandler(&amp;HandleException);  signal(SIGABRT, SignalHandler);  signal(SIGILL, SignalHandler);  signal(SIGSEGV, SignalHandler);  signal(SIGFPE, SignalHandler);  signal(SIGBUS, SignalHandler);  signal(SIGPIPE, SignalHandler); } 使用方法：直接在你的appdelegate的didfinishlaunch函数中添加 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { ... InstallUncaughtExceptionHandler(); ... return YES; } 注意，这里由于使用了C++的库，所以，如果你是纯OC应用，你的buil settings中应该默认配置是这样的： 那么，你很幸运，什么也不需要调整，直接用就好了。 但是，如果你混编的，而且不得不使用libstdc++,就是build settings中是这样的： 请你记得将UncaughtExceptionHandl.m改为UncaughtExceptionHandl.mm，否则会报Undefined symbols for architecture arm64错误，这本该是常识的，但是当你刚刚接触一个新项目，可能还没有反应过来，往往会浪费很多时间，找错方向。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-06-18-iOS-Project-Sumary4/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 在做项目的时候，经常会遇到duplicate symbols for architecture armvxx, Undefined symbols for architecture armxx等的问题，尤其是在添加第三方库的时候，给人一种措手不及的感觉。今天我将总结一下为什么会出现这样的问题，以及如何解决。 armxx这些都是什么？ 这些其实都是iOS设备的指令集，每一种指令集其实都是对应一类处理器硬件，这些所谓的指令，其实就是汇编指令，只是不同指令集会略有不同，导致各个指令集无法完全兼容，相互混用。但是，一般来说，这些指令集是自上而下能够完整兼容的。下面是指令集的介绍： armv6 – iPhone – iPhone2 – iPhone3G – 第一代和第二代iPod Touch armv7 – iPhone4 – iPhone4S armv7s – iPhone5 – iPhone5C – arm64 – iPhone5S Xcode的相关配置 在build settings中的第一个配置项就是arm相关的，解释如下： Architecture ： 指你想支持的指令集。 Valid architectures : 指即将编译的指令集。 Build Active Architecture Only : 只是否只编译当前适用的指令集。 只有在目标设备上，才会执行设备对应的指令集。 如果在工程Build Setting的Architectures 中的“Build Active Architecture Only”选择为YES，则即使你设置成armv7 , armv7s同时支持，也只会编译对应指令集的包；若选择NO，则编译器会整合两个指令集到一起，此时的包比较大，但是能在iPhone5上使用armv7s的优化，同时也能适配老的设备。一般都是Debug时“Build Active Architecture Only”选择YES，用当前的架构看代码逻辑是否有问题；而在Release时选择NO，来适配不同的设备。 此外，模拟器并不运行arm代码，软件会被编译成x86可以运行的指令。所以生成静态库时都是会先生成两个.a，一个是i386的用于在模拟器运行，另一个是在真实设备上运行的，然后再用命令将两个.a合并成一个。 可能出现的问题 那么，可能出现的问题及原因也就很容易明白了。  Undefined symbols for architecture arm64 1.你的静态库不支持arm64,但是你的工程支持ram64。  t这样你只能选择替换支持arm64的静态库了，因为现在苹果上架也是要求必须支持64位，所以你没得选择。 2.OC与C++混编的时候，调用C++的OC类的实现文件没有更改后缀名为.mm 更多可能与解决方案  duplicate symbols for architecture armv64 1.文件名重复 2.检查是否在#import头文件的时候，不小心把.h写成了.m。 3.build settings中，other linker flags 设置的重复，比如同时包含 -all_load和-ObjC，将-all_load删去即可 注意，这里第三种解决方式并不完美，这样做的话，会使一些外部的静态库，使用objc扩展函数(catagory)的方法失效。例如BaiduMapApi。 如果是有些库使用到了扩展函数(catagory)可以分别对这个库进行加载 使用：-force_load -force_load BaiduMapApi/libs/Release-iphoneos/libbaidumapapi.a (BaiduMapApi是添加到当前目录下的) 或 -force_load $(BUILT_PRODUCTS_DIR)/libxxx.a (这里是直接添加静态库项目源码的做法) 参考博客： armv6, armv7, armv7s的区别 duplicate symbols for architecture armv7解决办法 iOS解决两个静态库的冲突 duplicate symbol ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-06-19-iOS-Project-Sumary5/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 今天项目提交app store被拒了，总结一下原因。邮件说的原因很明白：  invalid Swift Support - The SwiftSupport folder is missing. Rebuild your app using the current public (GM) version of Xcode and resubmit it. 这里先总结一下OC项目使用swift代码如何配置：  导入swift文件，xcode会自动提示生成一个oc桥接头文件，点击创建，会自动创建一个项目名-Bridging-Header.h 使用时直接引入这个头文件即可，可以像OC一样直接调用swift函数。 在buildsettings中，设置EMBEDDED_CONTENT_CONTAINS_SWIFT = yes 一般来说，设置好上述的3点，使用以及到最后打包都不会有问题了，但是我们还就是出了问题，总结一下。  archive之后export时选择Export as an Xcode Archive就会在archive包中自动包含swiftsupport文件夹，上面说这个文件夹miss了，就是因为我们选择了Save Build Products(我们的问题有点傻，因为第一次提交吗，也算是提醒一下新手吧。当然，如果你们是使用脚本打的包，也会出现类似的问题，手动放进去即可。)  swiftsupport中不可以包含libswiftXCTest.dylib，这是app store不允许的，因此，你应该确保你的swiftsupport中没有这个东西。如果有的话，参考下面的解决方案：   Open your Xcode project  Select Product &gt; Scheme &gt; Edit Scheme  Click Build in the left sidebar  For your test target, uncheck the  tArchive checkbox  Click the Close button  Select Product &gt; Archive  Submit the latest archive to the App  tStore   ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-06-23-iOS-Project-Sumary6/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； iOS提交应用至App Store流程 最快让你上手ReactiveCocoa之基础篇 FMDB 使用方法 关于Xcode打包为Generic Xcode Archive 以及 Xcode打包按钮灰色的解决方法 git 创建分支提交远程分支 Restoration Classes and UIWebViews(保存webview的状态) ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-06-24-iOS-Project-Sumary7/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 今天被分了一个bug,说是iphone4s上的启动画面黑屏，本来想着应该是小菜一碟，因为凭本大侠的水平，怎么可能会搞不定一个静态的启动画面，结果，一整天就这样过去了==！不过好在在下班前1小时搞定了，来做一下总结，日了狗~ 我的问题 首先说我的问题，非常的amazing。我们的应用是要求同时支持横竖屏的，但是刚开始我们只要求支持横屏，后来又不得不添加竖屏。配置就是我们在target&gt;general&gt;device orientation中又多勾选了一个竖屏(当然，同时支持横竖屏只打个勾是远远不够的，需要你精确控制，这个网上很多，跟本文无关)，然后，打印4s的屏幕尺寸，你会发现这货是横屏的尺寸，因此，根本无法显示启动图(配置的启动图里没有4s的横屏)。解决方式很简单，把device orientation全取消，按顺序，先选择Portrait,然后选择Landscape Left和Landscape Right,记住，顺序很重要！！！你会发现你的启动图出来了！！（从这也可以看出来，苹果的配置文件大部分是字典存储，但是遇到这种多选的，显然是按照队列的方式进行存取的，默认是选择第一个选项） 启动画面的适配总结 iOS7之前(use asset catalog) iOS8之前我们使用use asset catalog，什么意思呢，简单来说就是最传统的UI做了一堆不同屏幕的图，然后按照苹果官方命名好，添加到你的资源文件夹中，然后Xcode里这样配置： 那么你启动的时候，就会发现启动界面已经弄好了。但是现在不能用了，因为你会发现，当你在plus运行的时候，你的界面整体放大了！所以，现在这种方式一般是和Launch Screen.xib或者Launch Screen.storyboard 一起使用，下面说。 iOS7以后(xib或者storyboard 与 use asset catalog一起(兼容iOS7以下)) 如果你需要兼容iOS7以下，那么你还需要把上述的也弄一下，去适配相应的硬件。但是如果你不需要，那么你只需要使用Launch Screen.storyboard 或者 Lauch Screen.xib即可，使用autolayout和sizeclass来进行约束适配即可。配置如下： 都可以使用的(images.xcassts的launch images) 我们项目就是使用本方式，在images.xcassts中右键选择App Icons &amp; Launch Images&gt;new iOS launch image新建Launch Images,创建好了效果如下： 在右侧选择你需要适配的所有系统版本，然后填充上对应大小的启动界面即可。注意我的上述问题。 其他问题总结(针对方式3) 在我解决我的问题的时候，也是走了不少弯路，总结一下其他可能问题。 1.png图的格式问题 判断方法：打开图片(双击，默认就是使用preview.app打开的),ctrl+i，查看信息，如果你的图片有问题，是这样的： 没有问题的： 有问题就重换喽。 2.Launch Screen File没有置空 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-06-28-iOS-Project-Sumary8/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 苹果官方提供了Reachbility可以直接用来判断网络状态，这里分析一下。 Reachability主要使用的是&lt;SystemConfiguration/SystemConfiguration.h&gt;，所以你在使用的时候应该添加SystemConfiguration.framework文件依赖。我们倒着分析： //很明显这里是作为一个回调函数，其功能是在网络状态发生变化的时候就发出通知 static void ReachabilityCallback(SCNetworkReachabilityRef target, SCNetworkReachabilityFlags flags, void* info) { #pragma unused (target, flags)  tNSCAssert(info != NULL, @info was NULL in ReachabilityCallback);  tNSCAssert([(__bridge NSObject*) info isKindOfClass: [Reachability class]], @info was wrong class in ReachabilityCallback); Reachability* noteObject = (__bridge Reachability *)info;  // Post a notification to notify the client that the network reachability changed.  [[NSNotificationCenter defaultCenter] postNotificationName: kReachabilityChangedNotification object: noteObject]; } 接下来我们按图索骥，找到这个回调是在哪里执行。 //这里是开始通知的函数，可以看到，上面的回调就是在这里设置的 - (BOOL)startNotifier {  tBOOL returnValue = NO;  tSCNetworkReachabilityContext context = {0, (__bridge void *)(self), NULL, NULL, NULL}; //第一个参数是主机地址的句柄，用于监听主机状态 //第二个参数就是回调了  tif (SCNetworkReachabilitySetCallback(_reachabilityRef, ReachabilityCallback, &amp;context))  t{  t//使监听在mainrunloop中运行 异步  t tif (SCNetworkReachabilityScheduleWithRunLoop(_reachabilityRef, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode))  t t{  t t treturnValue = YES;  t t}  t}  treturn returnValue; } 好了，流程就是这么简单，我们再看一下初始化 + (instancetype)reachabilityWithHostName:(NSString *)hostName {  tReachability* returnValue = NULL;  t//这里是创建主机地址的操作句柄，第一个参数是分配器，null表示使用默认，第二个参数就是主机地址了  tSCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(NULL, [hostName UTF8String]);  tif (reachability != NULL)  t{  t treturnValue= [[self alloc] init];  t tif (returnValue != NULL)  t t{  t t treturnValue-&gt;_reachabilityRef = reachability;  t t treturnValue-&gt;_alwaysReturnLocalWiFiStatus = NO;  t t}  t}  treturn returnValue; } 调用当前状态 //这里主要是分析flag的去向 - (NetworkStatus)currentReachabilityStatus {  tNSAssert(_reachabilityRef != NULL, @currentNetworkStatus called with NULL SCNetworkReachabilityRef);  tNetworkStatus returnValue = NotReachable;  tSCNetworkReachabilityFlags flags;  tif (SCNetworkReachabilityGetFlags(_reachabilityRef, &amp;flags))  t{  t tif (_alwaysReturnLocalWiFiStatus)  t t{  t t treturnValue = [self localWiFiStatusForFlags:flags];  t t}  t telse  t t{  t t treturnValue = [self networkStatusForFlags:flags];  t t}  t}  treturn returnValue; } flag的去向，我们找一个讲解 //可以看到，这里都是与kSCNetworkReachabilityFlags进行与操作，判断是否是对应状态。 - (NetworkStatus)localWiFiStatusForFlags:(SCNetworkReachabilityFlags)flags {  tPrintReachabilityFlags(flags, localWiFiStatusForFlags);  tNetworkStatus returnValue = NotReachable;  tif ((flags &amp; kSCNetworkReachabilityFlagsReachable) &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsIsDirect))  t{  t treturnValue = ReachableViaWiFi;  t}  treturn returnValue; } ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-07-04-iOS-Project-Sumary9/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 引言 H.264的主要目标： 1．高的视频压缩比 2．良好的网络亲和性 解决方案： VCL video codinglayer  视频编码层 NAL network abstraction layer 网络提取层 VCL：核心算法引擎，块，宏块及片的语法级别的定义 NAL：片级以上的语法级别（如序列参数集和图像参数集），同时支持以下功能：独立片解码，起始码唯一保证，SEI以及流格式编码数据传送 VCL设计目标：尽可能地独立于网络的情况下进行高效的编解码 NAL设计目标：根据不同的网络把数据打包成相应的格式，将VCL产生的比特字符串适配到各种各样的网络和多元环境中。 NALU头结构：NALU类型(5bit)、重要性指示位(2bit)、禁止位(1bit)。 NALU类型：1～12由H.264使用，24～31由H.264以外的应用使用。 重要性指示：标志该NAL单元用于重建时的重要性，值越大，越重要。 禁止位：网络发现NAL单元有比特错误时可设置该比特为1，以便接收方丢掉该单元。 NAL语法语义 NAL层句法： 在编码器输出的码流中，数据的基本单元是句法元素。 句法表征句法元素的组织结构。 语义阐述句法元素的具体含义。 分组都有头部，解码器可以很方便的检测出NAL的分界，依次取出NAL进行解码。 但为了节省码流，H.264没有另外在NAL的头部设立表示起始位置的句法元素。 如果编码数据是存储在介质上的，由于AL是依次紧密相连的，解码器就无法在数据流中分辨出每个NAL的起始位置和终止位置。 解决方案：在每个NAL前添加起始码：0X000001 在某些类型的介质上，为了寻址的方便，要求数据流在长度上对齐，或某个常数的整数倍。所以在起始码前添加若干字节的0来填充。 检测NAL的开始： 0X000001和0X00000001 我们必须考虑当NAL内部出现了0X000001和0X000000 如果NALU对应的Slice为一帧的开始，则用4字节表示，即0x00000001；否则用3字节表示，0x000001。 解决方案：为了防止NAL内部出现0x000001的数据，h.264又提出’防止竞争 emulation prevention”机制.在编码完一个NAL时，如果检测出有连续两个0x00字节，就在后面插入一个0x03，则在NAL数据内肯定不会存在NAL起始码0x000001。当解码器在NAL内部检测到0x000003的数据，就把0x03抛弃，恢复原始数据。 0x000000  »»» 0x00000300(结束码) 0x000001 »»» 0x00000301(起始码) 0x000002 »»» 0x00000302(保留) 0x000003 »»» 0x00000303(保证解码器正常工作) H.264提出了“防止竞争”机制： 0X000000——0X00000300 0X000001——0X00000301 0X000002——0X00000302 0X000003——0X00000303 为此，我们可以知道： 在NAL单元中，下面的三字节序列不应在任何字节对齐的位置出现 0X000000 0X000001 0X000002 Forbidden_zero_bit=0; Nal_ref_idc：表示NAL的优先级。0～3，取值越大，表示当前NAL越重要，需要优先受到保护。如果当前NAL是属于参考帧的片，或是序列参数集，或是图像参数集这些重要的单位时，本句法元素必需大于0。 Nal_unit_type：当前NAL 单元的类型 标识NAL单元中的RBSP数据类型，其中，nal_unit_type为1， 2， 3， 4， 5的NAL单元称为VCL的NAL单元，其他类型的NAL单元为非VCL的NAL单元。 § 0：未规定 § 1：非IDR图像中不采用数据划分的片段 § 2：非IDR图像中A类数据划分片段 § 3：非IDR图像中B类数据划分片段 § 4：非IDR图像中C类数据划分片段 § 5：IDR图像的片段 § 6：补充增强信息（SEI） § 7：序列参数集（SPS） § 8：图像参数集（PPS） § 9：分割符 § 10：序列结束符 § 11：流结束符 § 12：填充数据 § 13：序列参数集扩展 § 14：带前缀的NAL单元 § 15：子序列参数集 § 16 –18：保留 § 19：不采用数据划分的辅助编码图像片段 § 20：编码片段扩展 § 21 –23：保留 § 24 –31：未规定 H.264的NAL层处理 结构示意图： NAL以NALU（NAL unit）为单元来支持编码数据在基于分组交换技术网络中传输。它定义了符合传输层或存储介质要求的数据格式，同时给出头信息，从而提供了视频编码和外部世界的接口。 NALU：定义了可用于基于分组和基于比特流系统的基本格式 RTP封装：只针对基于NAL单元的本地NAL接口。 三种不同的数据形式： SODB　数据比特串－－＞最原始的编码数据 （raw） RBSP　原始字节序列载荷－－＞在SODB的后面填加了结尾比特（RBSP trailing bits一个bit“1”）若干比特“0”,以便字节对齐 EBSP　扩展字节序列载荷–&gt;在RBSP基础上填加了仿校验字节（0X03）它的原因是：　在NALU加到Annexb上时，需要添加每组NALU之前的开始码StartCodePrefix,如果该NALU对应的slice为一帧的开始则用4位字节表示，0x00000001,否则用3位字节表示0x000001.为了使NALU主体中不包括与开始码相冲突的，在编码时，每遇到两个字节连续为0，就插入一个字节的0x03。解码时将0x03去掉。也称为脱壳操作 处理过程： 1．将VCL层输出的SODB封装成nal_unit， Nal_unit是一个通用封装格式，可以适用于有序字节流方式和IP包交换方式。    2．针对不同的传送网络（电路交换  包交换），将nal_unit 封装成针对不同网络的封装格式。   第一步的具体过程： VCL层输出的比特流SODB（String OfData Bits），到nal_unit之间，经过了以下三步处理： 1.SODB字节对齐处理后封装成RBSP（RawByte Sequence Payload）。 2.为防止RBSP的字节流与有序字节流传送方式下的SCP（start_code_prefix_one_3bytes，0x000001）出现字节竞争情形，循环检测RBSP前三个字节，在出现字节竞争时在第三字节前加入emulation_prevention_three_byte（0x03） 具体方法： nal_unit( NumBytesInNALunit ) { forbidden_zero_bit nal_ref_idc nal_unit_type NumBytesInRBSP = 0 for( i = 1; i &lt; NumBytesInNALunit;i++ ) { if( i + 2 &lt; NumBytesInNALunit&amp;&amp; next_bits( 24 ) = = 0x000003 ) { rbsp_byte[ NumBytesInRBSP++ ] rbsp_byte[ NumBytesInRBSP++ ] i += 2 emulation_prevention_three_byte /*equal to 0x03 */ } else rbsp_byte[ NumBytesInRBSP++ ] } }  防字节竞争处理后的RBSP再加一个字节的header(forbidden_zero_bit+ nal_ref_idc+ nal_unit_type)，封装成nal_unit. 第二步的具体过程： case1：有序字节流的封装 byte_stream_nal_unit( NumBytesInNALunit ) { while( next_bits( 24 ) != 0x000001 ) zero_byte /* equal to 0x00 */ if( more_data_in_byte_stream( ) ) { start_code_prefix_one_3bytes /* equal to 0x000001 */nal_unit( NumBytesInNALunit ) } } 类似H.320和MPEG-2/H.222.0等传输系统，传输NAL作为有序连续字节或比特流，同时要依靠数据本身识别NAL单元边界。在这样的应用系统中，H.264/AVC规范定义了字节流格式，每个NAL单元前面增加3个字节的前缀，即同步字节。在比特流应用中，每个图像需要增加一个附加字节作为边界定位。还有一种可选特性，在字节流中增加附加数据，用做扩充发送数据量，能实现快速边界定位，恢复同步 Case2：IP网络的RTP打包封装 分组打包的规则 (1)额外开销要少，使MTU尺寸在100～64k字节范围都可以； (2)不用对分组内的数据解码就可以判别该分组的重要性； (3)载荷规范应当保证不用解码就可识别由于其他的比特丢失而造成的分组不可解码； (4)支持将NALU分割成多个RTP分组； (5)支持将多个NALU汇集在一个RTP分组中。 RTP的头标可以是NALU的头标，并可以实现以上的打包规则。 一个RTP分组里放入一个NALU，将NALU(包括同时作为载荷头标的NALU头)放入RTP的载荷中，设置RTP头标值。为了避免IP层对大分组的再一次分割，片分组的大小一般都要小于MTU尺寸。由于包传送的路径不同，解码端要重新对片分组排序，RTP包含的次序信息可以用来解决这一问题。 NALU分割 对于预先已经编码的内容，NALU可能大于MTU尺寸的限制。虽然IP层的分割可以使数据块小于64千字节，但无法在应用层实现保护，从而降低了非等重保护方案的效果。由于UDP数据包小于64千字节，而且一个片的长度对某些应用场合来说太小，所以应用层打包是RTP打包方案的一部分。 新的讨论方案(IETF)应当符合以下特征： (1)NALU的分块以按RTP次序号升序传输； (2)能够标记第一个和最后一个NALU分块； (3)可以检测丢失的分块。 NALU合并 一些NALU如SEI、参数集等非常小，将它们合并在一起有利于减少头标开销。已有两种集合分组： (1)单一时间集合分组(STAP)，按时间戳进行组合； (2)多时间集合分组(MTAP)，不同时间戳也可以组合。 NAL规范视频数据的格式，主要是提供头部信息，以适合各种媒体的传输和存储。NAL支持各种网络，包括： 1．任何使用RTP/IP协议的实时有线和无线Internet 服务 2．作为MP4文件存储和多媒体信息文件服务 3．MPEG-2系统 4．其它网 NAL规定一种通用的格式，既适合面向包传输，也适合流传送。实际上，包传输和流传输的方式是相同的，不同之处是传输前面增加了一个起始码前缀 在类似Internet/RTP面向包传送协议系统中，包结构中包含包边界识别字节，在这种情况下，不需要同步字节。 NAL单元分为VCL和非VCL两种 VCL NAL单元包含视频图像采样信息， 非VCL包含各种有关的附加信息，例如参数集（头部信息，应用到大量的VCL NAL单元）、提高性能的附加信息、定时信息等 参数集： 参数集是很少变化的信息，用于大量VCL NAL单元的解码，分为两种类型： 1．序列参数集，作用于一串连续的视频图像，即视频序列。两个IDR图像之间为序列参数集。IDR和I帧的区别见下面。 2．图像参数集，作用于视频序列中的一个或多个个别的图像序列和图像参数集机制，减少了重复参数的传送，每个VCL NAL单元包含一个标识，指向有关的图像参数集，每个图像参数集包含一个标识，指向有关的序列参数集的内容因此，只用少数的指针信息，引用大量的参数，大大减少每个VCL NAL单元重复传送的信息。 序列和图像参数集可以在发送VCL NAL单元以前发送，并且重复传送，大大提高纠错能力。序列和图像参数集可以在“带内”，也可以用更为可靠的其他“带外”通道传送。 存储单元： 一组指定格式的NAL单元称为存储单元，每个存储单元对应一个图像。每个存储单元包含一组VCL NAL单元，组成一个主编码图像，VCL NAL单元由表示视频图像采样的像条所组成。存储单元前面可以加一个前缀，分界存储单元，附加增强信息（SEI）（如图像定时信息）也可以放在主编码图像的前面。主编码图像后附加的VCL NAL单元，包含同一图像的冗余表示，称为冗余编码图像，当主编码图像数据丢失或损坏时，可用冗余编码图像解码。 编码视频序列: 一个编码视频序列由一串连续的存储单元组成，使用同一序列参数集。每个视频序列可独立解码。编码序列的开始是即时刷新存储单元（IDR）。IDR是一个I帧图像，表示后面的图像不用参考以前的图像。一个NAL单元流可包含一个或更多的编码视频序列。 I帧和IDR帧的区别： 1．在 H.264 中 I 帧并不具有随机访问的能力，这个功能由 IDR 承担。以前的标准中由 I 帧承担。 2．IDR 会导致 DPB （参考帧列表——这是关键所在）清空，而 I 不会。 3．I和IDR帧其实都是I帧,都是使用帧内预测的。但是IDR帧的作用是立刻刷新,使错误不致传播,从IDR帧开始,重新算一个新的序列开始编码。 4．IDR图像一定是I图像，但I图像不一定是IDR图像。一个序列中可以有很多的I图像，I图像之后的图像可以引用I图像之间的图像做运动参考。 关于h264拆包，按照FU-A方式说明： 1）第一个FU-A包的FU indicator：F应该为当前NALU头的F，而NRI应该为当前NALU头的NRI，Type则等于28，表明它是FU-A包。FU header生成方法：S = 1，E = 0，R = 0，Type则等于NALU头中的Type。 2）后续的N个FU-A包的FU indicator和第一个是完全一样的，如果不是最后一个包，则FU header应该为：S = 0，E= 0，R = 0，Type等于NALU头中的Type。 3）最后一个FU-A包FU header应该为：S = 0，E= 1，R = 0，Type等于NALU头中的Type。 因此总结就是：同一个NALU分包厚的FU indicator头是完全一致的，FU header只有S以及E位有区别，分别标记开始和结束，它们的RTP分包的序列号应该是依次递增的，并且它们的时间戳必须一致，而负载数据为NALU包去掉1个字节的NALU头后对剩余数据的拆分，这点很关键，你可以认为NALU头被拆分成了FU indicator和FU header，所以不再需要1字节的NALU头了。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-07-11-H.264-NALU/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 以小见大，不偏不倚 今天做项目遇到一个奇怪的问题，使用UITabBarController做主控制器，切换控制器然后返回时，下面的tabBar会比view切换慢了几秒，还自带动画，而且这个问题只是在切换特定界面时才会出现。具体描述： 1.实例化UITabBarController //.... -(YSSJNavigationController *)thirdNav{  if (!_thirdNav) {  YSSJLivingViewController *livingViewController = [[YSSJLivingViewController alloc] init];  [livingViewController setHidesBottomBarWhenPushed:YES];  _thirdNav = [[YSSJNavigationController alloc] initWithRootViewController:livingViewController];  _thirdNav.navigationBar.hidden = YES;  [_thirdNav setHidesBottomBarWhenPushed:YES]; }  return _thirdNav; } //.... self.thirdNav.tabBarItem = [self itemWithTitle:[arrayName objectAtIndex:4] image:[UIImage imageNamed:[arrayName objectAtIndex:5]] selectedImage:[UIImage imageNamed:[arrayName objectAtIndex:4]] ]; self.thirdNav.tabBarItem.tag = 2; //...此处略去了其他nav的实例化 //主控制器是继承的UITabBarViewController self.viewControllers = @[firstNav,secondNav,self.thirdNav,fourthNav]; 2.点击跳转到thirdNav //YSSJLivingViewController.m //从thirdnav的根控制器present到VLiveStreamViewController -(void)p_jumpToLivePage{  NSDictionary *options = @{      @gid : @(-1),      @gids : @[],      @shortContent : @,      @tags :@[],      @title : @,      @type : @live      };  NSMutableDictionary *liveInfo = [[NSMutableDictionary alloc]initWithDictionary:options];  //网上获取群组信息  liveInfo = [YSSJTop setLiveInfo:liveInfo];  NSMutableDictionary *createOption = [liveInfo[@creator] mutableCopy];  NSArray *joinedGroups = liveInfo[@joinedGroups];  createOption[@liveId]= liveInfo[@liveId];  [createOption setValuesForKeysWithDictionary:liveInfo];   // 发起直播  VLiveStreamViewController *liveStreamVC = [[VLiveStreamViewController alloc] initWithNibName:nil bundle:nil];  liveStreamVC.modalTransitionStyle = UIModalTransitionStyleCrossDissolve;   liveStreamVC.fromChatGroup = @(-1);  liveStreamVC.createOption = [createOption copy];  liveStreamVC.joinedGroups = joinedGroups;  liveStreamVC.needSelectGroup = YES;  liveStreamVC.delegate = self;   [self presentViewController:liveStreamVC animated:YES completion:nil]; } 3.dismiss控制器VLiveStreamViewController //YSSJLivingViewController.m //dismiss之后会响应这个函数 发出一个通知 -(void)viewWillAppear:(BOOL)animated{  [[NSNotificationCenter defaultCenter] postNotificationName:CloseLiveNotification object:nil]; } //这是通知的函数 回到原始界面 -(void)closeLive{  if (_lastSelectedIndex == 2) {  _lastSelectedIndex = _frontSelectedIndex;  [self setSelectedIndex:_frontSelectedIndex];  }else{  _lastSelectedIndex = _frontSelectedIndex;  } } 4.问题出现 此时在原始界面，随便push一个controller，然后pop,发现TabBar返回已经和根控制器不同步了 解决方式 还记得上面发送通知的地方吗，之前在viewwillappear中，现在在viewdidappear中 -(void)viewDidAppear:(BOOL)animated{  [[NSNotificationCenter defaultCenter] postNotificationName:CloseLiveNotification object:nil]; } Then all work nice!!! 解决方式很简单，但是我应该从这个问题里看到更多的问题： 当一些动画不是在同一个控制器，甚至是不是同一个view时，当这些动画显示会有冲突时，你必须让这些动画的时间错开，否则，将会真的产生冲突，从而产生各种奇葩的结果。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-07-25-iOS-Project-Sumary10/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 其实早就想开一个这样的blog,这样每次写代码有感的时候就可以来记录一下。由于拖延等等问题，今天才补上这么个开始，那么，就开始吧，万事，总得有个开始才好继续。 没有不能自定义的控件 苹果官方提供了许多的精美控件，但是出于某些原因，一些控件给出的自定义接口不足，致使我们无法定制出符合自己需求的控件，从而不得不每次自己去构建控件，这不免让人感到遗憾与无力。接下来，我就总结几种修改官方控件的方式，有了这几种方式，在我看来，几乎没有无法修改的控件了。 最优雅的自定义方式（重写） 最优雅的自定义方式，无非就是继承父控件进行重写了。这种方式对于大部分官方控件都是有效的，举个栗子：你现在要重写tablecell,满足表格距屏幕左右边界都是20pt. //继承tableviewcell @interface BaseCell : UITableViewCell @end //重写setframe @implemention BaseCell -(void)setFrame:(CGRect)frame{  frame.origin.x += 20;  frame.size.width -= 2 * 20;  [super setFrame:frame]; } @end 如何，是不是非常简单。当然，我相信大家对这种方式其实是非常熟悉的，因为这算是我们最为常用的了。这种方式对于那些特殊控件，比如UISwitch是没有作用的，无论你怎么修改frame，它都不会改变。但是，这并不是说没有办法了。 有点暴力的自定义方式（transform) UISwitch控件，宽高都是固定不变的，而且，个人感觉，有点大啊，不是那么好看。那么，如何更改呢？ UISwitch *switch = [[UISwitch alloc] init]; switch.transform = CGAffineTransformMakeScale(0.75, 0.75); 什么感觉？简单！而且这样基本不会有任何其他影响。不认识CGAffineTransform(变换)？ 认识一下，很强大，制作动画的利器。嗯，想优雅一点？结合继承： //继承UISwitch @interface MySwitch : UISwitch @end //重写setframe @implemention MySwitch -(void)setFrame:(CGRect)frame{  [super setFrame:frame];  t//ios7以后 uiswitch大小更改为（51,31）  tfloat scaleX = frame.size.width/51;  tfloat scaleY = frame.size.height/31;  tself.transform = CGAffineTransformMakeScale(scaleX,scaleY); } @end ok，这样，你就可以任意的更改Uiswitch的大小了。我就不截图了，大家试一下就知道了，没有任何问题。 最暴力的自定义方式（subview） 什么意思呢？之前使用父控件，这次又来折腾子view了！这次以什么为例呢？UIAlertController你怕不怕？到了ios9,uialertview已经废弃了，现在全面使用uialertcontroller。但是不管使用什么，最让开发者头疼的是，明明很好的一个控件，却大多数时候都需要自定义，因为主界面颜色完全无法自定义。。。。谁说的？ //实例化alertcontroller UIAlertController *alert = [UIAlertController alertControllerWithTitle:@提示message:message preferredStyle:UIAlertControllerStyleAlert]; //添加按钮 [alert addAction:[UIAlertAction actionWithTitle:@确定 style:UIAlertActionStyleCancel handler:^(UIAlertAction*action) {NSLog(@点击了确定按钮);}]]; //设置字体颜色（包括按钮的） [alert.view setTintColor:[UIColor redColor]]; //获取alertview的主窗体子view UIView *view = alert.view.subviews[0]; view = view.subviews[0]; //这是uialertview没有字时的大小 注意alert的大小跟提示信息的多少是有关系的，所以，这里104不是固定的 但是可以自己动态计算 UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 270, 104)]; //圆角 经测试 只要小于13就不会露出背景白色 imageView.layer.cornerRadius = 10.f; [imageView setBackgroundColor:[UIColor greenColor]]; [view insertSubview:imageView atIndex:0]; //嗯 一不小心又想起来一种更简单的方法 使用下面两句 上面的就不用了 core animation框架 //还是很强大的 这样也不用去计算高度了 哈哈 //view.layer.backgroundColor = [UIColor grayColor].CGColor; //view.layer.cornerRadius = 13.f; ok,diy成功。 隐藏的自定义方式（KVC) 其实官方控件中，许多属性虽然没有开放出来，但是苹果其实提供了一种类似于java反射机制的编程方式：KVC。KVC应该不用介绍了，不懂得就直接去搜索吧，我这里只是介绍它在自定义界面上的应用。这次就说UITextField的PlaceHolder属性，你想要斜体，想换个字体，想换个颜色？看代码 [_nameTF setValue:kTextViewPlaceHolderFont forKeyPath:@_placeholderLabel.font]; [_nameTF setValue:kTextViewPlaceColor forKeyPath:@_placeholderLabel.textColor]; ok了，现在去看看你的placeholder什么样吧，那个字体和颜色自己自定义哈。 Debug 为了开发方便，我们经常会有很多调试设置，但是这些设置在release模式下又是不需要，这时候我们往往会需要这些(例如)： #ifdef DEBUG //调试状态 #define MyLog(...) NSLog(__VA_ARGS__) #else //发布状态 #define MyLog(...) 那么，这个DEBUG是在哪里设置的呢？在 Target &gt; Build Settings &gt; Preprocessor Macros &gt; Debug 里有一个”DEBUG=1“。如果你把DEBUG改成haha呢?试一下！ 状态栏显示与隐藏 app启动时隐藏状态栏  在info.plist里面 Status bar is initially hidden 设置为 YES 如果你想启动后显示，在appdelegate.m中加入[application setStatusBarHidden:NO withAnimation:UIStatusBarAnimationFade]; 其他页面的状态栏的显示与隐藏 //在对应的控制器实现下面的方法 - (UIStatusBarStyle)preferredStatusBarStyle {  t//状态栏样式  return UIStatusBarStyleLightContent; } - (BOOL)prefersStatusBarHidden {  return YES; // 返回NO表示要显示，返回YES将hiden } UIScrollView捏合手势关闭 UIScrollView的自动缩放虽然方便，但也挡不住产品设计部的怪癖好，就是要停，要通过双击放大缩小，这就要求只关闭手势，而要保留缩放功能。通过查看UIScrollView.h发现有pinchGestureRecognizer属性，很是兴奋，于是 //在初始化函数中添加 但是并没有作用！！==！ 我这里是继承的UIScrollView [self removeGestureRecognizer:self.pinchGestureRecognizer]; self.pinchGestureRecognizer.enabled = NO; 后来，我是这样解决的： //在代理设置捏合手势失效 - (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView {  scrollView.pinchGestureRecognizer.enabled = NO;  return _photoImageView; } 这样就是可以的，我表示很方！！并不理解第一种方式为什么不行,猜测是在其他地方才初始化的pinch,不得而知。 双击放大缩小 既然说到了这个，就说一下如何通过双击实现放大缩小。 - (void)handleDoubleTap:(CGPoint)touchPoint {  t  t// Zoom  tif (self.zoomScale != self.minimumZoomScale &amp;&amp; self.zoomScale != [self initialZoomScaleWithMinScale]) {  t t  t t// Zoom out 主要是这个函数  t t[self setZoomScale:self.minimumZoomScale animated:YES];  t t  t} else {  t t  t t// Zoom in to twice the size  CGFloat newZoomScale = ((self.maximumZoomScale + self.minimumZoomScale) / 2);  CGFloat xsize = self.bounds.size.width / newZoomScale;  CGFloat ysize = self.bounds.size.height / newZoomScale;  [self zoomToRect:CGRectMake(touchPoint.x - xsize/2, touchPoint.y - ysize/2, xsize, ysize) animated:YES];  t} } App前后台切换的状态保存与恢复 //这些通知不只是在appdelegate中使用 每一个viewcontroller都是可以的 //WillResignActive //DidEnterBackground //WillEnterForeground //WillResignActive //切换前后台时 上面四个依次执行 //注册已经激活的通知 可以这里恢复状态 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onDidBecomeActive) name:UIApplicationDidBecomeActiveNotification object:nil]; //注册将要进入后台的通知 可以这里保存状态 注意这里非激活状态不只是切换前后台才会出现，比如切换页面的时候也会响应 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onWillResignActive) name:UIApplicationWillResignActiveNotification object:nil]; //注册将要进入前台通知 也可以这里恢复状态 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onWillEnterForeground) name:UIApplicationWillEnterForegroundNotification object:nil]; //这侧已经进入后台通知 也可以这里保存状态 注意操作不要超过5s，否则会被杀死 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onDidEnterBackground) name:UIApplicationDidEnterBackgroundNotification object:nil]; thread 1: sinal sigabrt 这个一般是因为你的xib或者storyboard与代码的连线有问题，或者是连多了，或者是连了之后改了名字又重连了一次，但是没有删除之前的。 UIScrollView与UICollectionView手势冲突 之前在制作一个图集浏览的控件，使用UICollectionView作为载体，每一个Cell中加入UIImageView和UIScrollView. UIImageView用来放图片与点击，双击，长按事件，UIScrollView主要是利用其放大缩小的功能。 UIScrollView的放大缩小本质是滑动手势的响应，这时，就偶尔会和UICollectionView的滑动事件冲突 解决方法是： 在cell上放一个UIView,比如contentView，然后把UIImageView和UIScrollView放到contentView上即可。 解决UIScrollview与NavigationBar的冲突 iOS7之后，scrollview都会自动留白一个navigationbar的高度，直接在你的controller里的viewdidload中假如下述代码即可。 if (DEVICE_OS_VERSION&gt;7) {  self.edgesForExtendedLayout = UIRectEdgeNone;  self.extendedLayoutIncludesOpaqueBars = NO;  self.modalPresentationCapturesStatusBarAppearance = NO;  self.automaticallyAdjustsScrollViewInsets = NO;  } 需要注意的是，添加这些后，view的位置就是从navigationbar开始，即屏幕的Y:64的位置现在是view的0。当然，你的view的总高度已经变成了DEVICE_SIZE.HEIGHT-64。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-08-25-Ios-OC-Skills-Total/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 其实早就想开一个这样的blog,这样每次写代码有感的时候就可以来记录一下。由于拖延等等问题，今天才补上这么个开始，那么，就开始吧，万事，总得有个开始才好继续。 Android隐藏标题栏的区别 Android隐藏标题栏可以在清单文件里设置： &lt;!--这种方式是直接移除了标题栏，不占位--&gt; &lt;activity android:name=.MainActivity   android:theme=@android:style/Theme.Black.NoTitleBar/&gt; 也可以在onCreate方法中设置 //这种方式只是隐藏了 但是还会占位 requestWindowFeature(Window.FEATURE_NO_TITLE); 举例 我们应该都遇到过适配华为等带有虚拟按键的屏幕，这些按键占据了屏幕的底部，使我们的底部布局被遮挡。按照网上大部分的说法是因为沉浸式布局导致的，只需要设置 &lt;FrameLayout xmlns:android=http://schemas.android.com/apk/res/android    android:id=@+id/fl_main    android:layout_width=match_parent    android:layout_height=match_parent   android:fitsSystemWindows=true&gt;//设置这一句 &lt;/FrameLayout&gt; 但是这会导致虚拟按键虚拟按键背景色会变成透明色。必须关闭沉浸式布局才行（可能吧，没有研究）。 可是突然发现你有可能根本没有配置沉浸式布局，也出现了这种情况。这时候，就是我上面说的代码设置隐藏标题栏的占位的原因了。你改为使用xml设置即可更正。 #编译出的gradle问题 编译时出现Error:No service of type Factory available in ProjectScopeServices. 在根目录的build.gradle中，直接将’ classpath com.github.dcendents:android-maven-gradle-plugin:1.3’更新到1.4.1就可以解决问题了。 其实gradle出问题解决方式相对固定： 查看gradle版本号 查看build_tools版本号 查看gradle/gradle-wrapper.properties是否是互联网路径(有些公司可能为了保持统一，将gradle的zip包下到本地，并在此文件中配置为本地路径) 在settings的gradle中查看是否选择了Use local gradle distribution 一般改为Use default gradle wrapper即可 viewPager的数据更新 更新的函数就是mPager.getAdapter().notifyDataSetChanged();。但是，并非任何情况都会生效。  Override getItemPosition in your PagerAdapter like this: public int getItemPosition(Object object) {  return POSITION_NONE; } 这是为了通知viewpager所有的view失效，此时调用notifyDataSetChanged()函数就会触发更新。如果你需要使用到这个函数，那么，你应该再去写一个public函数去实现相同的功能。  to setTag()method in instantiateItem() when instantiating a new view. Then instead of using notifyDataSetChanged(), you can use findViewWithTag() to find the view you want to update. 这种方式相当于你自己管理viewpager的view,然后手动去更新，但是显然不适合用于删除或者添加数据的情况。 AS2.2及以后版本，Failed to crunch file ！ 这个问题的根本原因是文件名（包括路径）太长了，AndroidStudio里路径名不能超过240个字符，所以，尝试把工程放到根目录试试。 UnsatisfiedLinkError 你可以在这里 看到这个错误的解释，简单来说，就是虚拟机找不到native函数的声明。这时候，你可以去看看你的library有没有load对，然后看看jni里面的命名是不是正确。 System.Load(library)找不到 首先，可能是笔误，名字弄错了。 其他隐蔽的可能就是，cpu平台的问题。 arm-v8 =&gt; arm64-v8a arm-v7 =&gt; armeabi-v7a arm-v5 =&gt; armeabi x86 =&gt; x86 x86-64 =&gt; x86_64 mips =&gt; mips mips-64 =&gt; mips64 在编译so时，有时候需要你能选择正确的cpu平台。 或者去过滤你的cpu平台，下面的是删除了64bit平台，防止apk只去64bit中寻找so,导致一些so找不到。当然，这个需要看你具体需要的so包。 android {  ....  defaultConfig {  ....  ndk {   abiFilters armeabi, armeabi-v7a, x86, mips  }  } } ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-09-24-Android-Skills-Total/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 如果你在现实中遇到难以解决的问题，不妨尝试把问题虚拟化一下！ ESXI安装前准备 首先说下本次实验的物理的结构,画张图吧： 解释一下，图中的master和client是准备部署puppet的server和agent的，但是本系列文章不会记录这些，只是纯粹介绍vsphere系列的部署，我会抽时间再写些文章记录puppet的使用。图中的Source是记录部署自己的yum仓库。 下载vsphere系列软件 方法一，直接去官网下载，但是比较麻烦，要注册账号什么的，你们可以自己搞搞。 方法二，提供百度云下载 下载ESXI和vCenter即可，其他的本系列文章不会介绍。另外vCenter本次实验使用的是linux版本，即VCSA(Vmware vCenter Server Appliance ),但我也会介绍下windows版本的安装。 安装硬件说明 ESXI并不是兼容所有的硬件的，因此，如果你不是在使用虚拟机做实验，那么在配置硬件时，必须要选购ESXI支持的硬件，这里的硬件主要说的是cpu,网卡和存储设备。你可以在这里去查询你将要选购的硬件是否被ESXI兼容。如果你懒得麻烦，那么，英特尔系列的产品是确定兼容的。 安装ESXI 安装ESXI跟安装普通系统是没有什么区别的，制作一个启动U盘，然后U盘启动即可。下面直接看图吧，很简单：    配置ESXI主机 配置ESXI主机主要是配置网络，按照规划好的来 ESXI主机开机后是这样的，这里下面的ip等网络信息都是已经配置好的。 F2进入设置界面 进入界面后，选择Configure Management Network,然后设置ipv4的地址 配置dns,这里dns我们还没有配置，按照规划先设置好就行，后续还会讲配置域控与dns 设置一下域 设置shell和ssh选项  连接ESXI主机 Web Client连接 web页面管理还是最方便的，直接在浏览器输入ESXI主机的ip或者域名即可：  具体怎么使用下节说。 desktop Client连接 具体使用，下节介绍。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-10-20-vsPhere-vCenter-etc1/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 站在巨人的肩膀上 最近在掘金上读了一些好的android blog,有些心得，总结一下。 ［译］开发安卓Apps，我所努力学习到的三十多条宝贵经验 其中的某些推荐博客需要翻墙才可浏览。 选择与使用第三方库  你应该选择大众的选择，一是因为经得起考验，二是因为用的人多，总会用贡献者加入，作者维护起来也会更加用心。 选择可信的作者或者组织。 选择文档比较全面的。 选择专精某一功能的库，而不是大而全的库。否则这个库一旦停止维护，你可能要面临全部重构的危险。 使用第三方库时，你应该对其再次封装，防止在你的工程需要替换这个库的时候导致的大范围代码修改。 一定要理解第三方库的原理，但不到万不得已，一定不要修改第三方库！ 应该养成积累自己的轮子的习惯。 避免过度绘制 首先你要学会使用android的一个检测工具：android手机=&gt;开发者选项=&gt;调试GPU强制渲染(Debug GPU Overdraw) 打开此选项之后，你会发现自己的手机屏幕充满了各种色块,如下图： 本图来源于https://riggaroo.co.za/optimizing-layouts-in-android-reducing-overdraw/ 各种颜色的含义： 原色：没有过度绘制 蓝色：1xOverdraw-绘制了2次 绿色：2xOverdraw-绘制了3次 粉色：3xOverdraw-绘制了4次 红色：4xOverdraw-绘制了5次 ok,现在已经知道了如何绘制，那么接下来就是如何fix 这个要根据具体的项目来解决，其实无非是一个原则，重复绘制的地方看如何避免绘制。一些常见的问题，比如你设置的背景色是否真的需要？你设置的背景图片，你的某些空间是否真的需要一直显示？还有，很重要的一点，你得有一个好的产品设计。 你可以从这里得到更多关于过度绘制的信息 如何分包(按功能) 这个，怎么说呢，各执一词，我从android转到ios,又从ios转回android,就我的经验来说，我觉得应该按照功能来分包更加的科学，如何分包，解决的无非是维护时如何快速寻找到目标的问题。显然，如果你按照功能模块进行分包，可以快速的定位一个区域，然后，在功能模块的包内，你再根据你选用的设计模式来分包，这样就能很快的找到你的目标。如果你是刚开始就按照设计模式分包，甚至按照控件分包，那么，等待你的，就是眼花缭乱。 如何加快gradle的编译速度 现在的android的开发者大多都已经转到android studio阵营了，而且不得不承认，android studio比eclipse要更加专业，功能也更强大。但是，当你的项目大到一定程度时，每次要启动一次应用都会变得异常煎熬。 在项目根目录下的gradle.properties中加入： //# The Gradle daemon aims to improve the startup and execution time of Gradle. //# When set to true the Gradle daemon is to run the build. org.gradle.daemon=true //# Specifies the JVM arguments used for the daemon process. //# The setting is particularly useful for tweaking memory settings. //# Default value: -Xmx10248m -XX:MaxPermSize=256m org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 //# When configured, Gradle will run in incubating parallel mode. //# This option should only be used with decoupled projects. More details, visit //# http://www.gradle.org/docs/current/userguide/multi_project_builds.html //#sec:decoupled_projects org.gradle.parallel=true //# Enables new incubating mode that makes Gradle selective when configuring projects. //# Only relevant projects are configured which results in faster builds for large multi-projects. //# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:configuration_on_demand org.gradle.configureondemand=true 具体的原理我就不再记录了，不是我想关注的，如果你想要了解，请看这里（需要梯子） SVG 代替 PNG 当年xcode6开始支持pdf作为矢量图时，着实给我我们的UI省了一大把力，UI只需要确定一个屏幕尺寸，出一套pdf图给我们就可以了，xcode会自动生成3个尺寸的png给我们，而我们的调用仍然想以前一样简单。 现在我看到android也可以这样搞了，给我们一套svg或者psd的图，我们也可以自己生成其他尺寸的图，同样也是不会有任何锯齿的。不过遗憾的是4.4及以下的系统是不支持的，所以恐怕现在还是不能大范围使用的，毕竟5.0以下系统还不能直接抛弃。 Android App优化之内存优化(序) 至于说GC机制以及系统切换APP的内存管理机制，这里都不会解释，不懂得可以参考上述博文，写的很详细生动。 我要总结的是：为了不要让系统kill掉我们的App, 可以从进程级别, 内存消耗量等几个方面进行优化。 内存监测工具Memory Monitor 此图来源于:http://blog.lmj.wiki/2016/10/25/app-opti/app_opt_mat/  ① GC按钮, 点击执行一次GC操作. ② Dump Java Heap按钮, 点击会在该调试工程的captures目录生成一个类似这样”com.anly.githubapp_2016.09.21_23.42.hprof”命名的hprof文件, 并打开Android Studio的HPROF Viewer显示该文件内容. ③ Allocation Traking按钮, 点击一次开始, 再次点击结束, 同样会在captrures目录生成一个文件, 类似”com.anly.githubapp_2016.09.21_23.48.alloc”, alloc后缀的文件, 并打开Allocation Tracker视图展示该文件内容. 这里只简单提一下android studio自带的监测工具，具体使用，可以参照上面的博文系列。 内存泄漏的常见可能  Context泄漏。某些全局对象没有使用Application级别的对象，而是使用的指定的activity的Context，导致activity难以回收。 内部类泄漏。当内部类持有当前类的引用，并且内部类的生命周期长与当前类，就会导致当前类的内存泄漏。如Handler泄露, Thread泄露等。其实，当我们发生这种错误时，一般lint会进行提示，并且建议我们使用使用Static + WeakReference的方式，这正是正确的解决方式，而不是使用@SuppressLint(“HandlerLeak”)来逃避提示。 Register泄漏。对于观察者，广播，Listener等，添加与删除没有成对出现，从而导致的内存泄露，这个只能希望程序员们多长点心了。 资源泄漏。当你操作文件或者数据库等等时，打开资源之后，请一定记得关闭资源。 Bitmap泄漏。Bitmap没有及时的调用recycle()回收导致内存泄漏。 有效使用内存的建议  合理使用ServiceService的及时关闭可以让我们节省内存消耗, 对于一次性的任务, 建议使用IntentService. 使用优化后的数据容器使用Android提供的SparseArray, SparseBooleanArray, LongSparseArray来代替HashMap的使用.关于HashMap，ArrayMap，SparseArray, 这篇文章有个比较直观的比较, 可以看下. 少用枚举enum结构相比于静态常量(static final), enum会耗费双倍的内存. 避免创建不必要的对象诸如一些临时对象, 特别是循环中的. 考虑实现onTrimMemory(), 在此根据当前的内存状态做些处理. Bitmap的合理有效使用.对于Bitmap的使用, 建议直接查看官方开发文档中的高效显示Bitmap(需翻墙). ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-11-07-Read-Android-Blog/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 面对正确的事物，我们往往无法确定它是正确的 面向对象的六大原则 单一职责原则(Single Responsibility Principle) 这一原则虽然简单，但其实争议最大，也是最难以界定的。一个类只应该做自己职责范围内的事，这个职责本身就很难确定，是功能职责？是架构职责？还是其他什么职责？每一个程序员心中可能都有不同的界定。 假定我们以功能职责为标准，类比经理(一般manager类)，作为一把手，是不是什么事都要亲自去做？那么其实其他人(财务，市场等)的职能是否都属于经理呢？这样显然不合理，各种事都该各个部门分别去做，然后经理来同意指挥协调(manager去调用各个实现类的方法)。 其实这是六大原则中的另外一种原则了，我想说的事，这个原则，大家需要靠自己的实践经验去形成自己的风格，没有真正的对错，只要你的风格稳定不变。 开闭原则(Open Close Principle) 这也是一个很基础的设计原则，对扩展，开放；对修改，封闭。 一个项目，免不了维护和升级。而在维护升级时，为了避免引入新的bug，我们应该尽量扩展新的功能，而不是直接在旧代码中进行修改。 当然，这只是理想的情景，实际上我们很多时候都不得不去修改旧的代码。但我们也应该尽可能的避免。 避免的方法就是使用开闭原则，尽可能的去覆写父类的方法，或者尽可能的去设计公共接口，然后去实现它们。 里氏替换原则(Liskov Substitution Principle) 简单来说，在我们进行组合依赖时，应该尽可能的依赖的是借口或者父类(包括抽象类)，这样我们在覆写了父类或者是实现类借口的方法之后，就可以在使用时随意的替换。 比如现在经理辞职换了一个人，经理职权不变，但是每个人行使职权的风格和方式却是不同的，这个经理只需要重新实现接口，就可以用自己的风格去快速执掌公司类。 依赖倒置原则(Depedence Inversion Principle) 这个，简单解释就是接口去决定细节实现。高层次的模块不去关心低层次的细节实现，而是设计类各种接口去掉用。而低层次模块则是根据高层次的调用的接口去实现细节。 比如，经理管理财务方面，要看财务报表，于是定义了一个看财务报表的接口，那么下面的财务部就得去实现这个接口，提供财务报表。至于这个财务报表，是机器统计的还是会计自己画的，经理是不会关心的。 接口隔离原则(InterfaceSegregation Principles) 这其实就是解决第一个原则中提出的问题，接口应该尽可能的小。 你不能设计一个大的经理的接口，里面声明类各个部门的所有方法，而是应该分成多个接口，每一个接口再去声明各自的功能。甚至，你应该再去进一步细分，比如每个部门有一个总管，下面各个职员，负责各个细节。 迪米特原则(Law of Demeter or Least Knowledge Principle) 一个对象，应该对所依赖的对象有最少的了解。简单来说，你最好就不要了解，各个功能都在对方的类中实现，你只管调用这个函数就好了。 比如，经理现在要市场部提供公司最大的客户的相关信息给他，市场部内有一个列表，保存了所有客户的信息。这时候，应该是市场部内部进行筛选拿到最大客户信息返给经理，而不是经理自己取出市场部的所有客户信息，自己遍历一遍拿出最大客户信息。 怎么看呢 这些原则都是老生常谈了，今天我并不是为了再次介绍它们，而是想说说以前自己的困惑，自己的想法，但，只是自己的观点，谈不上对错。 维护与实现 这是我刚开始接触各种设计模式最大的困惑，我知道怎么去设计架构以符合设计模式，也知道，写出的代码，应该扩展性好，解耦好，健壮性好……可是，一味的去符合设计模式，导致的结果可能会是，代码可读性差，难以维护。这个可能有争论，实际上，这里讨论的是设计模式的使用的度的问题。 比如，你大量的使用接口，那么，你在调试代码时，可能并不知道它到底是那一个子类实现的功能，你还需要按图索骥，一层层的去寻找调用赋值的位置，去寻找到实现的位置，然后再去分析有没有bug。 比如，按照接口隔离原则，可能每一个功能，都要去单独设计一个接口，那么，不可避免的是，你将会分成很多很多类文件，这对于维护来说，也无疑是增加了很大难度。 …… 所以，现在是一个如何适度的问题。到底是不是每一个功能都需要单独设计一个接口，到底是不是每一个地方都需要这么好的扩展性，都需要使用父类，接口，抽象类？ 程序员都知道，我们应该根据需求来说事。虽然从来都没遇到不变的需求，但是，好在大方向总是不变的，所以需求还是具有一定的参考性的。 那么，根据需求，以及我们的经验，我觉得，模块化的东西，往往需要充分的解耦合，并且应该有好的扩展性。因为我们可能在很多地方使用，以及本项目之外；大而全的东西，可以牺牲这些特性，因为它们可重用的机会比较少，比如android的activity，ios的controller。 总之，需要变化的地方，才是导致工程覆灭的潜在因素，我们的设计模式，我们的软件工程，针对的，应该是这些地方。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-11-14-OOP-principles/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 代码就像DNA,随机组合过程中总会出现毛病。 Animation 这里不会介绍动画的详细用法，只是记录一些小问题。 动画无效 //这里要时刻注意，你传进去要变化的动画纬度参数是否是正确的 TranslateAnimation animation = new TranslateAnimation(0, 0, mEditView.getHeight(), 0);  animation.setDuration(500); animation.setAnimationListener(new Animation.AnimationListener() {   @Override public void onAnimationStart(Animation animation) {     tmEditView.setVisibility(View.VISIBLE);    t}  @Override public void onAnimationEnd(Animation animation) {}  @Override public void onAnimationRepeat(Animation animation){}  });  mEditView.startAnimation(animation); 注意上述代码，在动画开始时，使mEditView显示，在动画前，它是隐藏的。这里需要注意的是，如果你在xml文件中(或者使用代码)设置的是gone，而不是invisible，那么，你在设置动画参数时，传入的mEditView.getHeight()就是0，从而导致没有动画发生。 动画之后出现异常情况 TranslateAnimation animation = new TranslateAnimation(0, 0, 0, mEditView.getHeight()); //注意这里，如果设为true，动画结束后，将会强制保持结束时的状态。 //animation.setFillAfter(true); animation.setDuration(500); animation.setAnimationListener(new Animation.AnimationListener() { @Override t  tpublic void onAnimationStart(Animation animation) { } t  t@Override    tpublic void onAnimationEnd(Animation animation) {  t tmEditView.setVisibility(View.INVISIBLE);  }  t@Override public void onAnimationRepeat(Animation animation) {} }); mEditView.startAnimation(animation); 这里是隐藏的动画，在上面//animation.setFillAfter(true);这句，会导致onAnimationEnd中的mEditView.setVisibility(View.INVISIBLE);无效，准确来说，mEditView保持了动画结束的状态，在屏幕外面。 但是，不仅如此，setFillAfter(true)这句，还使得事件与view分离了。所以，你往往会点到一些看起来诡异的东西。 Gesture view自身具有的手势监听已经很全面了。 mHeaderView.setOnTouchListener(new View.OnTouchListener() {  @Override  public boolean onTouch(View view, MotionEvent motionEvent) { );   switch (motionEvent.getAction()) {    case MotionEvent.ACTION_DOWN: {       t final float y = motionEvent.getY();    Log.d(downY:+y);    // Remember where we started (for dragging)    mLastTouchY = y;    // Save the ID of this pointer (for dragging)    break;    }       case MotionEvent.ACTION_MOVE: {    // Find the index of the active pointer and fetch its position    final float y = motionEvent.getY();    Log.d(downY:+mLastTouchY+===moveY:+y);       // Only move if the ScaleGestureDetector isn't processing a gesture.    //       if (!mScaleDetector.isInProgress()) {    // Calculate the distance moved    //       final float dx = x - mLastTouchX;    final float dy = y - mLastTouchY;       RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) mQueryListView.getLayoutParams();    params.topMargin = (int) (params.topMargin+dy);    mQueryListView.setLayoutParams(params);       break;    }       case MotionEvent.ACTION_UP: {    break;    }   }   return true;  }  }); 这里展示的是使用一个手指上下拖动view的事例。注意，这里监听的是一个控件，而不是整个window。在ACTION_MOVE中，拿到的y是你的手指在目标view中的坐标，因此，这里只需要减去ACTION_DOWN时的初始坐标，就能得到每次需要移动的距离。 注意，目标view随着你的手指在移动，所以，ACTION_MOVE中拿到的y一般波动很小，因为你的手指可能一直在目标view的同一个位置。 你的手指每移动1像素，目标view就会跟随移动1像素。 GestureDetector 在遇到极其复杂的交互情况，可能会需要使用到这里的手势监听器。 mGestureDetector = new GestureDetector(mActivity,UpdateFeaturesProtocol.this); //这里需要注意，必须设置这一句，否则在GestureDetector的实现中，只能响应down,press,longpress三个事件mHeaderView.setLongClickable(true); mHeaderView.setOnTouchListener(new View.OnTouchListener() {  @Override  public boolean onTouch(View view, MotionEvent motionEvent) {    return mGestureDetector.onTouchEvent(motionEvent);  }  }); 下面是对OnGestureListener的实现 private float startPointY;  /** * Gesture * @param motionEvent * @return */  //点下时响应 第一个响应  @Override  public boolean onDown(MotionEvent motionEvent) {  Log.d(down==&gt;e2.x:+motionEvent.getX()+====e2.y:+motionEvent.getY());  RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) mQueryListView.getLayoutParams();  startPointY = motionEvent.getY();  return false;  }  //几乎跟down一样，但是在down后  //比如down响应需要0.1s,那么press需要0.2s  //如果你的手指接触屏幕时间不足0.2s，该事件不会响应  //这里的0.1s和0.2s皆为假设，没有测过  @Override  public void onShowPress(MotionEvent motionEvent) {  Log.d(press==&gt;e2.x:+motionEvent.getX()+====e2.y:+motionEvent.getY());   }  //单击  @Override  public boolean onSingleTapUp(MotionEvent motionEvent) {  Log.d(singletap==&gt;e2.x:+motionEvent.getX()+====e2.y:+motionEvent.getY());  return false;  }  //滚动 在手指滑动过程中一直响应  @Override  public boolean onScroll(MotionEvent motionEvent, MotionEvent motionEvent1, float v, float v1) {  Log.d(scroll==&gt;e2.y:+motionEvent1.getY()+===e1.y:+motionEvent.getY()+distanceY:+v1);  RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) mQueryListView.getLayoutParams();  params.topMargin = (int) (params.topMargin + (motionEvent1.getY()-startPointY));  mQueryListView.setLayoutParams(params);  return false;  }  //长按  @Override  public void onLongPress(MotionEvent motionEvent) {  Log.d(longpress==&gt;e2.x:+motionEvent.getX()+====e2.y:+motionEvent.getY());  }  //扔？  //此事件是指用手指快速滑动并快速抬起的情况  //注意，此事件在scoll后是不一定响应的。  @Override  public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,     float velocityY) {  Log.d(fling==&gt;e2.x:+e2.getX()+====e2.y:+e2.getY());   return false;  } 功能和直接使用mHeaderView.setOnTouchListener完全一样，思路也是完全一样的。解释都在代码注释里。 需要注意的是里面没有监听手指抬起的地方，所以你还需要回到setOnTouchListener中使用ACTION_UP ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-11-17-Animation-Gesture/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 好记性不如烂笔头 接到一个android地图项目，准备使用mapbox作为底图。但是有些地方需要修改一下，主要是读取一些自己的数据等，所以这里得重新编译so及sdk。本篇不会记录如何修改，更不会去讲C++相关的任何知识，只是记录编译过程。 如果你是需要编译其他平台的sdk,看完本篇，也是完全没有问题的。 准备工作  环境 mac OS X EI Capitan(Command) or Linux(Command) or windows Cygwin 本人使用的是环境1。 另外，一个建议是，mac的硬盘比较小，我的是128的固态，编译完成可能有10多G，所以，我最后是把工程放到了移动硬盘里，也建议大家这样做(在编译开始前你就该放到移动硬盘里，否则会因为路径的问题，导致下载的好的包及配置文件失效)。  源码下载 在github下载源码。仓库tag和branch很多，clone的话很费时间，我个人的建议是选择一个tag或者分支就可以了，直接download zip比较快。 我这里选择的是android-v4.2.1,这是当前最新的android分支。  配置必要的环境 既然是要编译android sdk,那么，基础的android的环境配置是肯定要配置好的。主要是两个环境变量: 在主要是两个环境变量:ANDROID_HOME和NDK的路径。 在~/bash_profile的末尾添加： //当然 这里是我的路径 大家如果和我的不同 记得换啊 export ANDROID_HOME=/Users/developer/Library/Android/sdk export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools export PATH=$PATH:/Users/developer/Library/Android/sdk/ndk-bundle 开始编译 可以开始编译了。使用终端进入mapbox-gl-native(这个名字不是固定的，你下载源码的方式和版本不同，名称都是不一样的，新手不必纠结)的根目录。 cd ~/Downloads/mapbox-gl-native-release-android-v4.2.1 make android 不同make命令对应的cpu平台不同，如下： android=&gt;armeabi-v7 android-lib-$1: $1=&gt;(arm-v5 arm-v7 arm-v8 x86 x86-64 mips) arm-v8 =&gt; arm64-v8a arm-v7 =&gt; armeabi-v7a arm-v5 =&gt; armeabi x86 =&gt; x86 x86-64 =&gt; x86_64 mips =&gt; mips 如：make android-lib-x86 如果想编译全部平台: make apackage (编译android所有cpu架构,建议使用这个) 这些都可以从根目录的makefile文件里得到，这里粘贴makefile的一部分文件。 #### Android targets ########################################################### ANDROID_ENV = platform/android/scripts/toolchain.sh ANDROID_ABIS = arm-v5 arm-v7 arm-v8 x86 x86-64 mips .PHONY: style-code-android style-code-android: $(BUILD_DEPS)  tnode platform/android/scripts/generate-style-code.js define ANDROID_RULES build/android-$1/$(BUILDTYPE): style-code-android  tmkdir -p build/android-$1/$(BUILDTYPE) build/android-$1/$(BUILDTYPE)/toolchain.cmake: platform/android/scripts/toolchain.sh build/android-$1/$(BUILDTYPE)  t$(ANDROID_ENV) $1 &gt; build/android-$1/$(BUILDTYPE)/toolchain.cmake build/android-$1/$(BUILDTYPE)/Makefile: build/android-$1/$(BUILDTYPE)/toolchain.cmake platform/android/config.cmake  tcd build/android-$1/$(BUILDTYPE) &amp;&amp; cmake ../../.. -G Ninja     t t-DCMAKE_TOOLCHAIN_FILE=build/android-$1/$(BUILDTYPE)/toolchain.cmake     t t-DCMAKE_BUILD_TYPE=$(BUILDTYPE)     t t-DCMAKE_EXPORT_COMPILE_COMMANDS=ON     t t-DMBGL_PLATFORM=android .PHONY: android-lib-$1 android-lib-$1: build/android-$1/$(BUILDTYPE)/Makefile  t$(NINJA) $(NINJA_ARGS) -j$(JOBS) -C build/android-$1/$(BUILDTYPE) all .PHONY: android-$1 android-$1: android-lib-$1  tcd platform/android &amp;&amp; ./gradlew --parallel --max-workers=$(JOBS) assemble$(BUILDTYPE) apackage: android-lib-$1 endef $(foreach abi,$(ANDROID_ABIS),$(eval $(call ANDROID_RULES,$(abi)))) .PHONY: android android: android-arm-v7 .PHONY: android-test android-test:  tcd platform/android &amp;&amp; ./gradlew testDebugUnitTest --continue .PHONY: android-test-apk android-test-apk:  tcd platform/android &amp;&amp; ./gradlew assembleDebug --continue &amp;&amp; ./gradlew assembleAndroidTest --continue .PHONY: apackage apackage:  tcd platform/android &amp;&amp; ./gradlew --parallel-threads=$(JOBS) assemble$(BUILDTYPE) .PHONY: android-generate-test android-generate-test:  tnode platform/android/scripts/generate-test-code.js #### Miscellaneous targets ##################################################### .PHONY: style-code style-code:  tnode scripts/generate-style-code.js .PHONY: clean clean:  t-rm -rf ./build     t  ./platform/android/MapboxGLAndroidSDK/build     t  ./platform/android/MapboxGLAndroidSDKTestApp/build     t  ./platform/android/MapboxGLAndroidSDK/src/main/jniLibs     t  ./platform/android/MapboxGLAndroidSDKTestApp/src/main/jniLibs     t  ./platform/android/MapboxGLAndroidSDK/src/main/assets .PHONY: distclean distclean: clean  t-rm -rf ./mason_packages  t-rm -rf ./node_modules 可以看到.PHONY:后面的就是各种命令。其他平台类似。 先打针强心剂，在编译过程中，需要下载很多依赖，我在编译完成之后，整个文件夹有10.58G…我用了一整晚。 这样如果顺利的话，编译so就完成了。但是可能会有问题，看末尾问题解释。 另外说下，编译完成后，so文件在mapbox-gl-native/platform/android/MapboxGLAndroidSDK/src/main/jniLibs下 mapbox-android-sdk 的打包和使用  打包 使用android studio打开platform下的android工程 然后直接运行就好了。 在build的output下就可以找到aar文件了。  使用aar 这里我直接还以上述android工程里的测试工程为例。 ** 拷贝aar到目标工程的libs(没有自己创建)下 这里我将aar重命名了一下，大家随意，后有图。 ** 配置builid.gradle android { ··· repositories {  flatDir {   dirs 'libs'  }  } } dependencies { // compile(project(':MapboxGLAndroidSDK')) { //  transitive = true // } compile(name: 'mapbox-android-sdk-4.2.1', ext: 'aar') ··· //mapbox aar dependences  compile 'com.squareup.okhttp3:okhttp:3.4.1' // Exclude Guava to avoid an unnecessary transitive dependency  // See: https://github.com/mapbox/mapbox-gl-native/issues/7129  compile ('com.mapzen.android:lost:1.1.1') {  exclude group: 'com.google.guava'  } // Mapbox Android Services  compile('com.mapbox.mapboxsdk:mapbox-java-services:1.3.1@jar') {  transitive = true  }  //mapbox aar dependences  ··· }  需要说下的是，打包的aar不会自动打包依赖，除非是你自己手动添加对应的依赖aar或者jar到目录下，只是用gradle管理依赖的话，是不会自动打包到aar中的。 ** 记得添加上access_token 问题解释  某个包总是下载失败 我想说的是，多试几次，有代理，vpn什么的都连上，多试几次。从终端输出里可以看出来，这些包都是aws上的，但是亚马逊的服务器对我们来说太不稳定了，所以，试试vpn什么的，会好很多。  在x86等手机上提示找不到so 如果你是用make android命令来编译的，那么就只有arm-v7的so,64bit的运行没有问题(没有全部测试，用三星S7 edge测试没有问题)，但其他32bit平台就不行了，所以建议你编译上其他平台的包。使用make apackage编译。 很多问题在前面步骤中已经自动避过了，现在反而没什么需要多说了，祝好运吧。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-12-28-mapbox-compile/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": " 好记性不如烂笔头 项目用到spatialite,记录下使用方法 准备工作  环境 有android studio就行了  源码下载 如果想使用最新版本，去google下载源码吧。 我这里提供博客日期为止最新的源码 这里还有已经把所有的坑填上了完整工程 开始编译 使用android studio打开项目 File=&gt;New=&gt;import project 会报一些错误，直接贴图 缺少compile-sdk 版本 最小skd版本设置错误 package-name重复 缺少ndk编译模块 这个首先你应该已经安装了ndk,这个我就不多说了。 这时候sync gradle应该就没有问题了 配置工程 我没有重新去打包so文件，在这里有具体的打包流程。但是我有尝试过，确实是很麻烦的一件事，工程中没有完整的make文件，依赖都需要自己去管理，我直接去网上找到了合适的so文件。如果你是自己找的so文件，那么，一定要确定是ndk-r8以上版本编译的，否则会有text alloc…类似的错误 删除掉demo app目录下的Google Map相关的类，因为需要配置api_key,而且现在google map好像都已经完全更新了，不知道接口变了没有，要验证spatialite 是否成功并不需要展示到map上，所以删除掉MappingActivity.java和MapSelectionOverlay.java两个类文件,记得修改清单文件AndroidManifest.xml 现在已经可以编译成功并运行了。但是现在只能在32bit的安卓机上运行，因为so只有32bit的，64bit的机子会找错文件夹，需要再设置一下： 然后再运行就没有任何问题了。 spatialite-android-sdk 的使用  首先在build/outputs中找到aar文件，具体aar怎么用可以参考我的上篇博客。 下载spatialite-gui 普及一下spatialite的基础知识 spatialite&gt; select spatialite_version(); 4.0.0 spatialite&gt; select proj4_version(); Rel. 4.8.0, 6 March 2012 spatialite&gt; select geos_version(); 3.3.6-CAPI-1.7.6 spatialite&gt; select lwgeom_version(); 2.0.2 spatialite&gt; select HasIconv(); 1 spatialite&gt; select HasMathSQL(); 1 spatialite&gt; select HasGeoCallbacks(); 1 spatialite&gt; select HasProj(); 1 spatialite&gt; select HasGeos(); 1 spatialite&gt; select HasGeosAdvanced(); 1 spatialite&gt; select HasGeosTrunk(); 0 spatialite&gt; select HasLwGeom(); 1 spatialite&gt; select HasEpsg(); 1 spatialite&gt; select HasFreeXL(); 1 輸入由 WGS84 為基準的經緯度（4326 是 WGS84 2D 的 EPSG CRS SRID 編號）： spatialite&gt; select AsText(MakePoint(114.1689,22.4518,4326)); POINT(114.1689 22.4518) 將它轉換為 WGS84 UTM 50N 格網座標（32650 是 WGS84 / UTM zone 50N 的 EPSG CRS SRID 編號）： spatialite&gt; select AsText(ST_Transform(MakePoint(114.1689,22.4518,4326),32650)); POINT(208621.605201 2485587.067636) 將它轉換為 HK1980 格網座標（2326 是 Hong Kong 1980 Grid System 的 EPSG CRS SRID 編號）： spatialite&gt; select AsText(ST_Transform(MakePoint(114.1689,22.4518,4326),2326)); POINT(835447.180293 834705.40192) 利用格網座標計算大埔中心至九龍坑山的距離： spatialite&gt; select ST_Distance(MakePoint(208838.738969, 2488246.942923), MakePoint(208621.605201, 2485587.067636)); 2668.72321824495 利用經緯度計算大埔中心至九龍坑山的距離： spatialite&gt; select ST_Length(MakeLine(MakePoint(114.17052, 22.475837,4326), MakePoint(114.1689,22.4518,4326)), 1); 2666.99235712016 計算大埔中心至九龍坑山的方位角： spatialite&gt; select Degrees(ST_Azimuth(MakePoint(114.1689,22.4518,4326), MakePointZ(114.17052, 22.475837, 437.639187, 4326))); 3.85568120514838 輸出九龍坑山三角網測站的 KML： spatialite&gt; select AsKml(Cloudy Hill, description, MakePointZ( 835614.056, 837367.172, 440.8, 2326)); &lt;Placemark&gt;&lt;name&gt;Cloudy Hill&lt;/name&gt;&lt;description&gt;description&lt;/description&gt;&lt;Point&gt;&lt;coordinates&gt;114.170519962613,22.47583709798935,437.6391865937039&lt;/coordinates&gt;&lt;/Point&gt;&lt;/Placemark&gt; 點的 Union： spatialite&gt; select astext(ST_Union(MakePoint(114.17052, 22.475837,4326), MakePoint(114.1689,22.4518,4326))); MULTIPOINT(114.17052 22.475837, 114.1689 22.4518) 創建有地理數據的表，先是一般格式的欄： spatialite&gt; CREATE TABLE TestTable( id INTEGER PRIMARY KEY AUTOINCREMENT, Name TEXT NOT NULL); 創建該地理數據欄，儲存以 WGS84 為基準的點： spatialite&gt; SELECT AddGeometryColumn('TestTable', 'Geometry', 4326, 'POINT', 'XY'); 1 加入 R* index，以加快檢索：(添加索引) spatialite&gt; SELECT CreateSpatialIndex('TestTable', 'Geometry'); 1 加入點數據： spatialite&gt; insert into TestTable (Name, Geometry) VALUES (a, MakePoint(114.1689,22.4518,4326)); spatialite&gt; insert into TestTable (Name, Geometry) VALUES (b, MakePoint(114.17052,22.475837,4326)); 列出數據（Geometry 未能直接顯示）： spatialite&gt; select * from TestTable; 1|a| 2|b| 列出數據： spatialite&gt; select id, Name, AsText(Geometry) from TestTable; 1|a|POINT(114.1689 22.4518) 2|b|POINT(114.17052 22.475837) 利用 R* index 查出在 22.4518N 114.1689E, 22.4520N 114.1690E 內的點： spatialite&gt; SELECT id, Name, AsText(Geometry) FROM TestTable WHERE ROWID IN (SELECT pkid FROM idx_TestTable_Geometry WHERE pkid MATCH RTreeIntersects(114.1689,22.4518,114.1690,22.4520)); 1|a|POINT(114.1689 22.4518) 將點數據轉成 GeoHash（可以文字方式儲存於一般資料庫，以方便查詢某一點附近的其他點）： spatialite&gt; SELECT Name, GeoHash(Geometry) FROM TestTable; a|wecptzpr0ny5c1eeemw3 b|wecpy587jztypffhy099 sdk的简单使用，我直接按照demo理一下。 //上面这些获取数据库路径的代码就省略了 ... // 1. //Open the database 打开数据库 jsqlite.Database db = new jsqlite.Database(); db.open(dbFile.toString(), jsqlite.Constants.SQLITE_OPEN_READONLY); // 2. // Test prepare statements 测试下准备好了没有？我的理解就是查询一下数据库的基本状态和信息，可能真正使用时也是用不到的。 String query = SELECT name, peoples, AsText(Geometry) from Towns where peoples &gt; 350000; Stmt st = db.prepare(query); st.step(); st.close(); // 3.测试各种查询 你们也可以把我上面简单介绍的其他命令拿来测试下 // Test various queries db.exec(select Distance(PointFromText('point(-77.35368 39.04106)', 4326), PointFromText('point(-77.35581 39.01725)', 4326));,  t tcb); db.exec(SELECT name, peoples, AsText(Geometry), GeometryType(Geometry), NumPoints(Geometry), SRID(Geometry), IsValid(Geometry) from Towns where peoples &gt; 350000;,  t tcb); db.exec(SELECT Distance( Transform(MakePoint(4.430174797, 51.01047063, 4326), 32631), Transform(MakePoint(4.43001276, 51.01041585, 4326),32631));,  t tcb);  t t // 4. // Close the database 搞完了就关闭 db.close(); 最后，这里还有一个官方的tutorial，虽然很老了，但是api基本没变化，大家可以找到更多关于使用spatialite的使用方法。感兴趣的可以看下。 好了，就到这里了。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2016-12-29-spatialite-android/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": "progress Welcome your audience Good morning, everyone. Thanks for coming. Tell audience some interesting abstract information or statistic to get people’s attention. I know that you’re all anxious to get more information about our acquisition of Sunset Computers. Offer people a ‘map’ of your presentation. I’ll begin by giving a general update. Then, I’ll be discussing out acquisition of Smoot Hawley. -ing的形式听起来不太确定并且更加友好 And I’m going to finish by talking about new projects. However, I won’t have any new financial information. Give your audience the rules for questions. During my presentation, if you have questions, please just ask them at any time(or until the end). Transitioning to the next point  As you know However … which brings us to my next point Best of all 首先 Worse yet 最糟糕的是 Now, I’d like to move on to；现在，我想转到。。。 These pie charts show… As you can clearly see … 你可以清楚看到 I’d like to draw your attentions to … Concluding a presentation  To summarize, we have a new CFO, sales are rising steadily and our merger with Smoot happens next month. To conclusion, … Ending a presentation Next steps for us all are to come up with ideas for improving morale. Email them to me. 我们所有人下面要做的是想出提高士气的主意。把它们用邮件发送给我。 I’ll take questions now. Are there any questions? Any more questions? Any other questions? If you think of other questions, just send me an email. Do you have any updates, Tom? Thank you all for coming today. ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2021-02-06-Effective-Presentations/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "",
      "category" : "",
      "content": "Prof. Gilbert: Making use of this technology will instantly benefit some of the poorest people on Earth. Drought-resistant crops will solve the problem of hunger in the developing world. Prof. Gilbert: Fine-tuning the genes of mosquitos so that they spread vaccines instead of malaria will eliminate many terrible diseases. Prof. Gilbert: And, closer to home, gene screening will enable us to find and fix health problems before a person is even born. Prof. Gilbert: Who wouldn’t want the ability to prevent their child from developing cancer? Prof. Gilbert: Being able to change the DNA of plants, animals and ourseleves will trigger a chain reaction of technological advancements, all of which will help us to overcome the challenges the future will throw at us. A: But not all the experts are so optimistic. A: Professor Goldman, fro Queen’s College, is more cautionary. Prof. Goldman: This is untested technology, and I’d warn against taking a leap into the unknown Manipulating DNA for our benefit really is ‘Playing God’, and could come back to haunt us. Prof. Goldman: Imagine we genetically engineer some crops and the changes lead to undesirable results; those changes might be impossible to reverse, and have a disastrous effect on the environment. Prof. Goldman: It’s a slippery slope, with serious consequences. Prof. Goldman: Once we start making changes to human DNA, who knows what terrible results it could have on our health in the future? Prof. Goldman: We really shouldn’t be playing around with technology we don’t fully understand yes. ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/2021-02-06-Future-Technology/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "Badminton",
      "category" : "Hobbies",
      "content": "视频  李在福《Play To Win》完整版   李在福《追球》全集 图文  超全羽毛球技术图解 公众号  和蔡赟聊羽毛球 微信号：caiyunliaoyumaoqiu   羽毛球 微信号：yu-mao-qiu  ",
      "url"      : "https://pfcstyle.github.io/wiki/badminton/",
      "keywords" : "羽毛球"
    } 
  
]

