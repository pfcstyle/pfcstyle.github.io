

[
  
  
    {
      "title"    : "页面没有找到",
      "url"      : "https://pfcstyle.github.io/404.html",
      "keywords" : "404"
    } ,
  
  
  
    {
      "title"    : "About",
      "url"      : "https://pfcstyle.github.io/about/",
      "keywords" : "Yawei Wang, PfCStyle, Will, Zhuang Ma, 王亚威"
    } ,
  
  
  
    {
      "title"    : "归档",
      "url"      : "https://pfcstyle.github.io/archives/",
      "keywords" : "归档"
    } ,
  
  
  
    {
      "title"    : "Categories",
      "url"      : "https://pfcstyle.github.io/categories/",
      "keywords" : "分类"
    } ,
  
  
  
  
  
    {
      "title"    : "Links",
      "url"      : "https://pfcstyle.github.io/links/",
      "keywords" : "友情链接"
    } ,
  
  
  
    {
      "title"    : "mindmap",
      "url"      : "https://pfcstyle.github.io/mindmap-viewer/",
      "keywords" : "mindmap"
    } ,
  
  
  
    {
      "title"    : "Open Source Projects",
      "url"      : "https://pfcstyle.github.io/open-source/",
      "keywords" : "开源,open-source,GitHub,开源项目"
    } ,
  
  
  
  
  
    {
      "title"    : "Wiki",
      "url"      : "https://pfcstyle.github.io/wiki/",
      "keywords" : "维基, Wiki"
    } ,
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
    {
      "title"    : "Create and Open My Blog",
      "category" : "杂记",
      "content": " It’s My First Blog! Go down 这是我第一次自己搭建博客，以前虽然在CSDN上写过，但跟这个比显然有些索然无味了。我使用的这个模板是基于@Hux 分享的模板进行修改替换的，非常感谢！ 第一篇博文写什么呢？最后还是决定把自己搭建的过程记录下来。虽然网上已经有很多类似的了，但我仍觉得有些细节需要总结的，不废话了，Begin! 从Github开始 GitHub Pages是免费的静态站点，三个特点：免费托管、自带主题、支持自制页面和Jekyll。本博客即是建立在Github上的，所以下面介绍的也是基于Github的。 拥有一个Github账号 首先大家应该有一个Github账号，作为一个程序员，如果你还没有加入Github,那么你显然out了！当然这不是为了赶时髦，github现在已经是全球最大的开源社区了，所以，加入的必要性就不言而喻了。 怎么注册账号呢？呃，这个不写了，推荐一篇博文：创建GitHub技术博客全攻略 好吧，推荐了这篇博文之后感觉基本什么都不用写了。但是我还是有一些自己经验的补充（耍无赖:)）。 创建个人博文仓库 Github是这样规定的，以 username.github.io 命名的仓库才可以作为自己的个人（公司）主页，并且此时你的主页代码等等都是在master分支中的，浏览器访问地址是username.github.io (比如我的是：pfcstyle.github.io)。如果你想要为自己的某个项目写文章的话，那么你需要在项目中新建gh-pages分支，浏览器访问地址：username.github.io/yourRepName。  自己DIY才有感情吧，也更有成就感噻！ 没错，正如你所理解的那样，上面推荐的那篇博文里介绍了如何github帮助你自动生成一个博文分支（包括个人的master和项目的gh-pages），但是，这些都是完全自己新建，自己写代码，自己写样式，自己……总之完全可以自定义咯。 本地Git配置 远程的配置好了，该配置本地的了。我这里只介绍windows平台上的，linux/unix步骤也是差不多的。windows上最简单的应该就是这个github for windows 了，直接下载安装就好。但是这个显然不是我介绍的重点，看下面。 1.安装Git 使用命令行的好处，大概就是装逼了。。。但是我觉得命令行更原生，更能看到一些本质。好了，不装了，来这里 下载吧。版本你自己选，这个也是有界面的，但是，真的是丑陋无比，反正我是从来没有用过，都是直接用命令行。 安装好就是配置了，你可以添加环境变量，比如我的是D:  Program Files  Git  bin。其实我并没有配置环境变量，因为我觉得根本不需要，安装好之后根目录下有一个git-bash，哪里需要，哪里运行，尤其是自动添加了右键菜单，还有高亮显示，很是方便。 2.配置本地ssh到github 首先你要生成自己本地的sshkey，打开git-bash //邮箱地址后面的是指定生成公钥的文件名，不过不指定，默认生成~/.ssh/id_rsa.pub ssh-keygen -t rsa -C 邮箱地址 -f ~/.ssh/githug_blog_keys 回车之后还会让你设置提交用户名、密码，可以直接跳过，如图： 生成之后，打开你的pub文件（我的是githug_blog_keys.pub，一般在C:  Users  用户名.ssh  目录下），全选复制里面的内容,来到github进行配置： 如果你已经使用github生成好了，那么来到你想存放的目录下，右键打开git-bash，clone下来就好了： git clone 上图中的ssh 如果你是完全自定义的……那我相信你一定会搞的 Jekyll的安装与配置 Jekyll是一种简单的、适用于博客的、静态网站生成引擎。它使用一个模板目录作为网站布局的基础框架，支持Markdown、Textile等标记语言的解析，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。说白了就是，只要安装Jekyll的规范和结构，不用写html，就可以生成网站。[ jekyll介绍 ] [ jekyll on Github ][ jekyllbootstrap ] Jekyll使用Liquid模板语言，{{page.title}}表示文章标题，{{content}}表示文章内容。我们可以用两种Liquid标记语言：输出标记（output markup）和标签标记 (tag markup)。输出标记会输出文本（如果被引用的变量存在），而标签标记不会。输出标记是用双花括号分隔，而标签标记是用花括号-百分号对分隔[ Liquid模板语言 ][ Liquid模板变量参考 ] jekyll与github的关系：GitHub Pages一个由 GitHub 提供的用于托管项目主页或博客的服务，jekyll是后台所运行的引擎。 jekyll安装之前需要先安装DevKit,DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。但是这个方法目前仅支持通过RubyInstaller安装的Ruby,先下载RubyInstaller ,直接安装就好了，设置环境变量，path中配置C:  Ruby193  bin目录，然后在命令行终端下输入 gem update --system 来升级gem。这里有可能会遇到问题,因为被墙原因导致ssl错误，这时可以替换一下gem软件源： //查看当前所有软件源 gem sources -l //自带的源是https://rubygems.org/ 删除 gem source -r https://rubygems.org/ //添加新源 gem source -a http://rubygems.org/ 网上许多解决此问题是通过替换淘宝源http://ruby.taobao.org/成功的，刚开始笔者也是这样干的，但是并没有卵用，最后还是去掉了’s’成功的。还有一点需要注意的是，在添加源的时候，你不能在git-bash中添加，会提示： ERROR: While executing gem ... (Gem::OperationNotSupportedError)  Not connected to a tty and no default specified 这是说连接不到终端，所以，你需要使用cmd或者是微软新出的windows powershell来添加源才可以。 然后下载DevKit ，跟ruby在同一个下载页面。安装后找到DevKit目录，输入以下命令： ruby dk.rb init ruby dk.rb install 这里需要说明的是，你在dk初始化之后,会提示你查看config.yml中的根目录是否正确，而事实上这个文件里根本就没有配置，你需要添加上自己的ruby目录，如下： --- - D:  Ruby22-x64 然后才去执行下面的install命令。 好啦，接下来就可以安装jekyll了： //安装 注意，jekyll都是小写，大小写是敏感的 gem install jekyll //查看版本号，以确定是否安装成功 jekyll --version 安装Jekyll-Bootstrap： 来到你的本地仓库目录，打开git-bash: git clone https://github.com/plusjade/jekyll-bootstrap.git USERNAME.github.com cd USERNAME.github.com git remote set-url origin git@github.com:USERNAME/USERNAME.github.com.git git push origin master 启动jekyll服务 jekyll server --port 4000//4000是默认端口号 激动人心的时刻到啦，现在去浏览器输入：http://127.0.0.1:4000 ，看看自己的本地博客吧。 不过还没结束呢，激动之余，是不是感觉还有点乱呢？分析一下目录：  _posts: _posts中的数据文档，通过注入_layouts定义的模板，通过jekyll server最终生成的静态页面在_sites目录。目录是用来存放你的文章的，一般以日期的形式书写标题。 _layouts： _layouts中的模板一般指向了_includes/themes中的模板。目录是用来存放模板的，在这里你可以定义页面中不同的头部和底部。 _includes： _includes/JB中有一些常用的工具，用于列表显示、评论等； _includes/themes中可参看主题的相关html文档。 _includes/themes中的主题一般包含default.html、post.html和page.html三个文档。default.html定义了网站的最上层框架（模板），post.html和page.html是其子框架（模板） 生成好的html子页面通过default.html的{{ content }}变量调用，生成整个页面。 asset: 渲染页面的CSS和JS文档在assets/themes中。 _config.yml: 站点生成需要用到_config.yml配置文件，站点的全局变量在_config.yml中定义，用site.访问；页面的变量在YAML Front Matter中定义，用page.访问，更多的模板变量可参考模板数据。jekyll配置详解 当然，并不是一定要这样做，只是一个习惯而已，如果你完全是自定义的，那么你可能都没有这些东西。 第一篇博客开始之前 其实博客开始前的工作基本算是说完了，可是我觉得还是要对这个layout进行补充一下： 去网上找现成的layout layout即是你的blog的样式和布局，网上有许多精美的主题供下载 自己定义layout 从头自定义的话，无疑很是费劲,所以我建议也像我一样，找到现成的模板，慢慢修改。 写第一篇博客 直接使用markdown来写好了，唯一需要说一下的的是文件头的声明格式： --- layout: t tpost title: t tCreate and Open My Blog description: Hello Blog date: t t2016-03-20 17:45:00 author: t tPfCStyle keywords:  t- Github  t- Blog  t- Jekyll  t- Markdown  t- CDName  t- layout --- 看意思应该都明白是什么，不再赘述了，但是，需要提醒大家的是这些不是固定的，不同的layout是有不同参数的。再来张图吧： 最后是找个自己的域名 首先是购买一个域名，域名购买之后，要先设置解析，你购买域名的地方都是可以设置的，过程大致相似： 最后还需要在你的博客分支根目录下添加CNAME文件，里面放上你的域名就可以了，github就会为你自动跳转。 ok,大功告成！ ",
      "url"      : "https://pfcstyle.github.io/2016/03/21/Hello-Blog/",
      "keywords" : "[&quot;Blog&quot;, &quot;Github&quot;, &quot;Jekyll&quot;, &quot;Bootstrap&quot;, &quot;Markdown&quot;]"
    } ,
  
    {
      "title"    : "Android Studio for Beginer(一)",
      "category" : "Android",
      "content": " 工欲善其事，必先利其器 相信使用过eclipse的朋友们都体验过eclipse每次装插件都装不上的痛苦，尤其是配置adt，最是让人头痛，因为还面临着adt和sdk版本不匹配的问题，特别是每次google发布新的sdk，adt就必须跟着升级才行，实在是苦不堪言。终于，历时两年，google终于推出了android studio,完善的插件体统，以及对eclipse等工程的兼容，还有方便的sdk管理，最后再集成了Gradle项目管理，真是处处体现了android studio的强大与方便。 android studio的安装我相信不用多说，我们直接从hello world开始。 Hello World 如果你是刚刚装好了Android Studio,你应该是在欢迎界面，点击Create New Project,或者你已经打开或者导入过项目了，那就选择File&gt;New&gt;New Project,然后你会看到下图的界面。在Application name中填上Hello World，这里建议是以大写字母开头。Company Domain就是公司域名，Package name是反转的Company Domain加上Application Name。最后修改你的工程路径，本次修改后，路径会记录，下次如果不想修改就不用管了，感觉这个比设置默认的工作路径要方便很多。 next之后是硬件选择界面，Phone and Tablet(手机和平板)是默认被选中的，下面依次是Wear(手表)、TV(电视)、Android Auto(车载应用)、Glass(眼镜),他们每一项都要求设定最低支持的SDK版本，你们可以根据自己的需求来设定，如果自己无法确定，下面还有一个Help me choose,他可以向你展示android各个版本的市场份额，可以帮助你确定你的需求。 next之后是模板选择界面，我们这里选择empty Activity next之后是设置activity的名称这些，我们就使用默认的就好了。 点击完成，我们的hello world就创建成功了！ 使用虚拟机运行Hello World Android虚拟设备管理器允许你创建Android虚拟设备（AVDs），然后你可以在你的电脑上运行模拟器。模拟和仿真有一个很重要但是微妙的区别。模拟意味着虚拟设备只有一个外形，模拟实际的物理设备如何运作，但是不针对特定的操作系统。IOS开发环境使用模拟器，对于有限数量的设备的平台的IOS来说可能是一个不错的选择。 然而对于仿真器而言，你的电脑留出一块内存去复制基于仿真器正在仿真设备上的环境。Android Studio使用仿真器，这意味着Android虚拟设备管理器启动一个 Linux内核的大沙箱和整个Android栈为了仿真基于Android物理设备的环境。尽管仿真器提供了一个比模拟器更可靠的环境来测试你的应用程序，但是启动一个AVD需要数分钟，这取决于你电脑的速度。好消息是你的仿真器仍然活跃在内存中，它仍然是有响应的。然而，如果你有Android手机或者平板电脑，我们建议使用物理设备来测试你的应用程序，而不是使用AVD。也就是说，我们首先使用Android虚拟设备管理器创建一个AVD，在后来的章节我们将想你展示如何连接你的物理设备,当然如果你有的话。 下面我们将创建一个仿真器，选择工具栏中的avd manager 打开之后，点击左下角的Create Virtual Device,选择Galaxy Nexus，然后点击Next。下一个界面允许你选择一个系统镜像。选择Lollopop（或最新的API）和x86_64的API,如果你没有，那么点击download下载就好了，android studio会自动为你配置好的。点击Next 接下来是虚拟机的具体的一些配置参数，点击show Advanced Settings会显示出更多的高级选项。下图中会详细标出，点击finish，恭喜你，你的第一个虚拟机已经创建成功了。 点击绿色按钮运行，选择你刚刚创建的虚拟机，你将会看到hello world。 使用真机运行Hello World 使用真机调试的关键是要让你的电脑连接上你的手机，你可能需要安装与你的手机匹配的USB驱动，你可以自己去找一下，也可以让360之类的手机助手帮你安装，现在已经不是问题了。此外，你还需要打开开发人员选项并确保USB调试框被选中。当你成功连接真机之后，你可以在android device monitor中查看你的真机是否出现，并且状态为online，如下图： 接下来，直接点击运行就好了，Hello World应该成功出现在你的手机上了。 ",
      "url"      : "https://pfcstyle.github.io/2016/03/26/Android-Studio1/",
      "keywords" : "[&quot;Android&quot;, &quot;Tool&quot;, &quot;Android studio&quot;]"
    } ,
  
    {
      "title"    : "搭建驱动开发环境之VS2015+SDK10+WDK10安装",
      "category" : "Windows",
      "content": " 困难总是需要克服的 这两天一直在搭建驱动开发环境，本来是VS2010的，后来网上找了一下，配置起来比较麻烦，就没有去搞，直接换了VS2015了，然而，事情并没有想象中的那么简单。 从VS2015开始 刚开始我很自然的就去了微软的官网，也找到了VS2015,而且和WDK10在一起，于是我很开心的下载了下来，当然，只是一个安装器而已，于是，就苦逼的在线开始下载安装，然而，等来的却全是失败。 每次安装失败的都不一样，我去网上搜，也找到了各种答案(?),但没有一个可以解决我的问题。于是乎，好吧，找到了VS2015离线安装包，直接安装，什么问题也没有了。但是值得提醒的是你要记得在安装的时候选择自定义，然后把C++相关的装上，不然WDK安装的时候会提示你安装。然后，你应该和我一样，没有什么问题了。 WDK 和 SDK 的安装 WDK和SDK同样也是可以从微软官网找到的，我就不提供链接了，为什么？没有用啊，下载的只是下载器，等待的仍然是失败！我就只好提供WDK10和SDK10的百度云了。直接安装就好了，相信不会有任何问题。 另外提一下啊，如果你还想研究xp的话，那么你需要下载WDK7 好吧，想不到折磨了我好几天，甚至让我重装了一次系统的问题，三言两语就写完了，洗过了，睡了。 ",
      "url"      : "https://pfcstyle.github.io/2016/03/27/VS-WDK-SDK/",
      "keywords" : "[&quot;VS2015&quot;, &quot;驱动开发&quot;, &quot;内核开发&quot;, &quot;WDK10&quot;, &quot;SDK10&quot;, &quot;Windows Driver Kit&quot;]"
    } ,
  
    {
      "title"    : "C盘清理小技巧",
      "category" : "杂记",
      "content": " 小记 下面是C盘可以清理的路径： - C盘搜索FileRepository,这是windows自动推送的驱动更新，全选，删除。如果有些删不掉就跳过。 - C:  Windows  SoftwareDistribution  Download - C:  Users  **user**  AppData  Local  Temp ",
      "url"      : "https://pfcstyle.github.io/2016/03/28/Clean-DiskC/",
      "keywords" : "[&quot;磁盘清理&quot;, &quot;系统盘瘦身&quot;]"
    } ,
  
    {
      "title"    : "android source download on windows",
      "category" : "Android",
      "content": " 透过现象看本质 先跟大家推荐一个网站,这里提供了可以翻墙的hosts，毕竟google,大家都懂得。 最近想看看android的源码，于是就去google下载，google提供了具体的环境需求和下载方式，大家可以参考这里,但是，google官方提供的这种方式只能用于linux,因为它提供的repo是一个python脚本，里面一些模块是linux特有的，windows无法安装。 一种变通的方式是在windows上安装Cygwin，这是一个模拟linux环境的软件，安装好后再按照google官网说的搭建环境，下载源码即可。 但是我觉得上面的过程都太复杂了，用起来很不方便，后来我看了下google官方提供的repo文件，发现其本质就是先使用git clone下来android源码的清单文件,所以，你需要先安装git,git的安装就不说了，我之前的博客已经有介绍过了。假设你已经装好了git,找到你想要放android源码的目录，执行： git clone https://android.googlesource.com/platform/manifest cd manifest 接下来执行: //列出android各个分支版本 git tag //使用git checkout 切换到你想要的源码的分支，名称就是git tag列出的名称，比如android4.4.2 git checkout android-4.4.2_r1 这里所谓的切换分支只是切换到了对应分支的manifest清单文件，接下来，我们将使用清单文件进行源码下来，下面，有请python出场。下载安装python，具体过程我就不说了，很简单。建议安装python2.7，比较稳定。 这里提供一个根据manifest清单文件下载的python脚本，我在网上找到了下载的基础代码，自己添加了断点续传，方便大家使用。 import xml.dom.minidom import os from subprocess import call import stat #downloaded source path rootdir = F:/Documents/android_src/AndroidCode #git program path git = D:/Git/bin/git.exe dom = xml.dom.minidom.parse(F:/Documents/android_src/AndroidCode/manifest/default.xml) root = dom.documentElement prefix = git + clone https://aosp.tuna.tsinghua.edu.cn/ suffix = .git if not os.path.exists(rootdir):  os.mkdir(rootdir) def rmtree(top):  for root, dirs, files in os.walk(top, topdown=False):  for name in files:   filename = os.path.join(root, name)   os.chmod(filename, stat.S_IWUSR)   os.remove(filename)  for name in dirs:   os.rmdir(os.path.join(root, name))  os.rmdir(top) lastPath_pre = None lastName = None lastPath_all = None for node in root.getElementsByTagName(project):  os.chdir(rootdir)  d_all = node.getAttribute(path)  last = d_all.rfind(/)  if last != -1:  d_per = rootdir + / + d_all[:last]  d_all = rootdir + / + d_all  else:  d_per = rootdir + /  d_all = rootdir + / + d_all  print d_per  if os.path.exists(d_all):  lastPath_all = d_all  lastPath_pre = d_per  lastName = node.getAttribute(name)  else:  if not lastPath_all == None:   rmtree(lastPath_all)   os.chdir(lastPath_pre)   cmd = prefix + lastName + suffix   call(cmd)   lastPath_all = None  if not os.path.exists(d_per):   os.makedirs(d_per)  os.chdir(d_per)  cmd = prefix + node.getAttribute(name) + suffix  call(cmd)  需要注意的是要将里面的git和存放源代码路径都替换为你自己的。上面我使用的是清华的镜像，速度很快，推荐使用，如果不放心，可以自己替换为google的https://android.googlesource.com/，但是表示速度难以忍受。。。 ",
      "url"      : "https://pfcstyle.github.io/2016/03/29/Android-sources-download/",
      "keywords" : "[&quot;Android源码&quot;, &quot;windows&quot;, &quot;Android系统&quot;]"
    } ,
  
    {
      "title"    : "Android Studio for Beginer(二)",
      "category" : "Android",
      "content": " 工欲善其事，必先利其器 今天说一下代码方面常用的设置，以及快捷键。 常用快捷键记录  Ctrl + N 使用输入类名对话框快速打开类文件 Ctrl + Shift + N 搜索所有的文件名 Ctrl + Shift + A 动作或选项搜索框，如搜索show line numbers就会自动列出显示行数的开关，支持模糊查询 Ctrl + Shift + F/R 全局搜索/替换，可以搜索/替换文件内容，还可以设置过滤 Ctrl + G 以行和列导航单个文件，如果只输入一个数字，就是调到行 Ctrl + Alt + Home 列出与当前文件相关联的文件，如：xml Ctrl + Shift + Backspace 移动到最后编辑位置 Ctrl + ‘+’(数字键盘的) 展开代码块 Ctrl + ‘-‘(数字键盘的) 收缩代码块 Ctrl + Space 基本代码补全功能，附带javadoc展示 Ctrl + Shift + Space 智能代码补全，比基本代码补全范围更广 Ctrl + ‘/’ 行注释 Ctrl + Shift + ‘/’ 块注释 Ctrl + z 撤销 Ctrl + Shift + z 恢复撤销 Ctrl + J 调用动态模板，这是打出了缩略词之后调用 Ctrl + Alt + J 显示出动态模板列表 Ctrl + Shift + Down 向下移动代码块 Ctrl + Shift + Up 向上移动代码块 Ctrl + Alt + L 自动格式化代码 Ctrl + Alt + I 自动缩进代码 Code ➤ Rearrange 自动整理代码 Ctrl + Alt + T 环绕代码 如try/catch,if/else等等 Ctrl + Shift +Delete 删除环绕代码 Ctrl + E 查看最近打开过的文件 默认最多记录50个 Ctrl + Alt + 左箭头 遍历导航操作，上一个导航 Ctrl + Alt + 右箭头 遍历导航操作，下一个导航 Alt + ‘/’ 循环扩展 Alt + ‘F1’ 打开导航列表 Alt + Insert 生成代码，包括构造器，getter,setter等等 Shift + Tab 取消缩进 常用设置 代码生成设置 恰当的使用代码生成功能，这一特色将为你节约大量的时间，代码生成是生成各种方法的的强大功能，包括了构造，getters, setters, equals()，hashCode(), toString()方法等等。在你使用代码生成之前，确认Android Studio 是配置好了，可以忽略成员名称的前缀，如m和s（因为我们一般遵循成员变量前加’m’，静态变量前加’s’的规则），点击File ➤ Settings ➤ Code Style ➤ Java ➤ Code Generation将得到设置对话框，将会出现代码生成的标签页，如果域和静态域文本框不包含m和s，则键入他们，并点击”应用“和”确定“，如图 在模板中保存自己常用的代码 Android Studio有很多模板,允许您将预定义的代码直接插入到你的源文件中。在许多ide,生成的代码只是从模板中粘贴，而从来不考虑作用域;但是Android Studion的模板是对作用域敏感的,也可以集成变量数据。在你开始使用Android Studio的动态模板之前,让我们探索动态模板和自定义模板。导航到File ➤ Settings ➤ Live Templates。选择普通模板组。现在在右上角单击绿色加号按钮并选择住模板。如图，填充好缩写、描述和模板文本字段。在这个模板可以应用之前,您必须单击Define按钮,这看起来像一个蓝色的超文本链接，位于窗口的底部。现在选择Java和选择所有范围(语句,表达式,声明等等)。单击Apply 图中的$selection$意思是你选择的内容，你先选择一段文字，然后按Ctrl + Alt + J，选择cb模板，就会自动出现上图中定义的内容了。 定义你自己的代码风格 代码风格规范在不断发展。没有固定的规则，你应该在你的方法之后放置空格的数量，还是左括号应该出现在同一行作为方法签名或略低于它。组织倾向于定义自己的代码风格,但每个程序员的代码风格也各不相同,你也可能有你习惯的代码风格。幸运的是,Android Studio很简单就能样式化和组织你的代码。在开始样式化代码之前，让我们检查一下代码风格的设置。选择File ➤ Settings ➤ Code Style弹出设置对话框,如图所示。Java和XML是我们在Android中最感兴趣的语言。在左窗格中切换打开代码风格选项,选择Java,并检查在设置窗口的每个选项卡 代码风格的定义选项非常多，建议大家自己点击多试试，在右侧的代码框中会即时响应你的修改。 ",
      "url"      : "https://pfcstyle.github.io/2016/03/30/Android-Studio2/",
      "keywords" : "[&quot;Android&quot;, &quot;Tool&quot;, &quot;Android studio&quot;]"
    } ,
  
    {
      "title"    : "Android Studio for Beginer(三) 之初识Gradle",
      "category" : "Android",
      "content": " 工欲善其事，必先利其器 今天大致的介绍一下Gradle 为什么要用Gradle  一个像Ant一样灵活且通用的构建工具。 一种可切换的，像Maven一样的基于约定的构建框架，却又从不约束你（约定优于配置）。 对多项目构建的强力支持。 对依赖管理的强力支持（基于Apache Ivy）。 对已有的Maven和Ivy仓库有着全面的支持。 支持可传递性的依赖管理，而不需要远程仓库或者pom.xml和ivy.xml配置文件。 Gradle能够很好地支持Ant任务和构建 。（有更好的翻译欢迎提议） 支持用Groovy语言编写Gradle的脚本。 拥有丰富的领域模型来构建你的脚本。 Gradle的核心是一个丰富的可扩展的基于Groovy的领域特定语言(DSL)。Gradle通过提供说明性语言元素将说明性构建推到下一层，您可以组装。这些元素也提供build-by-convention支持Java、Groovy、OSGi、Web和Scala项目。说了这么多，下面我们来一个快速入门。 Gradle快速入门 Gradle安装 Gradle需要安装1.6及以上版本的Java JDK或JRE（使用java -version来查看当前版本）。Gradle拥有自己的Groovy库，因此不需要另行安装Groovy。任何已安装的Groovy都会被Gradle给忽略。Gradle使用环境变量中设置的JDK。 代码生成设置 恰当的使用代码生成功能，这一特色将为你节约大量的时间，代码生成是生成各种方法的的强大功能，包括了构造，getters, setters, equals()，hashCode(), toString()方法等等。在你使用代码生成之前，确认Android Studio 是配置好了，可以忽略成员名称的前缀，如m和s（因为我们一般遵循成员变量前加’m’，静态变量前加’s’的规则），点击File ➤ Settings ➤ Code Style ➤ Java ➤ Code Generation将得到设置对话框，将会出现代码生成的标签页，如果域和静态域文本框不包含m和s，则键入他们，并点击”应用“和”确定“，如图 在模板中保存自己常用的代码 Android Studio有很多模板,允许您将预定义的代码直接插入到你的源文件中。在许多ide,生成的代码只是从模板中粘贴，而从来不考虑作用域;但是Android Studion的模板是对作用域敏感的,也可以集成变量数据。在你开始使用Android Studio的动态模板之前,让我们探索动态模板和自定义模板。导航到File ➤ Settings ➤ Live Templates。选择普通模板组。现在在右上角单击绿色加号按钮并选择住模板。如图，填充好缩写、描述和模板文本字段。在这个模板可以应用之前,您必须单击Define按钮,这看起来像一个蓝色的超文本链接，位于窗口的底部。现在选择Java和选择所有范围(语句,表达式,声明等等)。单击Apply 图中的$selection$意思是你选择的内容，你先选择一段文字，然后按Ctrl + Alt + J，选择cb模板，就会自动出现上图中定义的内容了。 定义你自己的代码风格 代码风格规范在不断发展。没有固定的规则，你应该在你的方法之后放置空格的数量，还是左括号应该出现在同一行作为方法签名或略低于它。组织倾向于定义自己的代码风格,但每个程序员的代码风格也各不相同,你也可能有你习惯的代码风格。幸运的是,Android Studio很简单就能样式化和组织你的代码。在开始样式化代码之前，让我们检查一下代码风格的设置。选择File ➤ Settings ➤ Code Style弹出设置对话框,如图所示。Java和XML是我们在Android中最感兴趣的语言。在左窗格中切换打开代码风格选项,选择Java,并检查在设置窗口的每个选项卡 代码风格的定义选项非常多，建议大家自己点击多试试，在右侧的代码框中会即时响应你的修改。 ",
      "url"      : "https://pfcstyle.github.io/2016/04/09/Android-Studio3/",
      "keywords" : "[&quot;Android&quot;, &quot;Tool&quot;, &quot;Android studio&quot;, &quot;Gradle&quot;]"
    } ,
  
    {
      "title"    : "史上最简单的VPN搭建-softether",
      "category" : "VPN",
      "content": " 所有的墙都是纸老虎-PfCStyle 我真是觉得很悲催，眼望着马上要毕业了，我们学校网络中心发了一个通告，从此，每月20元不限流量的舒服日子结束了，以后要根据流量算每月的网费了，再也不能随心所欲的看想看的片了。。。 然而，作为一个崇尚自由的程序猿，面对一切封锁，都要打破！打破！打破！于是我伸展一下那过膝的双臂，准备翻墙了。 大家都知道，大学的ipv6的流量一直是免费的，而我，将要利用的就是这个。下面就是我的翻墙历程。 从VPS开始 首先，我得选择一个免费的VPS进行试验，于是我在网上找呀找，找到了亚马逊的aws, 只要你有一张信用卡，那么，你可以很轻松的获得12个月的免费试用。具体免费套餐内容请浏览这里. 没有信用卡？没有关系，经网友们测试，从淘宝买的虚拟信用卡可以用作激活Amazon AWS，关键词：“虚拟信用卡 amazon”. 注册aws 好的，都准备好了，现在，去亚马逊的aws 注册一个账号。看图：   在这一步一定要注意，因为默认选择的是开发人员选项，要扣40美金的偶，立刻就会扣，没有反应时间。。。好吧，被看出来了，我被扣了– 这一步之后注册就算是完成了，等待几分钟账号就会被激活了，有些人的会等很久才能激活，可能跟前面填写的信息有关系。 开始创建VPS 这个描述起来也是相当麻烦，大家看图吧。    到了这里，已经算是把一个VPS建好了，需要什么服务都可以自己配置了，接下来说如何本地连接到远程VPS,有多种方式，大家可以详细参看官网教程, 我这里只介绍我使用的方式，putty连接。 连接VPS 1.软件准备 从putty下载页面 下载putty和puttygen. putty是用来连接VPS的，但是VPS的连接需要提供秘钥，就是上文要你下载的pem文件。但是putty并不直接支持pem文件，你需要把pem文件转换为ppk文件，这就需要puttygen来完成了，下面，我们来转换。 2.转换秘钥格式  这样就转换好了，接下来我们开始正式连接VPS了： 3.获取连接VPS需要的信息 实例的获取公有DNS信息，如图： 填写信息：Host Name的格式是user_name@public_dns_name，其中user_name是root 或 ec2-user，但是经过测试，root是禁止直接登录的，所以只能使用ec2-user。注意不同的linux系统user_name是不同的，这里说得是Redhat，请到上文提到的官网教程查看具体内容。public_dns_name就是上步获取的公有dns 为了避免每次都重复填写，可以点击save按钮进行配置保存。 配置上文转换过得秘钥 4.连接 点击open启动 现在已经连上了VPS了，大家想干什么就随意吧。 开始配置VPN 使用SoftEther 软件准备 在VPS上下载softEther VPN: 你可以选择下载最新版本的，也可以选择较为稳定的版本。 //首先安装wget sudo yum install wget sudo wget http://www.softether-download.com/files/softether/v4.20-9608-rtm-2016.04.17-tree/Linux/SoftEther_VPN_Server/64bit_-_Intel_x64_or_AMD64/softether-vpnserver-v4.20-9608-rtm-2016.04.17-linux-x64-64bit.tar.gz  这个网上有些教程说下载这个是需要翻墙的，对于国内用户确实是这样，但是，但aws可是在美国呢，嘿嘿，不用担心，直接下就好了，速度杠杠的。还是提供一下百度云下载 插一下，putty经常死机，准确来说，如果你隔了两三分钟没有操作，aws就会把你的连接踢掉，但是如果你一直在使用就不会有什么问题的。死机了就重连好了。 开始安装 好的，下载完成了，解压： tar -zxvf softether-vpnserver-v4.20-9608-rtm-2016.04.17-linux-x64-64bit.tar.gz 接下来开始配置VPN了，是不是想想都要头疼了？但是，史上最简单，可不是白说的，看看一键配置！ cd vpnserver/ ./.install.sh 接下来，它会让你阅读用户协议，然后让你同意，你就连输入3个‘1’就ok了，进入正式安装。oh!出错了，提示缺少gcc，不早说。。。 //安装gcc sudo yum install gcc 安装完毕，再去执行上面的命令，输入3个‘1’，安装成功啦（如果你使用的其他系统，获取其他VPS，可能会缺少其他的依赖，按照错误提示一个个安装即可），好了，试试： ./vpnserver start ./vpnserver stop so easy! 在本地管理VPN 下载管理软件 好吧，还得需要下载 一个管理软件，这个要翻墙了。如图： 这里提供百度云下载。 下载之后解压就可以使用了，打开vpnsmgr.exe。 配置连接 连接VPN server 欧，遇到问题了，为什么会连接不上呢？现在要来说说aws的安全组是怎么一回事了。这个安全组类似于防火墙，你可以配置允许出入的协议和流量，看图： 配置允许访问的端口和协议，这些端口都是softether监听的端口号，在官网可以找到。如果你实在是觉得烦，可以开放所有流量，这个你自己决定吧，不安全偶~ 好的，接下来成功连接 你会进入下面这个界面（刚刚进入，会提示你进行各种配置，全X掉吧，我一步步的展示） 配置VPN 配置L2TPVPN 管理VPN用户配置 这里创建的用户以及密码会在连接vpn时使用。 配置NAT 这个不多解释，按照我的配置来吧。点击确定之后，VPN的所有配置算是完成了。怎么样，全部界面化，是不是非常简单。 连接VPN 接下来就是最激动人心的时刻了，试着连接VPN吧。直接使用windows自带的VPN连接就可以了：    连接成功啦！！！ IPV6配置 好的，现在万事俱备，只欠东风啦。配置一个公网的Ipv6就可以了。到哪里找呢，我只推荐HE, 就是好用，下面看操作。 先注册账号 注册就不多说了，简单。接下来看配置。 申请ipv6地址 申请成功之后就会显示如下界面 Vps配置ipv6地址 转到下图界面，选择自己的系统，通用的linux就是选择下图的linux-net-tools,然后就会出现下面的配置命令了。但是你要记得在添加sudo权限才可以执行 配置ipv6的网络命令 sudo ifconfig sit0 up sudo ifconfig sit0 inet6 tunnel ::【he中Server IPv4 Address】 sudo ifconfig sit1 up sudo ifconfig sit1 inet6 add 【he中Server IPv6 Address】 sudo route -A inet6 add ::/0 dev sit1 配置完毕之后，进行测试，如下图： ping ipv6.baidu.com 好了，接下来就可以尝试使用ipv6进行vpnconnect了： 这个除了主机地址是使用ipv6外，其他都是和ipv4配置相同的。连接就好了，如果你也是在校学生，那么，嘿嘿，我要飞得更高~~ 结束！ PS:说明一下啊，这个aws的流量并不是无限制的，一个月只有15g（上行和下行分别为15g）的，超过要扣费的。其他具体免费套餐内容参见这里. 但是你们可以用aws练手，然后再去网上租VPS,也挺便宜的。 ",
      "url"      : "https://pfcstyle.github.io/2016/04/25/VPS-softether/",
      "keywords" : "[&quot;VPN&quot;, &quot;VPS&quot;, &quot;SoftEhter&quot;, &quot;IPV6&quot;, &quot;AWS&quot;, &quot;CE2&quot;]"
    } ,
  
    {
      "title"    : "Android Studio for Beginer(四)之Gradle示例 ",
      "category" : "Android",
      "content": " 如果你不够懒，那么，你就做不好一个程序员。 不说废话，先直接说怎么做吧。 友盟多渠道打包 1.首先是在AndroidManifest.xml里面添加最下面一段： &lt;?xml version=1.0 encoding=utf-8?&gt; &lt;manifest xmlns:android=http://schemas.android.com/apk/res/android   package=me.pfcstyle.helloword&gt; &lt;application  android:allowBackup=true  android:icon=@mipmap/ic_launcher  android:label=@string/app_name  android:supportsRtl=true  android:theme=@style/AppTheme&gt;  &lt;activity android:name=.MainActivity&gt;   &lt;intent-filter&gt;    &lt;action android:name=android.intent.action.MAIN/&gt;   &lt;category android:name=android.intent.category.LAUNCHER/&gt;   &lt;/intent-filter&gt;  &lt;/activity&gt;  &lt;/application&gt;  t&lt;!--这里 --&gt;  &lt;meta-data  android:name=UMENG_CHANNEL  android:value={UMENG_CHANNEL_VALUE} /&gt; &lt;/manifest&gt; 里面的{UMENG_CHANNEL_VALUE}就是渠道指示，我们配置为PlaceHolder,这样可以在build.gradle里设置productFlavors,从而让其在编译时自动变化。 2.在build.gradle设置productFlavors productFlavors {  xiaomi {}  _360 {}  baidu {}  wandoujia {}  } productFlavors.all {  flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]  } 或者这样写也是一样的： productFlavors {  xiaomi {   manifestPlaceholders = [UMENG_CHANNEL_VALUE: xiaomi]  }  _360 {   manifestPlaceholders = [UMENG_CHANNEL_VALUE: _360]  }  baidu {   manifestPlaceholders = [UMENG_CHANNEL_VALUE: baidu]  }  wandoujia {   manifestPlaceholders = [UMENG_CHANNEL_VALUE: wandoujia]  }  }  如果你想确认一下你的productFlavors是否添加成功了，你可以通过下图验证： 然后命令行定位到你的项目的根目录，执行./gradlew assembleRelease，然后就可以静静的等待各渠道打包完成了。 一些可能的问题 如果你在执行./gradlew 的时候，提示你要下载类似gradle-2.10-all(这个版本可能不同)，这个下载比较慢，而且你会发现每一个工程都要安装，这本就很不合理，看解决方法！ 去官网下载对应版本的gradle-v-all.zip，然后到工程根路径-&gt;gradle-&gt;wrapper下找到gradle-wrapper.properties，编辑最后一行的 distributionUrl=https  ://services.gradle.org/distributions/gradle-2.10-all.zip //更改为 distributionUrl=gradle-2.10-all.zip 然后将你下载好的zip包放到工程根路径-&gt;gradle-&gt;wrapper下，如图： 好了，再去执行gradlew -v ok啦，显示如下图： 除此之外 assemble 还能和 Product Flavor 结合创建新的任务，其实 assemble 是和 Build Variants 一起结合使用的，而 Build Variants = Build Type + Product Flavor ， 举个例子大家就明白了： 如果我们想打包wandoujia渠道的release版本，执行如下命令就好了： ./gradlew assembleWandoujiaRelease 如果我们只打wandoujia渠道版本，则： ./gradlew assembleWandoujia 此命令会生成wandoujia渠道的Release和Debug版本 同理我想打全部Release版本： ./gradlew assembleRelease 这条命令会把Product Flavor下的所有渠道的Release版本都打出来。 Gradle管理依赖 gradle最常用的还是管理依赖吧，看看有多简单： dependencies {  compile fileTree(dir: 'libs', include: ['*.jar'])  compile 'com.android.support:appcompat-v7:23.4.0'  compile 'com.android.support.constraint:constraint-layout:1.0.0-alpha1'  testCompile 'junit:junit:4.12'  androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2.2'  androidTestCompile 'com.android.support.test:runner:0.5'  androidTestCompile 'com.android.support:support-annotations:23.4.0' } 直接执行上述的编译，gradle就会自动帮你下载添加到依赖，根本不用管了。这在我们使用第三方的时候就会非常方便，一句话，所有需要的jar包什么的都有了。 Gradle依赖的统一管理 那么，嘿嘿，更简单的来了，下面说一下依赖的统一管理方式。 统一一个依赖管理文件 你要先自己创建一个config.gradle文件来统一管理你的依赖和其他系统版本这些参数，注意，这个文件不是属于某一个工程的，而是属于你个人或者公司的维护的文件，在你的工程中只是引用它。 ext { android = [compileSdkVersion: 23,   buildToolsVersion: 23.0.2,   applicationId : me.storm.ninegag,   minSdkVersion : 14,   targetSdkVersion : 22,   versionCode : 2,   versionName : 1.1.0] dependencies = [support-v4   : 'com.android.support:support-v4:23.1.1',    appcompat-v7   : 'com.android.support:appcompat-v7:23.1.1',    design    : 'com.android.support:design:23.1.1',    cardview-v7   : 'com.android.support:cardview-v7:23.1.1',    recyclerview-v7  : 'com.android.support:recyclerview-v7:23.1.1',    multidex    : com.android.support:multidex:1.0.+,    butterknife   : 'com.jakewharton:butterknife:7.0.1',    volley    : 'com.mcxiaoke.volley:library:1.0.19',    okhttp    : 'com.squareup.okhttp:okhttp:2.7.0',    okhttp-urlconnection  : 'com.squareup.okhttp:okhttp-urlconnection:2.7.0',    leakcanary   : 'com.squareup.leakcanary:leakcanary-android:1.3.1',    glide    : 'com.github.bumptech.glide:glide:3.6.1',    glide-okhttp-integration : 'com.github.bumptech.glide:okhttp-integration:1.3.1',    foldable-layout  : 'com.alexvasilkov:foldable-layout:1.0.1',    etsy-grid   : 'com.etsy.android.grid:library:1.0.5'] } 上面是我的config.gradle文件，你们放你们需要的依赖以及配置其他的参数。 如何引用？ 如下图： 只需在最顶部加上上面一行代码，意思就是所有的子项目或者所有的modules都可以从这个配置文件里读取内容。 最后在到app目录下的build.gradle文件里看下具体如何读取的呢？ android节点下的读取： denpendencies节点下的读取： 参考博客：Gradle依赖的统一管理 ",
      "url"      : "https://pfcstyle.github.io/2016/05/26/Android-Studio4-Gradle/",
      "keywords" : "[&quot;Android&quot;, &quot;Gradle&quot;, &quot;多渠道打包&quot;]"
    } ,
  
    {
      "title"    : "iOS项目总结(一)",
      "category" : "iOS",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 之前就知道闷头写项目，在项目中解决了什么问题也不知道记录，现在很是后悔，如今来总结一下，希望能够回忆起一些。 iOS开发的本地存储主要有五种形式  XML属性列表（plist)归档 Preference(偏好设置NSUserDefaults) NSKeyedArchiver归档(NSCoding) SqlLite（本地数据库） CoreData（苹果官方封装的SqlLite数据库操作接口） 上述五种本地的存储方式在我们日常编码中都非常常用，本篇文章先介绍前三种，后两种请参考我的后续博文iOS项目总结(二)-iOS本地持久化总结2 应用沙盒 要想真正了解本地数据存储，你需要先了解什么是应用沙盒。我们都知道，iOS的各个应用的文件夹是对其他应用封闭的，也就是说它的文件系统是隔离的，而这每一个应用的数据文件夹就是应用沙盒。那么，如何获取应用沙盒的路径呢？可以通过打印NSHomeDirectory()来获取应用沙盒路径。 test[15254:733802] 沙盒：/Users/developer/Library/Developer/CoreSimulator/Devices/0360A858-A0E7-45A7-AE71-09D7988C089F/data/Containers/Data/Application/2FB5B4BB-A097-411D-A8BA-6043155C171E 这里需要提醒大家注意的是，如果你是在调试，那么你每次从XCode运行应用，沙盒路径都会发生改变。我之前做项目有一个涉及到管理草稿的，当时在这个坑里跳了一整天才跳出来。。。当然，如果你的应用发布了，那么，沙盒路径就是固定不变的。 接下来我们看一下沙盒的结构，Finder的快捷键shift+com+g可以前往任意路径  Documents: 保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录。例如，游戏应用可将游戏存档保存在该目录 Library/Caches: 保存应用运行时生成的需要持久化的数据，iTunes同步设备时不会备份该目录。一般存储体积大、不需要备份的非重要数据 Library/Preference: 保存应用的所有偏好设置，iOS的Settings(设置)应用会在该目录中查找应用的设置信息。iTunes同步设备时会备份该目录 tmp: 保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录 Document文件夹获取 // NSDocumentDirectory 要查找的文件 枚举 // NSUserDomainMask 代表从用户文件夹下找 枚举 // 最后的Yes代表返回完整路径，No是这样的形式:~/Documents // 在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素 NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; NSString *filePath = [path stringByAppendingPathComponent:@xxx.plist]; 其他的文件夹路径的获取方式我就不一一介绍了。接下来正式说持久化方式 XML属性列表(plist)归档 plist文件只能是数组、字典、数值、字符串、Bool值这几种类型，而根类型必须是数组或者字典。 plist文件的归档 NSString *filePath = [path stringByAppendingPathComponent:@xxx.plist]; // 解档 NSArray *arr = [NSArray arrayWithContentsOfFile:filePath]; NSLog(@%@, arr); plist文件的解档 NSArray *arr = [[NSArray alloc] initWithObjects:@1, @2, nil]; // NSDocumentDirectory 要查找的文件 // NSUserDomainMask 代表从用户文件夹下找 // 在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素 NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0]; NSString *filePath = [path stringByAppendingPathComponent:@xxx.plist]; [arr writeToFile:filePath atomically:YES]; Preference(偏好设置NSUserDefaults) OC中有一个NSUserDefaults的单例，它可以用来存储用户的偏好设置，例如：用户名，字体的大小，用户的一些设置等。 保存用户偏好设置 // 获取用户偏好设置对象 NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; // 保存用户偏好设置 [defaults setBool:self.one.isOn forKey:@one]; [defaults setBool:self.two.isOn forKey:@two]; // 注意：UserDefaults设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。这应该是iOS7之前的问题 // 出现以上问题，可以通过调用synchornize方法强制写入 // 现在这个版本不用写也会马上写入 不过之前的版本不会 [defaults synchronize]; 读取用户偏好设置 // 读取用户偏好设置 NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; self.one.on = [defaults boolForKey:@one]; self.two.on = [defaults boolForKey:@two]; 但是要注意的是，userDefault支持的类型有限，无法直接归档自定义类型，只能是NSData、NSString、NSNumber、NSDate、NSArray、NSDictionary，所以如果你要归档自定义类型，要先转换成前面的类型才行。 NSKeyedArchiver归档(NSCoding) 只有遵守了NSCoding协议的类才可以用NSKeyedArchiver归档和NSKeyedUnarchiver解档，但如果如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型就不需要了。 下面举的是归档解档一个Account模型 实现encodeWithCoder和initWithCoder方法 @implementation Account - (void)encodeWithCoder:(NSCoder *)encoder {  [encoder encodeObject:_accessToken forKey:@accessToken];  [encoder encodeObject:[NSString stringWithFormat:@%d, _userID] forKey:@user_id]; } - (id)initWithCoder:(NSCoder *)decoder {  if (self = [super init]) {  self.accessToken = [decoder decodeObjectForKey:@accessToken];  self.userID = [[decoder decodeObjectForKey:@user_id] intValue];  }  return self; } @end 归档 _account = [[Account alloc] init]; _account.accessToken = @123456789; _account.userID = 1; [NSKeyedArchiver archiveRootObject:account toFile:kFilePath]; 解档 _account = [NSKeyedUnarchiver unarchiveObjectWithFile:kFilePath]; UserDefault和KeyArchive结合 归档 - (void)saveAccount:(Account *)account { _account = account; NSData *data = [NSKeyedArchiver archivedDataWithRootObject:account]; NSUserDefaults *user = [NSUserDefaults standardUserDefaults]; [user setObject:data forKey:@kAccount]; } 解档 NSUserDefaults *user = [NSUserDefaults standardUserDefaults]; NSData *data = [user objectForKey:@kAccount]; _account = [NSKeyedUnarchiver unarchiveObjectWithData:data]; 嗯，是的，好吧 没有任何优点，反正就是能用userdefault存储了。。。。 参考博文：iOS开发中本地数据存储的总结 ",
      "url"      : "https://pfcstyle.github.io/2016/06/09/iOS-Project-Sumary1/",
      "keywords" : "[&quot;iOS&quot;, &quot;OC&quot;, &quot;本地持久化&quot;, &quot;plist&quot;, &quot;Preference&quot;, &quot;NSKeyedArchiver&quot;, &quot;sqllite&quot;, &quot;CoreData&quot;]"
    } ,
  
    {
      "title"    : "iOS项目总结(二)",
      "category" : "iOS",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； iOS开发的本地存储主要有五种形式  XML属性列表（plist)归档 Preference(偏好设置NSUserDefaults) NSKeyedArchiver归档(NSCoding) SqlLite（本地数据库） Core Data（苹果官方封装的SqlLite数据库操作接口） 上述五种本地的存储方式在我们日常编码中都非常常用，前三种已经在上篇博文iOS项目总结(一)-iOS本地持久化总结1中介绍了，今天开始说后两种SqlLite和Core Data. SqlLite（本地数据库） SQLite作为一中小型数据库，主要应用在移动端中，跟前三种保存方式相比，使用相对比较复杂一些，但如果你有数据库基础，这个其实也是小菜一碟了。下面看一下如何使用 1.添加libsqlite3.tbd依赖，并在对应的操作文件中导入#import “sqlite3.h” 2.打开数据库 - (void)openDB{  sqlite3 *db; //声明一个sqlite3数据库 这个其实要全局的 就这样写吧，大家知道就好  ///文件是否存在  NSFileManager* fileManager = [NSFileManager defaultManager];  //这里filePath是自己定义的路径，一般在沙箱的Documents里面操作，不明白沙箱的请移步我的上篇博文  NSString *dbpath=[self filePath];  //文件是否存在  BOOL success = [fileManager fileExistsAtPath:dbpath];  if (!success) {//不存在就复制过来一个  NSString *resourcePath=[[NSBundle mainBundle]resourcePath];  //复制  NSString *sourceDBPath=[resourcePath stringByAppendingPathComponent:@app.bundle/datas.sqlite];  NSError *error;  success = [fileManager copyItemAtPath:sourceDBPath toPath:dbpath error:&amp;error];  if(!success)  NSAssert1(0,@数据库附加失败！'%@'., [error localizedDescription]);  else  NSLog(@数据库附加成功:%@,dbpath);  }  //打开数据库  if (sqlite3_open([[self filePath] UTF8String], &amp;db) != SQLITE_OK) {  sqlite3_close(db);  NSAssert(0, @数据库打开失败。);  } } 3.执行sql语句 sqlite3 *db; //声明一个sqlite3数据库 这个是全局的 跟上同 //这里是模拟写了一个查找所有类型的操作 NSString *sql = @SELECT * FROM km_types; sqlite3_stmt *statement; //执行sql语句 返回成功或者失败 if (sqlite3_prepare_v2(db, [sql UTF8String], -1, &amp;statement, nil) == SQLITE_OK) {  //指针一行行下行  while (sqlite3_step(statement) == SQLITE_ROW) {  KMTypes* k= [[KMTypes alloc]init];  //按照类型取出对应字段  int type_id = (int)sqlite3_column_int(statement,0);  int parent_id = (int)sqlite3_column_int(statement,1);  char *type_title = (char *)sqlite3_column_text(statement, 2);  int type_order = (int)sqlite3_column_int(statement,3);  int topic_count=(int)sqlite3_column_int(statement,4);  //这里注意转换字符串编码  NSString *type_titleStr = [[NSString alloc] initWithUTF8String:type_title];  k.type_title = type_titleStr;  k.type_id=type_id;  k.parent_id = parent_id;  k.type_order = type_order;  k.topic_count=topic_count; [array addObject:k]; } //完成操作 sqlite3_finalize(statement); } //最后一定要关闭数据库 sqlite3_close(db) 这就是SQLite的基础操作了，其实挺简单的，但是可能数据存取，表的创建等还是有点繁琐，我们看下Core Data。 Core Data使用 Core Data实际上是对SQLite的操作封装，让我们更加易用，它完全不需要sql语句，因此，哪怕你没有数据库基础，用起来也是毫不费力。 1.添加实体和模型 首先你在创建项目的时候应该选在使用Core Data，这个就不再贴图了。如果你想在现成的项目中添加Core Data,你需要添加一下CoreData.framework的依赖，在pch文件中添加#import&lt;CoreData/CoreData.h&gt;，然后添加appdelegata的相关内容，你可以自己重新创建一个带有Core Data的工程，直接复制过来就行。最后再手动添加一个Core Data Model文件 创建Data Model文件时需要注意，文件名称要与AppDelegate.m中managedObjectModel方法中提到的文件名称相匹配，一般是你的工程名.momd 有了Data Model文件后，就可以在里面添加实体和关系，实际上就是向数据库中添加表格和建立表格之间的关联。添加实体如图所示： 每个学生有一个所在的班级，每个班级中有多个学生，因此，学生和班级之间可以建立关系。建立关系如图所示： 建立关系之后，可以切换显示的样式，以图表的方式查看实体之间的关系，如图所示： 这样就创建好了表格以及字段了，省却了sql语句。接下来自动创建数据模型类。 2.生成数据模型类 创建好实体后，可以通过添加NSManagedObject subclass文件，系统可以自动添加实体对应的数据模型类，如图所示：  3.CoreData的代码操作 介绍一下appdeldgate中自动生成的代码 - (void)applicationWillTerminate:(UIApplication *)application {  //保存数据到持久层  [self saveContext]; } - (void)saveContext {  NSError *error = nil;  NSManagedObjectContext *managedObjectContext = self.managedObjectContext;  if (managedObjectContext != nil) {  if ([managedObjectContext hasChanges] &amp;&amp; ![managedObjectContext save:&amp;error]) {   NSLog(@Unresolved error %@, %@, error, [error userInfo]);   abort();  } } } - (NSURL *)applicationDocumentsDirectory { //获取Documents的目录路径  return [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject]; } /** *被管理的数据上下文 *初始化的后，必须设置持久化存储助理 */ - (NSManagedObjectContext *)managedObjectContext {  if (__managedObjectContext != nil) {  return __managedObjectContext;  }  NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];  if (coordinator != nil) {  __managedObjectContext = [[NSManagedObjectContext alloc] init];  [__managedObjectContext setPersistentStoreCoordinator:coordinator];  }  return __managedObjectContext; } /** 被管理的数据模型 初始化必须依赖.momd文件路径，而.momd文件由.xcdatamodeld文件编译而来 */ - (NSManagedObjectModel *)managedObjectModel {  if (__managedObjectModel != nil) {  return __managedObjectModel;  }  NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@TestApp withExtension:@momd];  __managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];  return __managedObjectModel; } /** 持久化存储助理 初始化必须依赖NSManagedObjectModel，之后要指定持久化存储的数据类型，默认的是NSSQLiteStoreType，即SQLite数据库；并指定存储路径为Documents目录下，以及数据库名称 */ - (NSPersistentStoreCoordinator *)persistentStoreCoordinator {  if (__persistentStoreCoordinator != nil) {  return __persistentStoreCoordinator;  }  NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@TestApp.sqlite]; NSError *error = nil;  __persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]]; if (![__persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&amp;error]) {  NSLog(@Unresolved error %@, %@, error, [error userInfo]);  abort();  }  return __persistentStoreCoordinator; } 没有生成数据模型类的时候可以使用KVC来插入和查找 插入数据 - (void)insertCoreData {  NSManagedObjectContext *context = [self managedObjectContext]; NSManagedObject *student = [NSEntityDescription insertNewObjectForEntityForName:@Student inManagedObjectContext:context];  [student setValue:@1 forKey:@id];  [student setValue:@name A forKey:@name]; NSManagedObject *Class = [NSEntityDescription insertNewObjectForEntityForName:@Class inManagedObjectContext:context];  [Class setValue:@1 forKey:@id];  [Class setValue:@name B forKey:@name];  [Class setValue:student forKey:@student]; NSError *error;  if(![context save:&amp;error])  {  NSLog(@不能保存：%@,[error localizedDescription]);  } } 查找数据 - (void)dataFetchRequest {  NSManagedObjectContext *context = [self managedObjectContext];  NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];  NSEntityDescription *entity = [NSEntityDescription entityForName:@ContactInfo inManagedObjectContext:context];  [fetchRequest setEntity:entity];  NSError *error;  NSArray *fetchedObjects = [context executeFetchRequest:fetchRequest error:&amp;error];  for (NSManagedObject *info in fetchedObjects) {  NSLog(@name:%@, [info valueForKey:@name]);  } } 生成数据模型类之后 插入数据 - (void)insertCoreData {  NSManagedObjectContext *context = [self managedObjectContext]; Student *student = [NSEntityDescription insertNewObjectForEntityForName:@Student inManagedObjectContext:context];  student.id = 1;  student.name = @name A; Class *class = [NSEntityDescription insertNewObjectForEntityForName:@Class inManagedObjectContext:context];  class.id = 1;  class.name = @name B; class.student = student; NSError *error;  if(![context save:&amp;error])  {  NSLog(@不能保存：%@,[error localizedDescription]);  } } 查找数据也是类似，这里就不再赘述了。 参考博文： IOS 数据存储之 Core Data详解 iphone数据存储之－－ Core Data的使用（一） ",
      "url"      : "https://pfcstyle.github.io/2016/06/10/iOS-Project-Sumary2/",
      "keywords" : "[&quot;iOS&quot;, &quot;OC&quot;, &quot;本地持久化&quot;, &quot;plist&quot;, &quot;Preference&quot;, &quot;NSKeyedArchiver&quot;, &quot;sqllite&quot;, &quot;Core Data&quot;]"
    } ,
  
    {
      "title"    : "iOS项目总结(三)",
      "category" : "iOS",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 前段时间做了一个新加坡的电商项目，要求添加Google和Facebook的第三方登陆支持，我看国内介绍不多，也不够详细，在这里介绍一下。 Facebook 先说下Facebook的，我发现Facebook竟然提供了中文版的新手入门文档，所以大家也不用觉得难啃了，我在这里就简单说一下流程与我遇到的问题，大家参考上面的文档就好了(不要跟我讲翻不了墙，翻不了墙你还是不要集成了，集成了也登陆不上啊。。。)。  下载 SDK 创建 Facebook 应用 应用程序设置 添加 SDK 配置 Xcode 连接应用程序委托 添加应用事件 首先，在下载的SDK中是有一个示例工程的，所以大家如果遇到了什么解决不了的问题，可以去参考里面的示例工程。 仔细想想facebook好像没有遇到什么问题，大家按照上面来吧。如果遇到问题，可以在下面留言。如果大家只是需要集成登陆功能，只需要添加FBSDKCoreKit.framework和FBSDKLoginKit.framework即可。 Google Google没有提供中文文档，我这里详细说一下流程。 下载SDK 首先去下载Googel的最新版SDK。下载完毕了，本页面不要关闭，一会儿还有用。下载的SDK中也是包含有可以直接运行的示例工程的，大家多做参考。 添加SDK 将SDK解压，加入到你的工程中，如下图： 配置Xcode 1.添加下面这些frameworks  AddressBook.framework SafariServices.framework SystemConfiguration.framework libz.tbd 我只能说Google有点坑，libz.tbd在文档中没有提到。。。害得浪费我半天时间。所以还是使用pods好啊，可以自动帮你配置所需的依赖，但是我在使用pods的时候却无法下载Google的sdk,而且我确定我翻墙成功了，如果有朋友知道为什么，还请不吝赐教. 2.添加Objc linker flag到build setting  Other Linker Flags: $(OTHER_LDFLAGS) -ObjC  3.注册你的app到管理中心 4.下载你的app的配置文件 在刚刚下载sdk的页面往下，可以获得你的app的配置文件  那么这个config文件到底是什么的，其实它记录的是你的app的相关信息，其中最重要的是你的app的client_id和reserveclient_id. 5.添加URL scheme到你的项目 好了，至此就算是配置完毕了，接下来可以写代码来调用Google的登陆了。 Google登陆的使用 1.在appdelegate.m中导入#import &lt;GoogleSignIn/GoogleSignIn.h&gt; 2.设置GGLContext - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { NSError* configureError; [[GGLContext sharedInstance] configureWithError: &amp;configureError]; NSAssert(!configureError, @Error configuring Google services: %@, configureError); [GIDSignIn sharedInstance].delegate = self; return YES; } 3.实现回调 - (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary *)options {  return [[GIDSignIn sharedInstance] handleURL:url  sourceApplication:options[UIApplicationOpenURLOptionsSourceApplicationKey]  annotation:options[UIApplicationOpenURLOptionsAnnotationKey]]; } //如果你是使用的iOS8或者更老的版本，使用下面的 //这里比较郁闷的是facebook只是提供了老版本的接口。。。没有提供上面的代理实现 //所以我最后都是用的下面的这个 索性没有出问题 - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { return [[GIDSignIn sharedInstance] handleURL:url sourceApplication:sourceApplication annotation:annotation]; } 好的，那么问题来了，当你同时使用Google和Facebook时，如何判断是谁的回调呢？看解决方式 - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation {  if ([url.absoluteString rangeOfString:kGoogleReversedClientID].location != NSNotFound) {  //Google的回调  return [[GIDSignIn sharedInstance] handleURL:url  sourceApplication:sourceApplication  annotation:annotation];  }else{//facebook的回调  return [[FBSDKApplicationDelegate sharedInstance] application:application  openURL:url  sourceApplication:sourceApplication  annotation:annotation  ]; } } sharesdk是不是也是用的这种方式呢？难道被我猜到了？嘿嘿。 4.好了，现在到你的登陆界面，正式使用登陆按钮 //实现代理 @interface ViewController : UIViewController &lt;GIDSignInUIDelegate&gt; //在didload方法中设置代理 - (void)viewDidLoad { [super viewDidLoad]; // TODO(developer) Configure the sign-in button look/feel [GIDSignIn sharedInstance].uiDelegate = self; // 不推荐使用自动登陆 /** When users silently sign in, the Sign-In SDK automatically acquires access tokens and automatically refreshes them when necessary. If you need the access token and want the SDK to automatically handle refreshing it, you can use the getAccessTokenWithHandler: method. To explicitly refresh the access token, call the refreshAccessTokenWithHandler: method. */ //上面这段话是官网上的，大概是说如果你使用了自动登陆，你可以通过getAccessTokenWithHandler: //这个函数获取access token并且让SDK自动更新access token,如果你想要立刻更新，你可以使用 //refreshAccessTokenWithHandler: //[[GIDSignIn sharedInstance] signInSilently]; } 5.实现代理方法 //这些我就不再解释了 很好理解 // Stop the UIActivityIndicatorView animation that was started when the user // pressed the Sign In button - (void)signInWillDispatch:(GIDSignIn *)signIn error:(NSError *)error {  [myActivityIndicator stopAnimating]; } // Present a view that prompts the user to sign in with Google - (void)signIn:(GIDSignIn *)signIn  presentViewController:(UIViewController *)viewController {  [self presentViewController:viewController animated:YES completion:nil]; } // Dismiss the Sign in with Google view - (void)signIn:(GIDSignIn *)signIn  dismissViewController:(UIViewController *)viewController {  [self dismissViewControllerAnimated:YES completion:nil]; } 6.自定义button Google提供的button叫做GIDSignInButton，好吧，扯淡，把我也欺骗了，这货的父类是UIControl,当时知道真相的我眼泪掉下来（我在storyboard里翻了半天啊＝＝）。那么所谓的自定义就是设置这货的属性了。 //好吧 只有这俩属性 具体使用方式你们可以参考示例项目 // The layout style for the sign-in button. // Possible values: // - kGIDSignInButtonStyleStandard: 230 x 48 (default) // - kGIDSignInButtonStyleWide:  312 x 48 // - kGIDSignInButtonStyleIconOnly: 48 x 48 (no text, fixed size) @property(nonatomic, assign) GIDSignInButtonStyle style; // The color scheme for the sign-in button. // Possible values: // - kGIDSignInButtonColorSchemeDark // - kGIDSignInButtonColorSchemeLight (default) @property(nonatomic, assign) GIDSignInButtonColorScheme colorScheme; 当然，我是一直坚信没有无法自定义的view的，请移步iOS一些小技巧及小知识点总结。 PS：后来我发现Google的登录按钮其实可以使用自己的按钮，你只需要在按钮事件中添加[[GIDSignIn sharedInstance] signIn]即可，当然，其他的代理仍然是需要实现的。 ",
      "url"      : "https://pfcstyle.github.io/2016/06/11/iOS-Project-Sumary3/",
      "keywords" : "[&quot;iOS&quot;, &quot;OC&quot;, &quot;第三方登陆&quot;, &quot;Google&quot;, &quot;Facebook&quot;, &quot;SDK&quot;]"
    } ,
  
    {
      "title"    : "iOS项目总结(四)",
      "category" : "iOS",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 今天在应用里添加一个异常捕获类，以方便测试人员在没有xcode的情况下也可以直接看到错误日志。先说一下原理： Signal是什么 iOS SDK中提供了一个现成的函数 NSSetUncaughtExceptionHandler 用来做异常处理，但功能非常有限，而引起崩溃的大多数原因如：内存访问错误，重复释放等错误就无能为力了。因为这种错误它抛出的是Signal，所以必须要专门做Signal处理。 在计算机科学中， 信号 （ 英语： Signals）是Unix、类Unix以及其他POSIX兼容的操作系统中进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。 信号处理函数可以通过 signal() 系统调用来设置。如果没有为一个信号设置对应的处理函数，就会使用默认的处理函数，否则信号就被进程截获并调用相应的处理函数。在没有处理函数的情况下，程序可以指定两种行为：忽略这个信号 SIG_IGN 或者用默认的处理函数 SIG_DFL 。但是有两个信号是无法被截获并处理的： SIGKILL、SIGSTOP 。 信号的类型 SIGABRT–程序中止命令中止信号 SIGALRM–程序超时信号 SIGFPE–程序浮点异常信号 SIGILL–程序非法指令信号 SIGHUP–程序终端中止信号 SIGINT–程序键盘中断信号 SIGKILL–程序结束接收中止信号 SIGTERM–程序kill中止信号 SIGSTOP–程序键盘中止信号 SIGSEGV–程序无效内存中止信号 SIGBUS–程序内存字节未对齐中止信号 SIGPIPE–程序Socket发送失败中止信号 如何实现 废话不多说了，直接上代码，不懂的看注释就可以了。 //UncaughtExceptionHandl.h #import &lt;UIKit/UIKit.h&gt; @interface UncaughtExceptionHandl : NSObject{  tBOOL dismissed; } @end void HandleException(NSException *exception); void SignalHandler(int signal); void InstallUncaughtExceptionHandler(void); //UncaughtExceptionHandl.m #import UncaughtExceptionHandl.h #include &lt;libkern/OSAtomic.h&gt; #include &lt;execinfo.h&gt; #import AppDelegate.h NSString * const UncaughtExceptionHandlerSignalExceptionName = @UncaughtExceptionHandlerSignalExceptionName; NSString * const UncaughtExceptionHandlerSignalKey = @UncaughtExceptionHandlerSignalKey; NSString * const UncaughtExceptionHandlerAddressesKey = @UncaughtExceptionHandlerAddressesKey; //当前处理的异常个数 volatile int32_t UncaughtExceptionCount = 0; //能够处理的最大异常个数 const int32_t UncaughtExceptionMaximum = 10; const NSInteger UncaughtExceptionHandlerSkipAddressCount = 4; const NSInteger UncaughtExceptionHandlerReportAddressCount = 5; @interface UncaughtExceptionHandl() //计时器 @property (strong, nonatomic) NSTimer *countDurTimer; @end @implementation UncaughtExceptionHandl + (NSArray *)backtrace {  void* callstack[128];  int frames = backtrace(callstack, 128);  char **strs = backtrace_symbols(callstack, frames);  int i;  NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];  for (  i = UncaughtExceptionHandlerSkipAddressCount;  i &lt; UncaughtExceptionHandlerSkipAddressCount +  UncaughtExceptionHandlerReportAddressCount;  i++)  {  [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];  }  free(strs);  return backtrace; } - (void)alertView:(UIAlertView *)anAlertView clickedButtonAtIndex:(NSInteger)anIndex {  if (anIndex == 0)  {  dismissed = YES;  }else{  dismissed = YES;  AppDelegate *app = [[UIApplication sharedApplication] delegate];  app.mainViewController = [[MainTabBarController alloc] init];  app.window.rootViewController = app.mainViewController;  [app.mainViewController exchangeTabbarHightFromSetSystemTextFont:nil];  } } - (void)validateAndSaveCriticalApplicationData { } //捕获信号后的回调函数 由HandleException调用 - (void)handleException:(NSException *)exception {  [self validateAndSaveCriticalApplicationData];  NSString *reason = [exception reason];  NSString *name = [exception name];  UIAlertView *alert =  [[[UIAlertView alloc]  initWithTitle:@tip  message:[NSString stringWithFormat:@CRASH: %@ name:%@,  Reason: %@,  Stack Trace: %@,  ,exception,name,reason,[exception callStackSymbols]]  delegate:self  cancelButtonTitle:NSLocalizedString(@Quit, nil)  otherButtonTitles:NSLocalizedString(@Continue, nil), nil] autorelease];  [alert show];  //或者直接用代码，输入这个崩溃信息，以便在console中进一步分析错误原因  //当接收到异常处理消息是，让程序开始runloop，防止程序死亡  CFRunLoopRef runLoop = CFRunLoopGetCurrent();  CFArrayRef allModes = CFRunLoopCopyAllModes(runLoop);  while (!dismissed)  {  for (NSString *mode in (NSArray *)allModes)  {   CFRunLoopRunInMode((CFStringRef)mode, 0.001, false);  }  }  CFRelease(allModes);  NSSetUncaughtExceptionHandler(NULL);  signal(SIGABRT, SIG_DFL);  signal(SIGILL, SIG_DFL);  signal(SIGSEGV, SIG_DFL);  signal(SIGFPE, SIG_DFL);  signal(SIGBUS, SIG_DFL);  signal(SIGPIPE, SIG_DFL);  if ([[exception name] isEqual:UncaughtExceptionHandlerSignalExceptionName])  {  kill(getpid(), [[[exception userInfo] objectForKey:UncaughtExceptionHandlerSignalKey] intValue]);  }  else  {  [exception raise];  } } @end //捕获信号后的回调函数 void HandleException(NSException *exception) {  int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount);  if (exceptionCount &gt; UncaughtExceptionMaximum)  {  return;  } NSArray *callStack = [UncaughtExceptionHandl backtrace];  NSMutableDictionary *userInfo =  [NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];  [userInfo  setObject:callStack  forKey:UncaughtExceptionHandlerAddressesKey]; [[[[UncaughtExceptionHandl alloc] init] autorelease]  performSelectorOnMainThread:@selector(handleException:)  withObject:   [NSException    exceptionWithName:[exception name]    reason:[exception reason]    userInfo:userInfo]  waitUntilDone:YES]; } void SignalHandler(int signal) {  int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount);  if (exceptionCount &gt; UncaughtExceptionMaximum)  {  return;  }  NSMutableDictionary *userInfo =  [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];  NSArray *callStack = [UncaughtExceptionHandl backtrace];  [userInfo setObject:callStack forKey:UncaughtExceptionHandlerAddressesKey];  [[[[UncaughtExceptionHandl alloc] init] autorelease] performSelectorOnMainThread:@selector(handleException:) withObject: [NSException  exceptionWithName:UncaughtExceptionHandlerSignalExceptionName  reason:  [NSString stringWithFormat:  NSLocalizedString(@Signal %d was raised., nil),  signal]  userInfo:  [NSDictionary  dictionaryWithObject:[NSNumber numberWithInt:signal]  forKey:UncaughtExceptionHandlerSignalKey]] waitUntilDone:YES]; } //SIGABRT--程序中止命令中止信号 //SIGALRM--程序超时信号 //SIGFPE--程序浮点异常信号 //SIGILL--程序非法指令信号 //SIGHUP--程序终端中止信号 //SIGINT--程序键盘中断信号 //SIGKILL--程序结束接收中止信号 //SIGTERM--程序kill中止信号 //SIGSTOP--程序键盘中止信号 //SIGSEGV--程序无效内存中止信号 //SIGBUS--程序内存字节未对齐中止信号 //SIGPIPE--程序Socket发送失败中止信号 void InstallUncaughtExceptionHandler(void) {  NSSetUncaughtExceptionHandler(&amp;HandleException);  signal(SIGABRT, SignalHandler);  signal(SIGILL, SignalHandler);  signal(SIGSEGV, SignalHandler);  signal(SIGFPE, SignalHandler);  signal(SIGBUS, SignalHandler);  signal(SIGPIPE, SignalHandler); } 使用方法：直接在你的appdelegate的didfinishlaunch函数中添加 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { ... InstallUncaughtExceptionHandler(); ... return YES; } 注意，这里由于使用了C++的库，所以，如果你是纯OC应用，你的buil settings中应该默认配置是这样的： 那么，你很幸运，什么也不需要调整，直接用就好了。 但是，如果你混编的，而且不得不使用libstdc++,就是build settings中是这样的： 请你记得将UncaughtExceptionHandl.m改为UncaughtExceptionHandl.mm，否则会报Undefined symbols for architecture arm64错误，这本该是常识的，但是当你刚刚接触一个新项目，可能还没有反应过来，往往会浪费很多时间，找错方向。 ",
      "url"      : "https://pfcstyle.github.io/2016/06/18/iOS-Project-Sumary4/",
      "keywords" : "[&quot;iOS&quot;, &quot;OC&quot;, &quot;signal&quot;, &quot;runloop&quot;, &quot;exception&quot;]"
    } ,
  
    {
      "title"    : "iOS项目总结(五)",
      "category" : "iOS",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 在做项目的时候，经常会遇到duplicate symbols for architecture armvxx, Undefined symbols for architecture armxx等的问题，尤其是在添加第三方库的时候，给人一种措手不及的感觉。今天我将总结一下为什么会出现这样的问题，以及如何解决。 armxx这些都是什么？ 这些其实都是iOS设备的指令集，每一种指令集其实都是对应一类处理器硬件，这些所谓的指令，其实就是汇编指令，只是不同指令集会略有不同，导致各个指令集无法完全兼容，相互混用。但是，一般来说，这些指令集是自上而下能够完整兼容的。下面是指令集的介绍： armv6 – iPhone – iPhone2 – iPhone3G – 第一代和第二代iPod Touch armv7 – iPhone4 – iPhone4S armv7s – iPhone5 – iPhone5C – arm64 – iPhone5S Xcode的相关配置 在build settings中的第一个配置项就是arm相关的，解释如下： Architecture ： 指你想支持的指令集。 Valid architectures : 指即将编译的指令集。 Build Active Architecture Only : 只是否只编译当前适用的指令集。 只有在目标设备上，才会执行设备对应的指令集。 如果在工程Build Setting的Architectures 中的“Build Active Architecture Only”选择为YES，则即使你设置成armv7 , armv7s同时支持，也只会编译对应指令集的包；若选择NO，则编译器会整合两个指令集到一起，此时的包比较大，但是能在iPhone5上使用armv7s的优化，同时也能适配老的设备。一般都是Debug时“Build Active Architecture Only”选择YES，用当前的架构看代码逻辑是否有问题；而在Release时选择NO，来适配不同的设备。 此外，模拟器并不运行arm代码，软件会被编译成x86可以运行的指令。所以生成静态库时都是会先生成两个.a，一个是i386的用于在模拟器运行，另一个是在真实设备上运行的，然后再用命令将两个.a合并成一个。 可能出现的问题 那么，可能出现的问题及原因也就很容易明白了。  Undefined symbols for architecture arm64 1.你的静态库不支持arm64,但是你的工程支持ram64。  t这样你只能选择替换支持arm64的静态库了，因为现在苹果上架也是要求必须支持64位，所以你没得选择。 2.OC与C++混编的时候，调用C++的OC类的实现文件没有更改后缀名为.mm 更多可能与解决方案  duplicate symbols for architecture armv64 1.文件名重复 2.检查是否在#import头文件的时候，不小心把.h写成了.m。 3.build settings中，other linker flags 设置的重复，比如同时包含 -all_load和-ObjC，将-all_load删去即可 注意，这里第三种解决方式并不完美，这样做的话，会使一些外部的静态库，使用objc扩展函数(catagory)的方法失效。例如BaiduMapApi。 如果是有些库使用到了扩展函数(catagory)可以分别对这个库进行加载 使用：-force_load -force_load BaiduMapApi/libs/Release-iphoneos/libbaidumapapi.a (BaiduMapApi是添加到当前目录下的) 或 -force_load $(BUILT_PRODUCTS_DIR)/libxxx.a (这里是直接添加静态库项目源码的做法) 参考博客： armv6, armv7, armv7s的区别 duplicate symbols for architecture armv7解决办法 iOS解决两个静态库的冲突 duplicate symbol ",
      "url"      : "https://pfcstyle.github.io/2016/06/19/iOS-Project-Sumary5/",
      "keywords" : "[&quot;iOS&quot;, &quot;OC&quot;, &quot;architectures&quot;]"
    } ,
  
    {
      "title"    : "iOS项目总结(六)",
      "category" : "iOS",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 今天项目提交app store被拒了，总结一下原因。邮件说的原因很明白：  invalid Swift Support - The SwiftSupport folder is missing. Rebuild your app using the current public (GM) version of Xcode and resubmit it. 这里先总结一下OC项目使用swift代码如何配置：  导入swift文件，xcode会自动提示生成一个oc桥接头文件，点击创建，会自动创建一个项目名-Bridging-Header.h 使用时直接引入这个头文件即可，可以像OC一样直接调用swift函数。 在buildsettings中，设置EMBEDDED_CONTENT_CONTAINS_SWIFT = yes 一般来说，设置好上述的3点，使用以及到最后打包都不会有问题了，但是我们还就是出了问题，总结一下。  archive之后export时选择Export as an Xcode Archive就会在archive包中自动包含swiftsupport文件夹，上面说这个文件夹miss了，就是因为我们选择了Save Build Products(我们的问题有点傻，因为第一次提交吗，也算是提醒一下新手吧。当然，如果你们是使用脚本打的包，也会出现类似的问题，手动放进去即可。)  swiftsupport中不可以包含libswiftXCTest.dylib，这是app store不允许的，因此，你应该确保你的swiftsupport中没有这个东西。如果有的话，参考下面的解决方案：   Open your Xcode project  Select Product &gt; Scheme &gt; Edit Scheme  Click Build in the left sidebar  For your test target, uncheck the  tArchive checkbox  Click the Close button  Select Product &gt; Archive  Submit the latest archive to the App  tStore   ",
      "url"      : "https://pfcstyle.github.io/2016/06/23/iOS-Project-Sumary6/",
      "keywords" : "[&quot;iOS&quot;, &quot;OC&quot;, &quot;app store&quot;, &quot;swiftsupport&quot;]"
    } ,
  
    {
      "title"    : "iOS项目总结(七)",
      "category" : "iOS",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； iOS提交应用至App Store流程 最快让你上手ReactiveCocoa之基础篇 FMDB 使用方法 关于Xcode打包为Generic Xcode Archive 以及 Xcode打包按钮灰色的解决方法 git 创建分支提交远程分支 Restoration Classes and UIWebViews(保存webview的状态) ",
      "url"      : "https://pfcstyle.github.io/2016/06/24/iOS-Project-Sumary7/",
      "keywords" : "[&quot;iOS&quot;, &quot;OC&quot;, &quot;archive&quot;, &quot;swiftsupport&quot;, &quot;app store&quot;, &quot;reactivecocoa&quot;, &quot;fmdb&quot;]"
    } ,
  
    {
      "title"    : "iOS项目总结(八)",
      "category" : "iOS",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 今天被分了一个bug,说是iphone4s上的启动画面黑屏，本来想着应该是小菜一碟，因为凭本大侠的水平，怎么可能会搞不定一个静态的启动画面，结果，一整天就这样过去了==！不过好在在下班前1小时搞定了，来做一下总结，日了狗~ 我的问题 首先说我的问题，非常的amazing。我们的应用是要求同时支持横竖屏的，但是刚开始我们只要求支持横屏，后来又不得不添加竖屏。配置就是我们在target&gt;general&gt;device orientation中又多勾选了一个竖屏(当然，同时支持横竖屏只打个勾是远远不够的，需要你精确控制，这个网上很多，跟本文无关)，然后，打印4s的屏幕尺寸，你会发现这货是横屏的尺寸，因此，根本无法显示启动图(配置的启动图里没有4s的横屏)。解决方式很简单，把device orientation全取消，按顺序，先选择Portrait,然后选择Landscape Left和Landscape Right,记住，顺序很重要！！！你会发现你的启动图出来了！！（从这也可以看出来，苹果的配置文件大部分是字典存储，但是遇到这种多选的，显然是按照队列的方式进行存取的，默认是选择第一个选项） 启动画面的适配总结 iOS7之前(use asset catalog) iOS8之前我们使用use asset catalog，什么意思呢，简单来说就是最传统的UI做了一堆不同屏幕的图，然后按照苹果官方命名好，添加到你的资源文件夹中，然后Xcode里这样配置： 那么你启动的时候，就会发现启动界面已经弄好了。但是现在不能用了，因为你会发现，当你在plus运行的时候，你的界面整体放大了！所以，现在这种方式一般是和Launch Screen.xib或者Launch Screen.storyboard 一起使用，下面说。 iOS7以后(xib或者storyboard 与 use asset catalog一起(兼容iOS7以下)) 如果你需要兼容iOS7以下，那么你还需要把上述的也弄一下，去适配相应的硬件。但是如果你不需要，那么你只需要使用Launch Screen.storyboard 或者 Lauch Screen.xib即可，使用autolayout和sizeclass来进行约束适配即可。配置如下： 都可以使用的(images.xcassts的launch images) 我们项目就是使用本方式，在images.xcassts中右键选择App Icons &amp; Launch Images&gt;new iOS launch image新建Launch Images,创建好了效果如下： 在右侧选择你需要适配的所有系统版本，然后填充上对应大小的启动界面即可。注意我的上述问题。 其他问题总结(针对方式3) 在我解决我的问题的时候，也是走了不少弯路，总结一下其他可能问题。 1.png图的格式问题 判断方法：打开图片(双击，默认就是使用preview.app打开的),ctrl+i，查看信息，如果你的图片有问题，是这样的： 没有问题的： 有问题就重换喽。 2.Launch Screen File没有置空 ",
      "url"      : "https://pfcstyle.github.io/2016/06/28/iOS-Project-Sumary8/",
      "keywords" : "[&quot;iOS&quot;, &quot;Xcode&quot;, &quot;LaunchScreen&quot;, &quot;launchimage&quot;, &quot;启动界面适配&quot;, &quot;Black Screen&quot;]"
    } ,
  
    {
      "title"    : "iOS项目总结(九)",
      "category" : "iOS",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 苹果官方提供了Reachbility可以直接用来判断网络状态，这里分析一下。 Reachability主要使用的是&lt;SystemConfiguration/SystemConfiguration.h&gt;，所以你在使用的时候应该添加SystemConfiguration.framework文件依赖。我们倒着分析： //很明显这里是作为一个回调函数，其功能是在网络状态发生变化的时候就发出通知 static void ReachabilityCallback(SCNetworkReachabilityRef target, SCNetworkReachabilityFlags flags, void* info) { #pragma unused (target, flags)  tNSCAssert(info != NULL, @info was NULL in ReachabilityCallback);  tNSCAssert([(__bridge NSObject*) info isKindOfClass: [Reachability class]], @info was wrong class in ReachabilityCallback); Reachability* noteObject = (__bridge Reachability *)info;  // Post a notification to notify the client that the network reachability changed.  [[NSNotificationCenter defaultCenter] postNotificationName: kReachabilityChangedNotification object: noteObject]; } 接下来我们按图索骥，找到这个回调是在哪里执行。 //这里是开始通知的函数，可以看到，上面的回调就是在这里设置的 - (BOOL)startNotifier {  tBOOL returnValue = NO;  tSCNetworkReachabilityContext context = {0, (__bridge void *)(self), NULL, NULL, NULL}; //第一个参数是主机地址的句柄，用于监听主机状态 //第二个参数就是回调了  tif (SCNetworkReachabilitySetCallback(_reachabilityRef, ReachabilityCallback, &amp;context))  t{  t//使监听在mainrunloop中运行 异步  t tif (SCNetworkReachabilityScheduleWithRunLoop(_reachabilityRef, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode))  t t{  t t treturnValue = YES;  t t}  t}  treturn returnValue; } 好了，流程就是这么简单，我们再看一下初始化 + (instancetype)reachabilityWithHostName:(NSString *)hostName {  tReachability* returnValue = NULL;  t//这里是创建主机地址的操作句柄，第一个参数是分配器，null表示使用默认，第二个参数就是主机地址了  tSCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(NULL, [hostName UTF8String]);  tif (reachability != NULL)  t{  t treturnValue= [[self alloc] init];  t tif (returnValue != NULL)  t t{  t t treturnValue-&gt;_reachabilityRef = reachability;  t t treturnValue-&gt;_alwaysReturnLocalWiFiStatus = NO;  t t}  t}  treturn returnValue; } 调用当前状态 //这里主要是分析flag的去向 - (NetworkStatus)currentReachabilityStatus {  tNSAssert(_reachabilityRef != NULL, @currentNetworkStatus called with NULL SCNetworkReachabilityRef);  tNetworkStatus returnValue = NotReachable;  tSCNetworkReachabilityFlags flags;  tif (SCNetworkReachabilityGetFlags(_reachabilityRef, &amp;flags))  t{  t tif (_alwaysReturnLocalWiFiStatus)  t t{  t t treturnValue = [self localWiFiStatusForFlags:flags];  t t}  t telse  t t{  t t treturnValue = [self networkStatusForFlags:flags];  t t}  t}  treturn returnValue; } flag的去向，我们找一个讲解 //可以看到，这里都是与kSCNetworkReachabilityFlags进行与操作，判断是否是对应状态。 - (NetworkStatus)localWiFiStatusForFlags:(SCNetworkReachabilityFlags)flags {  tPrintReachabilityFlags(flags, localWiFiStatusForFlags);  tNetworkStatus returnValue = NotReachable;  tif ((flags &amp; kSCNetworkReachabilityFlagsReachable) &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsIsDirect))  t{  t treturnValue = ReachableViaWiFi;  t}  treturn returnValue; } ",
      "url"      : "https://pfcstyle.github.io/2016/07/04/iOS-Project-Sumary9/",
      "keywords" : "[&quot;iOS&quot;, &quot;网络状态监听&quot;, &quot;Reachability&quot;, &quot;NetWork&quot;]"
    } ,
  
    {
      "title"    : "H.264 NAL层解析(0x00000001,编码,打包,NALU)【转】",
      "category" : "Media",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 引言 H.264的主要目标： 1．高的视频压缩比 2．良好的网络亲和性 解决方案： VCL video codinglayer  视频编码层 NAL network abstraction layer 网络提取层 VCL：核心算法引擎，块，宏块及片的语法级别的定义 NAL：片级以上的语法级别（如序列参数集和图像参数集），同时支持以下功能：独立片解码，起始码唯一保证，SEI以及流格式编码数据传送 VCL设计目标：尽可能地独立于网络的情况下进行高效的编解码 NAL设计目标：根据不同的网络把数据打包成相应的格式，将VCL产生的比特字符串适配到各种各样的网络和多元环境中。 NALU头结构：NALU类型(5bit)、重要性指示位(2bit)、禁止位(1bit)。 NALU类型：1～12由H.264使用，24～31由H.264以外的应用使用。 重要性指示：标志该NAL单元用于重建时的重要性，值越大，越重要。 禁止位：网络发现NAL单元有比特错误时可设置该比特为1，以便接收方丢掉该单元。 NAL语法语义 NAL层句法： 在编码器输出的码流中，数据的基本单元是句法元素。 句法表征句法元素的组织结构。 语义阐述句法元素的具体含义。 分组都有头部，解码器可以很方便的检测出NAL的分界，依次取出NAL进行解码。 但为了节省码流，H.264没有另外在NAL的头部设立表示起始位置的句法元素。 如果编码数据是存储在介质上的，由于AL是依次紧密相连的，解码器就无法在数据流中分辨出每个NAL的起始位置和终止位置。 解决方案：在每个NAL前添加起始码：0X000001 在某些类型的介质上，为了寻址的方便，要求数据流在长度上对齐，或某个常数的整数倍。所以在起始码前添加若干字节的0来填充。 检测NAL的开始： 0X000001和0X00000001 我们必须考虑当NAL内部出现了0X000001和0X000000 如果NALU对应的Slice为一帧的开始，则用4字节表示，即0x00000001；否则用3字节表示，0x000001。 解决方案：为了防止NAL内部出现0x000001的数据，h.264又提出’防止竞争 emulation prevention”机制.在编码完一个NAL时，如果检测出有连续两个0x00字节，就在后面插入一个0x03，则在NAL数据内肯定不会存在NAL起始码0x000001。当解码器在NAL内部检测到0x000003的数据，就把0x03抛弃，恢复原始数据。 0x000000  »»» 0x00000300(结束码) 0x000001 »»» 0x00000301(起始码) 0x000002 »»» 0x00000302(保留) 0x000003 »»» 0x00000303(保证解码器正常工作) H.264提出了“防止竞争”机制： 0X000000——0X00000300 0X000001——0X00000301 0X000002——0X00000302 0X000003——0X00000303 为此，我们可以知道： 在NAL单元中，下面的三字节序列不应在任何字节对齐的位置出现 0X000000 0X000001 0X000002 Forbidden_zero_bit=0; Nal_ref_idc：表示NAL的优先级。0～3，取值越大，表示当前NAL越重要，需要优先受到保护。如果当前NAL是属于参考帧的片，或是序列参数集，或是图像参数集这些重要的单位时，本句法元素必需大于0。 Nal_unit_type：当前NAL 单元的类型 标识NAL单元中的RBSP数据类型，其中，nal_unit_type为1， 2， 3， 4， 5的NAL单元称为VCL的NAL单元，其他类型的NAL单元为非VCL的NAL单元。 § 0：未规定 § 1：非IDR图像中不采用数据划分的片段 § 2：非IDR图像中A类数据划分片段 § 3：非IDR图像中B类数据划分片段 § 4：非IDR图像中C类数据划分片段 § 5：IDR图像的片段 § 6：补充增强信息（SEI） § 7：序列参数集（SPS） § 8：图像参数集（PPS） § 9：分割符 § 10：序列结束符 § 11：流结束符 § 12：填充数据 § 13：序列参数集扩展 § 14：带前缀的NAL单元 § 15：子序列参数集 § 16 –18：保留 § 19：不采用数据划分的辅助编码图像片段 § 20：编码片段扩展 § 21 –23：保留 § 24 –31：未规定 H.264的NAL层处理 结构示意图： NAL以NALU（NAL unit）为单元来支持编码数据在基于分组交换技术网络中传输。它定义了符合传输层或存储介质要求的数据格式，同时给出头信息，从而提供了视频编码和外部世界的接口。 NALU：定义了可用于基于分组和基于比特流系统的基本格式 RTP封装：只针对基于NAL单元的本地NAL接口。 三种不同的数据形式： SODB　数据比特串－－＞最原始的编码数据 （raw） RBSP　原始字节序列载荷－－＞在SODB的后面填加了结尾比特（RBSP trailing bits一个bit“1”）若干比特“0”,以便字节对齐 EBSP　扩展字节序列载荷–&gt;在RBSP基础上填加了仿校验字节（0X03）它的原因是：　在NALU加到Annexb上时，需要添加每组NALU之前的开始码StartCodePrefix,如果该NALU对应的slice为一帧的开始则用4位字节表示，0x00000001,否则用3位字节表示0x000001.为了使NALU主体中不包括与开始码相冲突的，在编码时，每遇到两个字节连续为0，就插入一个字节的0x03。解码时将0x03去掉。也称为脱壳操作 处理过程： 1．将VCL层输出的SODB封装成nal_unit， Nal_unit是一个通用封装格式，可以适用于有序字节流方式和IP包交换方式。    2．针对不同的传送网络（电路交换  包交换），将nal_unit 封装成针对不同网络的封装格式。   第一步的具体过程： VCL层输出的比特流SODB（String OfData Bits），到nal_unit之间，经过了以下三步处理： 1.SODB字节对齐处理后封装成RBSP（RawByte Sequence Payload）。 2.为防止RBSP的字节流与有序字节流传送方式下的SCP（start_code_prefix_one_3bytes，0x000001）出现字节竞争情形，循环检测RBSP前三个字节，在出现字节竞争时在第三字节前加入emulation_prevention_three_byte（0x03） 具体方法： nal_unit( NumBytesInNALunit ) { forbidden_zero_bit nal_ref_idc nal_unit_type NumBytesInRBSP = 0 for( i = 1; i &lt; NumBytesInNALunit;i++ ) { if( i + 2 &lt; NumBytesInNALunit&amp;&amp; next_bits( 24 ) = = 0x000003 ) { rbsp_byte[ NumBytesInRBSP++ ] rbsp_byte[ NumBytesInRBSP++ ] i += 2 emulation_prevention_three_byte /*equal to 0x03 */ } else rbsp_byte[ NumBytesInRBSP++ ] } }  防字节竞争处理后的RBSP再加一个字节的header(forbidden_zero_bit+ nal_ref_idc+ nal_unit_type)，封装成nal_unit. 第二步的具体过程： case1：有序字节流的封装 byte_stream_nal_unit( NumBytesInNALunit ) { while( next_bits( 24 ) != 0x000001 ) zero_byte /* equal to 0x00 */ if( more_data_in_byte_stream( ) ) { start_code_prefix_one_3bytes /* equal to 0x000001 */nal_unit( NumBytesInNALunit ) } } 类似H.320和MPEG-2/H.222.0等传输系统，传输NAL作为有序连续字节或比特流，同时要依靠数据本身识别NAL单元边界。在这样的应用系统中，H.264/AVC规范定义了字节流格式，每个NAL单元前面增加3个字节的前缀，即同步字节。在比特流应用中，每个图像需要增加一个附加字节作为边界定位。还有一种可选特性，在字节流中增加附加数据，用做扩充发送数据量，能实现快速边界定位，恢复同步 Case2：IP网络的RTP打包封装 分组打包的规则 (1)额外开销要少，使MTU尺寸在100～64k字节范围都可以； (2)不用对分组内的数据解码就可以判别该分组的重要性； (3)载荷规范应当保证不用解码就可识别由于其他的比特丢失而造成的分组不可解码； (4)支持将NALU分割成多个RTP分组； (5)支持将多个NALU汇集在一个RTP分组中。 RTP的头标可以是NALU的头标，并可以实现以上的打包规则。 一个RTP分组里放入一个NALU，将NALU(包括同时作为载荷头标的NALU头)放入RTP的载荷中，设置RTP头标值。为了避免IP层对大分组的再一次分割，片分组的大小一般都要小于MTU尺寸。由于包传送的路径不同，解码端要重新对片分组排序，RTP包含的次序信息可以用来解决这一问题。 NALU分割 对于预先已经编码的内容，NALU可能大于MTU尺寸的限制。虽然IP层的分割可以使数据块小于64千字节，但无法在应用层实现保护，从而降低了非等重保护方案的效果。由于UDP数据包小于64千字节，而且一个片的长度对某些应用场合来说太小，所以应用层打包是RTP打包方案的一部分。 新的讨论方案(IETF)应当符合以下特征： (1)NALU的分块以按RTP次序号升序传输； (2)能够标记第一个和最后一个NALU分块； (3)可以检测丢失的分块。 NALU合并 一些NALU如SEI、参数集等非常小，将它们合并在一起有利于减少头标开销。已有两种集合分组： (1)单一时间集合分组(STAP)，按时间戳进行组合； (2)多时间集合分组(MTAP)，不同时间戳也可以组合。 NAL规范视频数据的格式，主要是提供头部信息，以适合各种媒体的传输和存储。NAL支持各种网络，包括： 1．任何使用RTP/IP协议的实时有线和无线Internet 服务 2．作为MP4文件存储和多媒体信息文件服务 3．MPEG-2系统 4．其它网 NAL规定一种通用的格式，既适合面向包传输，也适合流传送。实际上，包传输和流传输的方式是相同的，不同之处是传输前面增加了一个起始码前缀 在类似Internet/RTP面向包传送协议系统中，包结构中包含包边界识别字节，在这种情况下，不需要同步字节。 NAL单元分为VCL和非VCL两种 VCL NAL单元包含视频图像采样信息， 非VCL包含各种有关的附加信息，例如参数集（头部信息，应用到大量的VCL NAL单元）、提高性能的附加信息、定时信息等 参数集： 参数集是很少变化的信息，用于大量VCL NAL单元的解码，分为两种类型： 1．序列参数集，作用于一串连续的视频图像，即视频序列。两个IDR图像之间为序列参数集。IDR和I帧的区别见下面。 2．图像参数集，作用于视频序列中的一个或多个个别的图像序列和图像参数集机制，减少了重复参数的传送，每个VCL NAL单元包含一个标识，指向有关的图像参数集，每个图像参数集包含一个标识，指向有关的序列参数集的内容因此，只用少数的指针信息，引用大量的参数，大大减少每个VCL NAL单元重复传送的信息。 序列和图像参数集可以在发送VCL NAL单元以前发送，并且重复传送，大大提高纠错能力。序列和图像参数集可以在“带内”，也可以用更为可靠的其他“带外”通道传送。 存储单元： 一组指定格式的NAL单元称为存储单元，每个存储单元对应一个图像。每个存储单元包含一组VCL NAL单元，组成一个主编码图像，VCL NAL单元由表示视频图像采样的像条所组成。存储单元前面可以加一个前缀，分界存储单元，附加增强信息（SEI）（如图像定时信息）也可以放在主编码图像的前面。主编码图像后附加的VCL NAL单元，包含同一图像的冗余表示，称为冗余编码图像，当主编码图像数据丢失或损坏时，可用冗余编码图像解码。 编码视频序列: 一个编码视频序列由一串连续的存储单元组成，使用同一序列参数集。每个视频序列可独立解码。编码序列的开始是即时刷新存储单元（IDR）。IDR是一个I帧图像，表示后面的图像不用参考以前的图像。一个NAL单元流可包含一个或更多的编码视频序列。 I帧和IDR帧的区别： 1．在 H.264 中 I 帧并不具有随机访问的能力，这个功能由 IDR 承担。以前的标准中由 I 帧承担。 2．IDR 会导致 DPB （参考帧列表——这是关键所在）清空，而 I 不会。 3．I和IDR帧其实都是I帧,都是使用帧内预测的。但是IDR帧的作用是立刻刷新,使错误不致传播,从IDR帧开始,重新算一个新的序列开始编码。 4．IDR图像一定是I图像，但I图像不一定是IDR图像。一个序列中可以有很多的I图像，I图像之后的图像可以引用I图像之间的图像做运动参考。 关于h264拆包，按照FU-A方式说明： 1）第一个FU-A包的FU indicator：F应该为当前NALU头的F，而NRI应该为当前NALU头的NRI，Type则等于28，表明它是FU-A包。FU header生成方法：S = 1，E = 0，R = 0，Type则等于NALU头中的Type。 2）后续的N个FU-A包的FU indicator和第一个是完全一样的，如果不是最后一个包，则FU header应该为：S = 0，E= 0，R = 0，Type等于NALU头中的Type。 3）最后一个FU-A包FU header应该为：S = 0，E= 1，R = 0，Type等于NALU头中的Type。 因此总结就是：同一个NALU分包厚的FU indicator头是完全一致的，FU header只有S以及E位有区别，分别标记开始和结束，它们的RTP分包的序列号应该是依次递增的，并且它们的时间戳必须一致，而负载数据为NALU包去掉1个字节的NALU头后对剩余数据的拆分，这点很关键，你可以认为NALU头被拆分成了FU indicator和FU header，所以不再需要1字节的NALU头了。 ",
      "url"      : "https://pfcstyle.github.io/2016/07/11/H.264-NALU/",
      "keywords" : "[&quot;H.264&quot;, &quot;NAL层解析&quot;, &quot;NALU&quot;]"
    } ,
  
    {
      "title"    : "iOS项目总结(十)",
      "category" : "iOS",
      "content": " 以小见大，不偏不倚 今天做项目遇到一个奇怪的问题，使用UITabBarController做主控制器，切换控制器然后返回时，下面的tabBar会比view切换慢了几秒，还自带动画，而且这个问题只是在切换特定界面时才会出现。具体描述： 1.实例化UITabBarController //.... -(YSSJNavigationController *)thirdNav{  if (!_thirdNav) {  YSSJLivingViewController *livingViewController = [[YSSJLivingViewController alloc] init];  [livingViewController setHidesBottomBarWhenPushed:YES];  _thirdNav = [[YSSJNavigationController alloc] initWithRootViewController:livingViewController];  _thirdNav.navigationBar.hidden = YES;  [_thirdNav setHidesBottomBarWhenPushed:YES]; }  return _thirdNav; } //.... self.thirdNav.tabBarItem = [self itemWithTitle:[arrayName objectAtIndex:4] image:[UIImage imageNamed:[arrayName objectAtIndex:5]] selectedImage:[UIImage imageNamed:[arrayName objectAtIndex:4]] ]; self.thirdNav.tabBarItem.tag = 2; //...此处略去了其他nav的实例化 //主控制器是继承的UITabBarViewController self.viewControllers = @[firstNav,secondNav,self.thirdNav,fourthNav]; 2.点击跳转到thirdNav //YSSJLivingViewController.m //从thirdnav的根控制器present到VLiveStreamViewController -(void)p_jumpToLivePage{  NSDictionary *options = @{      @gid : @(-1),      @gids : @[],      @shortContent : @,      @tags :@[],      @title : @,      @type : @live      };  NSMutableDictionary *liveInfo = [[NSMutableDictionary alloc]initWithDictionary:options];  //网上获取群组信息  liveInfo = [YSSJTop setLiveInfo:liveInfo];  NSMutableDictionary *createOption = [liveInfo[@creator] mutableCopy];  NSArray *joinedGroups = liveInfo[@joinedGroups];  createOption[@liveId]= liveInfo[@liveId];  [createOption setValuesForKeysWithDictionary:liveInfo];   // 发起直播  VLiveStreamViewController *liveStreamVC = [[VLiveStreamViewController alloc] initWithNibName:nil bundle:nil];  liveStreamVC.modalTransitionStyle = UIModalTransitionStyleCrossDissolve;   liveStreamVC.fromChatGroup = @(-1);  liveStreamVC.createOption = [createOption copy];  liveStreamVC.joinedGroups = joinedGroups;  liveStreamVC.needSelectGroup = YES;  liveStreamVC.delegate = self;   [self presentViewController:liveStreamVC animated:YES completion:nil]; } 3.dismiss控制器VLiveStreamViewController //YSSJLivingViewController.m //dismiss之后会响应这个函数 发出一个通知 -(void)viewWillAppear:(BOOL)animated{  [[NSNotificationCenter defaultCenter] postNotificationName:CloseLiveNotification object:nil]; } //这是通知的函数 回到原始界面 -(void)closeLive{  if (_lastSelectedIndex == 2) {  _lastSelectedIndex = _frontSelectedIndex;  [self setSelectedIndex:_frontSelectedIndex];  }else{  _lastSelectedIndex = _frontSelectedIndex;  } } 4.问题出现 此时在原始界面，随便push一个controller，然后pop,发现TabBar返回已经和根控制器不同步了 解决方式 还记得上面发送通知的地方吗，之前在viewwillappear中，现在在viewdidappear中 -(void)viewDidAppear:(BOOL)animated{  [[NSNotificationCenter defaultCenter] postNotificationName:CloseLiveNotification object:nil]; } Then all work nice!!! 解决方式很简单，但是我应该从这个问题里看到更多的问题： 当一些动画不是在同一个控制器，甚至是不是同一个view时，当这些动画显示会有冲突时，你必须让这些动画的时间错开，否则，将会真的产生冲突，从而产生各种奇葩的结果。 ",
      "url"      : "https://pfcstyle.github.io/2016/07/25/iOS-Project-Sumary10/",
      "keywords" : "[&quot;iOS&quot;, &quot;UITabBarController&quot;, &quot;TabBar&quot;, &quot;Show&quot;]"
    } ,
  
    {
      "title"    : "iOS一些小技巧及小知识点总结(持续更新)",
      "category" : "iOS",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 其实早就想开一个这样的blog,这样每次写代码有感的时候就可以来记录一下。由于拖延等等问题，今天才补上这么个开始，那么，就开始吧，万事，总得有个开始才好继续。 没有不能自定义的控件 苹果官方提供了许多的精美控件，但是出于某些原因，一些控件给出的自定义接口不足，致使我们无法定制出符合自己需求的控件，从而不得不每次自己去构建控件，这不免让人感到遗憾与无力。接下来，我就总结几种修改官方控件的方式，有了这几种方式，在我看来，几乎没有无法修改的控件了。 最优雅的自定义方式（重写） 最优雅的自定义方式，无非就是继承父控件进行重写了。这种方式对于大部分官方控件都是有效的，举个栗子：你现在要重写tablecell,满足表格距屏幕左右边界都是20pt. //继承tableviewcell @interface BaseCell : UITableViewCell @end //重写setframe @implemention BaseCell -(void)setFrame:(CGRect)frame{  frame.origin.x += 20;  frame.size.width -= 2 * 20;  [super setFrame:frame]; } @end 如何，是不是非常简单。当然，我相信大家对这种方式其实是非常熟悉的，因为这算是我们最为常用的了。这种方式对于那些特殊控件，比如UISwitch是没有作用的，无论你怎么修改frame，它都不会改变。但是，这并不是说没有办法了。 有点暴力的自定义方式（transform) UISwitch控件，宽高都是固定不变的，而且，个人感觉，有点大啊，不是那么好看。那么，如何更改呢？ UISwitch *switch = [[UISwitch alloc] init]; switch.transform = CGAffineTransformMakeScale(0.75, 0.75); 什么感觉？简单！而且这样基本不会有任何其他影响。不认识CGAffineTransform(变换)？ 认识一下，很强大，制作动画的利器。嗯，想优雅一点？结合继承： //继承UISwitch @interface MySwitch : UISwitch @end //重写setframe @implemention MySwitch -(void)setFrame:(CGRect)frame{  [super setFrame:frame];  t//ios7以后 uiswitch大小更改为（51,31）  tfloat scaleX = frame.size.width/51;  tfloat scaleY = frame.size.height/31;  tself.transform = CGAffineTransformMakeScale(scaleX,scaleY); } @end ok，这样，你就可以任意的更改Uiswitch的大小了。我就不截图了，大家试一下就知道了，没有任何问题。 最暴力的自定义方式（subview） 什么意思呢？之前使用父控件，这次又来折腾子view了！这次以什么为例呢？UIAlertController你怕不怕？到了ios9,uialertview已经废弃了，现在全面使用uialertcontroller。但是不管使用什么，最让开发者头疼的是，明明很好的一个控件，却大多数时候都需要自定义，因为主界面颜色完全无法自定义。。。。谁说的？ //实例化alertcontroller UIAlertController *alert = [UIAlertController alertControllerWithTitle:@提示message:message preferredStyle:UIAlertControllerStyleAlert]; //添加按钮 [alert addAction:[UIAlertAction actionWithTitle:@确定 style:UIAlertActionStyleCancel handler:^(UIAlertAction*action) {NSLog(@点击了确定按钮);}]]; //设置字体颜色（包括按钮的） [alert.view setTintColor:[UIColor redColor]]; //获取alertview的主窗体子view UIView *view = alert.view.subviews[0]; view = view.subviews[0]; //这是uialertview没有字时的大小 注意alert的大小跟提示信息的多少是有关系的，所以，这里104不是固定的 但是可以自己动态计算 UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 270, 104)]; //圆角 经测试 只要小于13就不会露出背景白色 imageView.layer.cornerRadius = 10.f; [imageView setBackgroundColor:[UIColor greenColor]]; [view insertSubview:imageView atIndex:0]; //嗯 一不小心又想起来一种更简单的方法 使用下面两句 上面的就不用了 core animation框架 //还是很强大的 这样也不用去计算高度了 哈哈 //view.layer.backgroundColor = [UIColor grayColor].CGColor; //view.layer.cornerRadius = 13.f; ok,diy成功。 隐藏的自定义方式（KVC) 其实官方控件中，许多属性虽然没有开放出来，但是苹果其实提供了一种类似于java反射机制的编程方式：KVC。KVC应该不用介绍了，不懂得就直接去搜索吧，我这里只是介绍它在自定义界面上的应用。这次就说UITextField的PlaceHolder属性，你想要斜体，想换个字体，想换个颜色？看代码 [_nameTF setValue:kTextViewPlaceHolderFont forKeyPath:@_placeholderLabel.font]; [_nameTF setValue:kTextViewPlaceColor forKeyPath:@_placeholderLabel.textColor]; ok了，现在去看看你的placeholder什么样吧，那个字体和颜色自己自定义哈。 Debug 为了开发方便，我们经常会有很多调试设置，但是这些设置在release模式下又是不需要，这时候我们往往会需要这些(例如)： #ifdef DEBUG //调试状态 #define MyLog(...) NSLog(__VA_ARGS__) #else //发布状态 #define MyLog(...) 那么，这个DEBUG是在哪里设置的呢？在 Target &gt; Build Settings &gt; Preprocessor Macros &gt; Debug 里有一个”DEBUG=1“。如果你把DEBUG改成haha呢?试一下！ 状态栏显示与隐藏 app启动时隐藏状态栏  在info.plist里面 Status bar is initially hidden 设置为 YES 如果你想启动后显示，在appdelegate.m中加入[application setStatusBarHidden:NO withAnimation:UIStatusBarAnimationFade]; 其他页面的状态栏的显示与隐藏 //在对应的控制器实现下面的方法 - (UIStatusBarStyle)preferredStatusBarStyle {  t//状态栏样式  return UIStatusBarStyleLightContent; } - (BOOL)prefersStatusBarHidden {  return YES; // 返回NO表示要显示，返回YES将hiden } UIScrollView捏合手势关闭 UIScrollView的自动缩放虽然方便，但也挡不住产品设计部的怪癖好，就是要停，要通过双击放大缩小，这就要求只关闭手势，而要保留缩放功能。通过查看UIScrollView.h发现有pinchGestureRecognizer属性，很是兴奋，于是 //在初始化函数中添加 但是并没有作用！！==！ 我这里是继承的UIScrollView [self removeGestureRecognizer:self.pinchGestureRecognizer]; self.pinchGestureRecognizer.enabled = NO; 后来，我是这样解决的： //在代理设置捏合手势失效 - (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView {  scrollView.pinchGestureRecognizer.enabled = NO;  return _photoImageView; } 这样就是可以的，我表示很方！！并不理解第一种方式为什么不行,猜测是在其他地方才初始化的pinch,不得而知。 双击放大缩小 既然说到了这个，就说一下如何通过双击实现放大缩小。 - (void)handleDoubleTap:(CGPoint)touchPoint {  t  t// Zoom  tif (self.zoomScale != self.minimumZoomScale &amp;&amp; self.zoomScale != [self initialZoomScaleWithMinScale]) {  t t  t t// Zoom out 主要是这个函数  t t[self setZoomScale:self.minimumZoomScale animated:YES];  t t  t} else {  t t  t t// Zoom in to twice the size  CGFloat newZoomScale = ((self.maximumZoomScale + self.minimumZoomScale) / 2);  CGFloat xsize = self.bounds.size.width / newZoomScale;  CGFloat ysize = self.bounds.size.height / newZoomScale;  [self zoomToRect:CGRectMake(touchPoint.x - xsize/2, touchPoint.y - ysize/2, xsize, ysize) animated:YES];  t} } App前后台切换的状态保存与恢复 //这些通知不只是在appdelegate中使用 每一个viewcontroller都是可以的 //WillResignActive //DidEnterBackground //WillEnterForeground //WillResignActive //切换前后台时 上面四个依次执行 //注册已经激活的通知 可以这里恢复状态 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onDidBecomeActive) name:UIApplicationDidBecomeActiveNotification object:nil]; //注册将要进入后台的通知 可以这里保存状态 注意这里非激活状态不只是切换前后台才会出现，比如切换页面的时候也会响应 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onWillResignActive) name:UIApplicationWillResignActiveNotification object:nil]; //注册将要进入前台通知 也可以这里恢复状态 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onWillEnterForeground) name:UIApplicationWillEnterForegroundNotification object:nil]; //这侧已经进入后台通知 也可以这里保存状态 注意操作不要超过5s，否则会被杀死 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onDidEnterBackground) name:UIApplicationDidEnterBackgroundNotification object:nil]; thread 1: sinal sigabrt 这个一般是因为你的xib或者storyboard与代码的连线有问题，或者是连多了，或者是连了之后改了名字又重连了一次，但是没有删除之前的。 UIScrollView与UICollectionView手势冲突 之前在制作一个图集浏览的控件，使用UICollectionView作为载体，每一个Cell中加入UIImageView和UIScrollView. UIImageView用来放图片与点击，双击，长按事件，UIScrollView主要是利用其放大缩小的功能。 UIScrollView的放大缩小本质是滑动手势的响应，这时，就偶尔会和UICollectionView的滑动事件冲突 解决方法是： 在cell上放一个UIView,比如contentView，然后把UIImageView和UIScrollView放到contentView上即可。 解决UIScrollview与NavigationBar的冲突 iOS7之后，scrollview都会自动留白一个navigationbar的高度，直接在你的controller里的viewdidload中假如下述代码即可。 if (DEVICE_OS_VERSION&gt;7) {  self.edgesForExtendedLayout = UIRectEdgeNone;  self.extendedLayoutIncludesOpaqueBars = NO;  self.modalPresentationCapturesStatusBarAppearance = NO;  self.automaticallyAdjustsScrollViewInsets = NO;  } 需要注意的是，添加这些后，view的位置就是从navigationbar开始，即屏幕的Y:64的位置现在是view的0。当然，你的view的总高度已经变成了DEVICE_SIZE.HEIGHT-64。 ",
      "url"      : "https://pfcstyle.github.io/2016/08/25/Ios-OC-Skills-Total/",
      "keywords" : "[&quot;Ios&quot;, &quot;OC&quot;, &quot;Skills&quot;, &quot;custome view&quot;, &quot;日期/字符串&quot;, &quot;Debug&quot;, &quot;Status bar&quot;]"
    } ,
  
    {
      "title"    : "Android一些小技巧及小知识点总结(持续更新)",
      "category" : "Android",
      "content": " 不积跬步，无以至千里；不积小流，无以成江海； 其实早就想开一个这样的blog,这样每次写代码有感的时候就可以来记录一下。由于拖延等等问题，今天才补上这么个开始，那么，就开始吧，万事，总得有个开始才好继续。 Android隐藏标题栏的区别 Android隐藏标题栏可以在清单文件里设置： &lt;!--这种方式是直接移除了标题栏，不占位--&gt; &lt;activity android:name=.MainActivity   android:theme=@android:style/Theme.Black.NoTitleBar/&gt; 也可以在onCreate方法中设置 //这种方式只是隐藏了 但是还会占位 requestWindowFeature(Window.FEATURE_NO_TITLE); 举例 我们应该都遇到过适配华为等带有虚拟按键的屏幕，这些按键占据了屏幕的底部，使我们的底部布局被遮挡。按照网上大部分的说法是因为沉浸式布局导致的，只需要设置 &lt;FrameLayout xmlns:android=http://schemas.android.com/apk/res/android    android:id=@+id/fl_main    android:layout_width=match_parent    android:layout_height=match_parent   android:fitsSystemWindows=true&gt;//设置这一句 &lt;/FrameLayout&gt; 但是这会导致虚拟按键虚拟按键背景色会变成透明色。必须关闭沉浸式布局才行（可能吧，没有研究）。 可是突然发现你有可能根本没有配置沉浸式布局，也出现了这种情况。这时候，就是我上面说的代码设置隐藏标题栏的占位的原因了。你改为使用xml设置即可更正。 #编译出的gradle问题 编译时出现Error:No service of type Factory available in ProjectScopeServices. 在根目录的build.gradle中，直接将’ classpath com.github.dcendents:android-maven-gradle-plugin:1.3’更新到1.4.1就可以解决问题了。 其实gradle出问题解决方式相对固定： 查看gradle版本号 查看build_tools版本号 查看gradle/gradle-wrapper.properties是否是互联网路径(有些公司可能为了保持统一，将gradle的zip包下到本地，并在此文件中配置为本地路径) 在settings的gradle中查看是否选择了Use local gradle distribution 一般改为Use default gradle wrapper即可 viewPager的数据更新 更新的函数就是mPager.getAdapter().notifyDataSetChanged();。但是，并非任何情况都会生效。  Override getItemPosition in your PagerAdapter like this: public int getItemPosition(Object object) {  return POSITION_NONE; } 这是为了通知viewpager所有的view失效，此时调用notifyDataSetChanged()函数就会触发更新。如果你需要使用到这个函数，那么，你应该再去写一个public函数去实现相同的功能。  to setTag()method in instantiateItem() when instantiating a new view. Then instead of using notifyDataSetChanged(), you can use findViewWithTag() to find the view you want to update. 这种方式相当于你自己管理viewpager的view,然后手动去更新，但是显然不适合用于删除或者添加数据的情况。 AS2.2及以后版本，Failed to crunch file ！ 这个问题的根本原因是文件名（包括路径）太长了，AndroidStudio里路径名不能超过240个字符，所以，尝试把工程放到根目录试试。 UnsatisfiedLinkError 你可以在这里 看到这个错误的解释，简单来说，就是虚拟机找不到native函数的声明。这时候，你可以去看看你的library有没有load对，然后看看jni里面的命名是不是正确。 System.Load(library)找不到 首先，可能是笔误，名字弄错了。 其他隐蔽的可能就是，cpu平台的问题。 arm-v8 =&gt; arm64-v8a arm-v7 =&gt; armeabi-v7a arm-v5 =&gt; armeabi x86 =&gt; x86 x86-64 =&gt; x86_64 mips =&gt; mips mips-64 =&gt; mips64 在编译so时，有时候需要你能选择正确的cpu平台。 或者去过滤你的cpu平台，下面的是删除了64bit平台，防止apk只去64bit中寻找so,导致一些so找不到。当然，这个需要看你具体需要的so包。 android {  ....  defaultConfig {  ....  ndk {   abiFilters armeabi, armeabi-v7a, x86, mips  }  } } ",
      "url"      : "https://pfcstyle.github.io/2016/09/24/Android-Skills-Total/",
      "keywords" : "[&quot;Android&quot;, &quot;Java&quot;, &quot;jNI&quot;]"
    } ,
  
    {
      "title"    : "ESXi+vCenter6.0虚拟化集群配置(一)",
      "category" : "Virtulized",
      "content": " 如果你在现实中遇到难以解决的问题，不妨尝试把问题虚拟化一下！ ESXI安装前准备 首先说下本次实验的物理的结构,画张图吧： 解释一下，图中的master和client是准备部署puppet的server和agent的，但是本系列文章不会记录这些，只是纯粹介绍vsphere系列的部署，我会抽时间再写些文章记录puppet的使用。图中的Source是记录部署自己的yum仓库。 下载vsphere系列软件 方法一，直接去官网下载，但是比较麻烦，要注册账号什么的，你们可以自己搞搞。 方法二，提供百度云下载 下载ESXI和vCenter即可，其他的本系列文章不会介绍。另外vCenter本次实验使用的是linux版本，即VCSA(Vmware vCenter Server Appliance ),但我也会介绍下windows版本的安装。 安装硬件说明 ESXI并不是兼容所有的硬件的，因此，如果你不是在使用虚拟机做实验，那么在配置硬件时，必须要选购ESXI支持的硬件，这里的硬件主要说的是cpu,网卡和存储设备。你可以在这里去查询你将要选购的硬件是否被ESXI兼容。如果你懒得麻烦，那么，英特尔系列的产品是确定兼容的。 安装ESXI 安装ESXI跟安装普通系统是没有什么区别的，制作一个启动U盘，然后U盘启动即可。下面直接看图吧，很简单：    配置ESXI主机 配置ESXI主机主要是配置网络，按照规划好的来 ESXI主机开机后是这样的，这里下面的ip等网络信息都是已经配置好的。 F2进入设置界面 进入界面后，选择Configure Management Network,然后设置ipv4的地址 配置dns,这里dns我们还没有配置，按照规划先设置好就行，后续还会讲配置域控与dns 设置一下域 设置shell和ssh选项  连接ESXI主机 Web Client连接 web页面管理还是最方便的，直接在浏览器输入ESXI主机的ip或者域名即可：  具体怎么使用下节说。 desktop Client连接 具体使用，下节介绍。 ",
      "url"      : "https://pfcstyle.github.io/2016/10/20/vsPhere-vCenter-etc1/",
      "keywords" : "[&quot;ESXi6.0&quot;, &quot;vCenter6.0&quot;, &quot;vsPhere&quot;]"
    } ,
  
    {
      "title"    : "Read-Android-Blog",
      "category" : "Android",
      "content": " 站在巨人的肩膀上 最近在掘金上读了一些好的android blog,有些心得，总结一下。 ［译］开发安卓Apps，我所努力学习到的三十多条宝贵经验 其中的某些推荐博客需要翻墙才可浏览。 选择与使用第三方库  你应该选择大众的选择，一是因为经得起考验，二是因为用的人多，总会用贡献者加入，作者维护起来也会更加用心。 选择可信的作者或者组织。 选择文档比较全面的。 选择专精某一功能的库，而不是大而全的库。否则这个库一旦停止维护，你可能要面临全部重构的危险。 使用第三方库时，你应该对其再次封装，防止在你的工程需要替换这个库的时候导致的大范围代码修改。 一定要理解第三方库的原理，但不到万不得已，一定不要修改第三方库！ 应该养成积累自己的轮子的习惯。 避免过度绘制 首先你要学会使用android的一个检测工具：android手机=&gt;开发者选项=&gt;调试GPU强制渲染(Debug GPU Overdraw) 打开此选项之后，你会发现自己的手机屏幕充满了各种色块,如下图： 本图来源于https://riggaroo.co.za/optimizing-layouts-in-android-reducing-overdraw/ 各种颜色的含义： 原色：没有过度绘制 蓝色：1xOverdraw-绘制了2次 绿色：2xOverdraw-绘制了3次 粉色：3xOverdraw-绘制了4次 红色：4xOverdraw-绘制了5次 ok,现在已经知道了如何绘制，那么接下来就是如何fix 这个要根据具体的项目来解决，其实无非是一个原则，重复绘制的地方看如何避免绘制。一些常见的问题，比如你设置的背景色是否真的需要？你设置的背景图片，你的某些空间是否真的需要一直显示？还有，很重要的一点，你得有一个好的产品设计。 你可以从这里得到更多关于过度绘制的信息 如何分包(按功能) 这个，怎么说呢，各执一词，我从android转到ios,又从ios转回android,就我的经验来说，我觉得应该按照功能来分包更加的科学，如何分包，解决的无非是维护时如何快速寻找到目标的问题。显然，如果你按照功能模块进行分包，可以快速的定位一个区域，然后，在功能模块的包内，你再根据你选用的设计模式来分包，这样就能很快的找到你的目标。如果你是刚开始就按照设计模式分包，甚至按照控件分包，那么，等待你的，就是眼花缭乱。 如何加快gradle的编译速度 现在的android的开发者大多都已经转到android studio阵营了，而且不得不承认，android studio比eclipse要更加专业，功能也更强大。但是，当你的项目大到一定程度时，每次要启动一次应用都会变得异常煎熬。 在项目根目录下的gradle.properties中加入： //# The Gradle daemon aims to improve the startup and execution time of Gradle. //# When set to true the Gradle daemon is to run the build. org.gradle.daemon=true //# Specifies the JVM arguments used for the daemon process. //# The setting is particularly useful for tweaking memory settings. //# Default value: -Xmx10248m -XX:MaxPermSize=256m org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 //# When configured, Gradle will run in incubating parallel mode. //# This option should only be used with decoupled projects. More details, visit //# http://www.gradle.org/docs/current/userguide/multi_project_builds.html //#sec:decoupled_projects org.gradle.parallel=true //# Enables new incubating mode that makes Gradle selective when configuring projects. //# Only relevant projects are configured which results in faster builds for large multi-projects. //# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:configuration_on_demand org.gradle.configureondemand=true 具体的原理我就不再记录了，不是我想关注的，如果你想要了解，请看这里（需要梯子） SVG 代替 PNG 当年xcode6开始支持pdf作为矢量图时，着实给我我们的UI省了一大把力，UI只需要确定一个屏幕尺寸，出一套pdf图给我们就可以了，xcode会自动生成3个尺寸的png给我们，而我们的调用仍然想以前一样简单。 现在我看到android也可以这样搞了，给我们一套svg或者psd的图，我们也可以自己生成其他尺寸的图，同样也是不会有任何锯齿的。不过遗憾的是4.4及以下的系统是不支持的，所以恐怕现在还是不能大范围使用的，毕竟5.0以下系统还不能直接抛弃。 Android App优化之内存优化(序) 至于说GC机制以及系统切换APP的内存管理机制，这里都不会解释，不懂得可以参考上述博文，写的很详细生动。 我要总结的是：为了不要让系统kill掉我们的App, 可以从进程级别, 内存消耗量等几个方面进行优化。 内存监测工具Memory Monitor 此图来源于:http://blog.lmj.wiki/2016/10/25/app-opti/app_opt_mat/  ① GC按钮, 点击执行一次GC操作. ② Dump Java Heap按钮, 点击会在该调试工程的captures目录生成一个类似这样”com.anly.githubapp_2016.09.21_23.42.hprof”命名的hprof文件, 并打开Android Studio的HPROF Viewer显示该文件内容. ③ Allocation Traking按钮, 点击一次开始, 再次点击结束, 同样会在captrures目录生成一个文件, 类似”com.anly.githubapp_2016.09.21_23.48.alloc”, alloc后缀的文件, 并打开Allocation Tracker视图展示该文件内容. 这里只简单提一下android studio自带的监测工具，具体使用，可以参照上面的博文系列。 内存泄漏的常见可能  Context泄漏。某些全局对象没有使用Application级别的对象，而是使用的指定的activity的Context，导致activity难以回收。 内部类泄漏。当内部类持有当前类的引用，并且内部类的生命周期长与当前类，就会导致当前类的内存泄漏。如Handler泄露, Thread泄露等。其实，当我们发生这种错误时，一般lint会进行提示，并且建议我们使用使用Static + WeakReference的方式，这正是正确的解决方式，而不是使用@SuppressLint(“HandlerLeak”)来逃避提示。 Register泄漏。对于观察者，广播，Listener等，添加与删除没有成对出现，从而导致的内存泄露，这个只能希望程序员们多长点心了。 资源泄漏。当你操作文件或者数据库等等时，打开资源之后，请一定记得关闭资源。 Bitmap泄漏。Bitmap没有及时的调用recycle()回收导致内存泄漏。 有效使用内存的建议  合理使用ServiceService的及时关闭可以让我们节省内存消耗, 对于一次性的任务, 建议使用IntentService. 使用优化后的数据容器使用Android提供的SparseArray, SparseBooleanArray, LongSparseArray来代替HashMap的使用.关于HashMap，ArrayMap，SparseArray, 这篇文章有个比较直观的比较, 可以看下. 少用枚举enum结构相比于静态常量(static final), enum会耗费双倍的内存. 避免创建不必要的对象诸如一些临时对象, 特别是循环中的. 考虑实现onTrimMemory(), 在此根据当前的内存状态做些处理. Bitmap的合理有效使用.对于Bitmap的使用, 建议直接查看官方开发文档中的高效显示Bitmap(需翻墙). ",
      "url"      : "https://pfcstyle.github.io/2016/11/07/Read-Android-Blog/",
      "keywords" : "[&quot;android&quot;, &quot;blog&quot;]"
    } ,
  
    {
      "title"    : "OOP-Six-Principles",
      "category" : "设计模式",
      "content": " 面对正确的事物，我们往往无法确定它是正确的 面向对象的六大原则 单一职责原则(Single Responsibility Principle) 这一原则虽然简单，但其实争议最大，也是最难以界定的。一个类只应该做自己职责范围内的事，这个职责本身就很难确定，是功能职责？是架构职责？还是其他什么职责？每一个程序员心中可能都有不同的界定。 假定我们以功能职责为标准，类比经理(一般manager类)，作为一把手，是不是什么事都要亲自去做？那么其实其他人(财务，市场等)的职能是否都属于经理呢？这样显然不合理，各种事都该各个部门分别去做，然后经理来同意指挥协调(manager去调用各个实现类的方法)。 其实这是六大原则中的另外一种原则了，我想说的事，这个原则，大家需要靠自己的实践经验去形成自己的风格，没有真正的对错，只要你的风格稳定不变。 开闭原则(Open Close Principle) 这也是一个很基础的设计原则，对扩展，开放；对修改，封闭。 一个项目，免不了维护和升级。而在维护升级时，为了避免引入新的bug，我们应该尽量扩展新的功能，而不是直接在旧代码中进行修改。 当然，这只是理想的情景，实际上我们很多时候都不得不去修改旧的代码。但我们也应该尽可能的避免。 避免的方法就是使用开闭原则，尽可能的去覆写父类的方法，或者尽可能的去设计公共接口，然后去实现它们。 里氏替换原则(Liskov Substitution Principle) 简单来说，在我们进行组合依赖时，应该尽可能的依赖的是借口或者父类(包括抽象类)，这样我们在覆写了父类或者是实现类借口的方法之后，就可以在使用时随意的替换。 比如现在经理辞职换了一个人，经理职权不变，但是每个人行使职权的风格和方式却是不同的，这个经理只需要重新实现接口，就可以用自己的风格去快速执掌公司类。 依赖倒置原则(Depedence Inversion Principle) 这个，简单解释就是接口去决定细节实现。高层次的模块不去关心低层次的细节实现，而是设计类各种接口去掉用。而低层次模块则是根据高层次的调用的接口去实现细节。 比如，经理管理财务方面，要看财务报表，于是定义了一个看财务报表的接口，那么下面的财务部就得去实现这个接口，提供财务报表。至于这个财务报表，是机器统计的还是会计自己画的，经理是不会关心的。 接口隔离原则(InterfaceSegregation Principles) 这其实就是解决第一个原则中提出的问题，接口应该尽可能的小。 你不能设计一个大的经理的接口，里面声明类各个部门的所有方法，而是应该分成多个接口，每一个接口再去声明各自的功能。甚至，你应该再去进一步细分，比如每个部门有一个总管，下面各个职员，负责各个细节。 迪米特原则(Law of Demeter or Least Knowledge Principle) 一个对象，应该对所依赖的对象有最少的了解。简单来说，你最好就不要了解，各个功能都在对方的类中实现，你只管调用这个函数就好了。 比如，经理现在要市场部提供公司最大的客户的相关信息给他，市场部内有一个列表，保存了所有客户的信息。这时候，应该是市场部内部进行筛选拿到最大客户信息返给经理，而不是经理自己取出市场部的所有客户信息，自己遍历一遍拿出最大客户信息。 怎么看呢 这些原则都是老生常谈了，今天我并不是为了再次介绍它们，而是想说说以前自己的困惑，自己的想法，但，只是自己的观点，谈不上对错。 维护与实现 这是我刚开始接触各种设计模式最大的困惑，我知道怎么去设计架构以符合设计模式，也知道，写出的代码，应该扩展性好，解耦好，健壮性好……可是，一味的去符合设计模式，导致的结果可能会是，代码可读性差，难以维护。这个可能有争论，实际上，这里讨论的是设计模式的使用的度的问题。 比如，你大量的使用接口，那么，你在调试代码时，可能并不知道它到底是那一个子类实现的功能，你还需要按图索骥，一层层的去寻找调用赋值的位置，去寻找到实现的位置，然后再去分析有没有bug。 比如，按照接口隔离原则，可能每一个功能，都要去单独设计一个接口，那么，不可避免的是，你将会分成很多很多类文件，这对于维护来说，也无疑是增加了很大难度。 …… 所以，现在是一个如何适度的问题。到底是不是每一个功能都需要单独设计一个接口，到底是不是每一个地方都需要这么好的扩展性，都需要使用父类，接口，抽象类？ 程序员都知道，我们应该根据需求来说事。虽然从来都没遇到不变的需求，但是，好在大方向总是不变的，所以需求还是具有一定的参考性的。 那么，根据需求，以及我们的经验，我觉得，模块化的东西，往往需要充分的解耦合，并且应该有好的扩展性。因为我们可能在很多地方使用，以及本项目之外；大而全的东西，可以牺牲这些特性，因为它们可重用的机会比较少，比如android的activity，ios的controller。 总之，需要变化的地方，才是导致工程覆灭的潜在因素，我们的设计模式，我们的软件工程，针对的，应该是这些地方。 ",
      "url"      : "https://pfcstyle.github.io/2016/11/14/OOP-principles/",
      "keywords" : "[&quot;OOP&quot;, &quot;Principles&quot;]"
    } ,
  
    {
      "title"    : "Android-Animation-Gesture",
      "category" : "Android",
      "content": " 代码就像DNA,随机组合过程中总会出现毛病。 Animation 这里不会介绍动画的详细用法，只是记录一些小问题。 动画无效 //这里要时刻注意，你传进去要变化的动画纬度参数是否是正确的 TranslateAnimation animation = new TranslateAnimation(0, 0, mEditView.getHeight(), 0);  animation.setDuration(500); animation.setAnimationListener(new Animation.AnimationListener() {   @Override public void onAnimationStart(Animation animation) {     tmEditView.setVisibility(View.VISIBLE);    t}  @Override public void onAnimationEnd(Animation animation) {}  @Override public void onAnimationRepeat(Animation animation){}  });  mEditView.startAnimation(animation); 注意上述代码，在动画开始时，使mEditView显示，在动画前，它是隐藏的。这里需要注意的是，如果你在xml文件中(或者使用代码)设置的是gone，而不是invisible，那么，你在设置动画参数时，传入的mEditView.getHeight()就是0，从而导致没有动画发生。 动画之后出现异常情况 TranslateAnimation animation = new TranslateAnimation(0, 0, 0, mEditView.getHeight()); //注意这里，如果设为true，动画结束后，将会强制保持结束时的状态。 //animation.setFillAfter(true); animation.setDuration(500); animation.setAnimationListener(new Animation.AnimationListener() { @Override t  tpublic void onAnimationStart(Animation animation) { } t  t@Override    tpublic void onAnimationEnd(Animation animation) {  t tmEditView.setVisibility(View.INVISIBLE);  }  t@Override public void onAnimationRepeat(Animation animation) {} }); mEditView.startAnimation(animation); 这里是隐藏的动画，在上面//animation.setFillAfter(true);这句，会导致onAnimationEnd中的mEditView.setVisibility(View.INVISIBLE);无效，准确来说，mEditView保持了动画结束的状态，在屏幕外面。 但是，不仅如此，setFillAfter(true)这句，还使得事件与view分离了。所以，你往往会点到一些看起来诡异的东西。 Gesture view自身具有的手势监听已经很全面了。 mHeaderView.setOnTouchListener(new View.OnTouchListener() {  @Override  public boolean onTouch(View view, MotionEvent motionEvent) { );   switch (motionEvent.getAction()) {    case MotionEvent.ACTION_DOWN: {       t final float y = motionEvent.getY();    Log.d(downY:+y);    // Remember where we started (for dragging)    mLastTouchY = y;    // Save the ID of this pointer (for dragging)    break;    }       case MotionEvent.ACTION_MOVE: {    // Find the index of the active pointer and fetch its position    final float y = motionEvent.getY();    Log.d(downY:+mLastTouchY+===moveY:+y);       // Only move if the ScaleGestureDetector isn't processing a gesture.    //       if (!mScaleDetector.isInProgress()) {    // Calculate the distance moved    //       final float dx = x - mLastTouchX;    final float dy = y - mLastTouchY;       RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) mQueryListView.getLayoutParams();    params.topMargin = (int) (params.topMargin+dy);    mQueryListView.setLayoutParams(params);       break;    }       case MotionEvent.ACTION_UP: {    break;    }   }   return true;  }  }); 这里展示的是使用一个手指上下拖动view的事例。注意，这里监听的是一个控件，而不是整个window。在ACTION_MOVE中，拿到的y是你的手指在目标view中的坐标，因此，这里只需要减去ACTION_DOWN时的初始坐标，就能得到每次需要移动的距离。 注意，目标view随着你的手指在移动，所以，ACTION_MOVE中拿到的y一般波动很小，因为你的手指可能一直在目标view的同一个位置。 你的手指每移动1像素，目标view就会跟随移动1像素。 GestureDetector 在遇到极其复杂的交互情况，可能会需要使用到这里的手势监听器。 mGestureDetector = new GestureDetector(mActivity,UpdateFeaturesProtocol.this); //这里需要注意，必须设置这一句，否则在GestureDetector的实现中，只能响应down,press,longpress三个事件mHeaderView.setLongClickable(true); mHeaderView.setOnTouchListener(new View.OnTouchListener() {  @Override  public boolean onTouch(View view, MotionEvent motionEvent) {    return mGestureDetector.onTouchEvent(motionEvent);  }  }); 下面是对OnGestureListener的实现 private float startPointY;  /** * Gesture * @param motionEvent * @return */  //点下时响应 第一个响应  @Override  public boolean onDown(MotionEvent motionEvent) {  Log.d(down==&gt;e2.x:+motionEvent.getX()+====e2.y:+motionEvent.getY());  RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) mQueryListView.getLayoutParams();  startPointY = motionEvent.getY();  return false;  }  //几乎跟down一样，但是在down后  //比如down响应需要0.1s,那么press需要0.2s  //如果你的手指接触屏幕时间不足0.2s，该事件不会响应  //这里的0.1s和0.2s皆为假设，没有测过  @Override  public void onShowPress(MotionEvent motionEvent) {  Log.d(press==&gt;e2.x:+motionEvent.getX()+====e2.y:+motionEvent.getY());   }  //单击  @Override  public boolean onSingleTapUp(MotionEvent motionEvent) {  Log.d(singletap==&gt;e2.x:+motionEvent.getX()+====e2.y:+motionEvent.getY());  return false;  }  //滚动 在手指滑动过程中一直响应  @Override  public boolean onScroll(MotionEvent motionEvent, MotionEvent motionEvent1, float v, float v1) {  Log.d(scroll==&gt;e2.y:+motionEvent1.getY()+===e1.y:+motionEvent.getY()+distanceY:+v1);  RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) mQueryListView.getLayoutParams();  params.topMargin = (int) (params.topMargin + (motionEvent1.getY()-startPointY));  mQueryListView.setLayoutParams(params);  return false;  }  //长按  @Override  public void onLongPress(MotionEvent motionEvent) {  Log.d(longpress==&gt;e2.x:+motionEvent.getX()+====e2.y:+motionEvent.getY());  }  //扔？  //此事件是指用手指快速滑动并快速抬起的情况  //注意，此事件在scoll后是不一定响应的。  @Override  public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,     float velocityY) {  Log.d(fling==&gt;e2.x:+e2.getX()+====e2.y:+e2.getY());   return false;  } 功能和直接使用mHeaderView.setOnTouchListener完全一样，思路也是完全一样的。解释都在代码注释里。 需要注意的是里面没有监听手指抬起的地方，所以你还需要回到setOnTouchListener中使用ACTION_UP ",
      "url"      : "https://pfcstyle.github.io/2016/11/17/Animation-Gesture/",
      "keywords" : "[&quot;Android&quot;, &quot;Animation&quot;, &quot;Gesture&quot;]"
    } ,
  
    {
      "title"    : "记mapbox-android-sdk的修改编译过程",
      "category" : "Android",
      "content": " 好记性不如烂笔头 接到一个android地图项目，准备使用mapbox作为底图。但是有些地方需要修改一下，主要是读取一些自己的数据等，所以这里得重新编译so及sdk。本篇不会记录如何修改，更不会去讲C++相关的任何知识，只是记录编译过程。 如果你是需要编译其他平台的sdk,看完本篇，也是完全没有问题的。 准备工作  环境 mac OS X EI Capitan(Command) or Linux(Command) or windows Cygwin 本人使用的是环境1。 另外，一个建议是，mac的硬盘比较小，我的是128的固态，编译完成可能有10多G，所以，我最后是把工程放到了移动硬盘里，也建议大家这样做(在编译开始前你就该放到移动硬盘里，否则会因为路径的问题，导致下载的好的包及配置文件失效)。  源码下载 在github下载源码。仓库tag和branch很多，clone的话很费时间，我个人的建议是选择一个tag或者分支就可以了，直接download zip比较快。 我这里选择的是android-v4.2.1,这是当前最新的android分支。  配置必要的环境 既然是要编译android sdk,那么，基础的android的环境配置是肯定要配置好的。主要是两个环境变量: 在主要是两个环境变量:ANDROID_HOME和NDK的路径。 在~/bash_profile的末尾添加： //当然 这里是我的路径 大家如果和我的不同 记得换啊 export ANDROID_HOME=/Users/developer/Library/Android/sdk export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools export PATH=$PATH:/Users/developer/Library/Android/sdk/ndk-bundle 开始编译 可以开始编译了。使用终端进入mapbox-gl-native(这个名字不是固定的，你下载源码的方式和版本不同，名称都是不一样的，新手不必纠结)的根目录。 cd ~/Downloads/mapbox-gl-native-release-android-v4.2.1 make android 不同make命令对应的cpu平台不同，如下： android=&gt;armeabi-v7 android-lib-$1: $1=&gt;(arm-v5 arm-v7 arm-v8 x86 x86-64 mips) arm-v8 =&gt; arm64-v8a arm-v7 =&gt; armeabi-v7a arm-v5 =&gt; armeabi x86 =&gt; x86 x86-64 =&gt; x86_64 mips =&gt; mips 如：make android-lib-x86 如果想编译全部平台: make apackage (编译android所有cpu架构,建议使用这个) 这些都可以从根目录的makefile文件里得到，这里粘贴makefile的一部分文件。 #### Android targets ########################################################### ANDROID_ENV = platform/android/scripts/toolchain.sh ANDROID_ABIS = arm-v5 arm-v7 arm-v8 x86 x86-64 mips .PHONY: style-code-android style-code-android: $(BUILD_DEPS)  tnode platform/android/scripts/generate-style-code.js define ANDROID_RULES build/android-$1/$(BUILDTYPE): style-code-android  tmkdir -p build/android-$1/$(BUILDTYPE) build/android-$1/$(BUILDTYPE)/toolchain.cmake: platform/android/scripts/toolchain.sh build/android-$1/$(BUILDTYPE)  t$(ANDROID_ENV) $1 &gt; build/android-$1/$(BUILDTYPE)/toolchain.cmake build/android-$1/$(BUILDTYPE)/Makefile: build/android-$1/$(BUILDTYPE)/toolchain.cmake platform/android/config.cmake  tcd build/android-$1/$(BUILDTYPE) &amp;&amp; cmake ../../.. -G Ninja     t t-DCMAKE_TOOLCHAIN_FILE=build/android-$1/$(BUILDTYPE)/toolchain.cmake     t t-DCMAKE_BUILD_TYPE=$(BUILDTYPE)     t t-DCMAKE_EXPORT_COMPILE_COMMANDS=ON     t t-DMBGL_PLATFORM=android .PHONY: android-lib-$1 android-lib-$1: build/android-$1/$(BUILDTYPE)/Makefile  t$(NINJA) $(NINJA_ARGS) -j$(JOBS) -C build/android-$1/$(BUILDTYPE) all .PHONY: android-$1 android-$1: android-lib-$1  tcd platform/android &amp;&amp; ./gradlew --parallel --max-workers=$(JOBS) assemble$(BUILDTYPE) apackage: android-lib-$1 endef $(foreach abi,$(ANDROID_ABIS),$(eval $(call ANDROID_RULES,$(abi)))) .PHONY: android android: android-arm-v7 .PHONY: android-test android-test:  tcd platform/android &amp;&amp; ./gradlew testDebugUnitTest --continue .PHONY: android-test-apk android-test-apk:  tcd platform/android &amp;&amp; ./gradlew assembleDebug --continue &amp;&amp; ./gradlew assembleAndroidTest --continue .PHONY: apackage apackage:  tcd platform/android &amp;&amp; ./gradlew --parallel-threads=$(JOBS) assemble$(BUILDTYPE) .PHONY: android-generate-test android-generate-test:  tnode platform/android/scripts/generate-test-code.js #### Miscellaneous targets ##################################################### .PHONY: style-code style-code:  tnode scripts/generate-style-code.js .PHONY: clean clean:  t-rm -rf ./build     t  ./platform/android/MapboxGLAndroidSDK/build     t  ./platform/android/MapboxGLAndroidSDKTestApp/build     t  ./platform/android/MapboxGLAndroidSDK/src/main/jniLibs     t  ./platform/android/MapboxGLAndroidSDKTestApp/src/main/jniLibs     t  ./platform/android/MapboxGLAndroidSDK/src/main/assets .PHONY: distclean distclean: clean  t-rm -rf ./mason_packages  t-rm -rf ./node_modules 可以看到.PHONY:后面的就是各种命令。其他平台类似。 先打针强心剂，在编译过程中，需要下载很多依赖，我在编译完成之后，整个文件夹有10.58G…我用了一整晚。 这样如果顺利的话，编译so就完成了。但是可能会有问题，看末尾问题解释。 另外说下，编译完成后，so文件在mapbox-gl-native/platform/android/MapboxGLAndroidSDK/src/main/jniLibs下 mapbox-android-sdk 的打包和使用  打包 使用android studio打开platform下的android工程 然后直接运行就好了。 在build的output下就可以找到aar文件了。  使用aar 这里我直接还以上述android工程里的测试工程为例。 ** 拷贝aar到目标工程的libs(没有自己创建)下 这里我将aar重命名了一下，大家随意，后有图。 ** 配置builid.gradle android { ··· repositories {  flatDir {   dirs 'libs'  }  } } dependencies { // compile(project(':MapboxGLAndroidSDK')) { //  transitive = true // } compile(name: 'mapbox-android-sdk-4.2.1', ext: 'aar') ··· //mapbox aar dependences  compile 'com.squareup.okhttp3:okhttp:3.4.1' // Exclude Guava to avoid an unnecessary transitive dependency  // See: https://github.com/mapbox/mapbox-gl-native/issues/7129  compile ('com.mapzen.android:lost:1.1.1') {  exclude group: 'com.google.guava'  } // Mapbox Android Services  compile('com.mapbox.mapboxsdk:mapbox-java-services:1.3.1@jar') {  transitive = true  }  //mapbox aar dependences  ··· }  需要说下的是，打包的aar不会自动打包依赖，除非是你自己手动添加对应的依赖aar或者jar到目录下，只是用gradle管理依赖的话，是不会自动打包到aar中的。 ** 记得添加上access_token 问题解释  某个包总是下载失败 我想说的是，多试几次，有代理，vpn什么的都连上，多试几次。从终端输出里可以看出来，这些包都是aws上的，但是亚马逊的服务器对我们来说太不稳定了，所以，试试vpn什么的，会好很多。  在x86等手机上提示找不到so 如果你是用make android命令来编译的，那么就只有arm-v7的so,64bit的运行没有问题(没有全部测试，用三星S7 edge测试没有问题)，但其他32bit平台就不行了，所以建议你编译上其他平台的包。使用make apackage编译。 很多问题在前面步骤中已经自动避过了，现在反而没什么需要多说了，祝好运吧。 ",
      "url"      : "https://pfcstyle.github.io/2016/12/28/mapbox-compile/",
      "keywords" : "[&quot;Android&quot;, &quot;mapbox&quot;, &quot;libmapbox-gl&quot;]"
    } ,
  
    {
      "title"    : "spatialite-android-sdk的编译和使用",
      "category" : "Android",
      "content": " 好记性不如烂笔头 项目用到spatialite,记录下使用方法 准备工作  环境 有android studio就行了  源码下载 如果想使用最新版本，去google下载源码吧。 我这里提供博客日期为止最新的源码 这里还有已经把所有的坑填上了完整工程 开始编译 使用android studio打开项目 File=&gt;New=&gt;import project 会报一些错误，直接贴图 缺少compile-sdk 版本 最小skd版本设置错误 package-name重复 缺少ndk编译模块 这个首先你应该已经安装了ndk,这个我就不多说了。 这时候sync gradle应该就没有问题了 配置工程 我没有重新去打包so文件，在这里有具体的打包流程。但是我有尝试过，确实是很麻烦的一件事，工程中没有完整的make文件，依赖都需要自己去管理，我直接去网上找到了合适的so文件。如果你是自己找的so文件，那么，一定要确定是ndk-r8以上版本编译的，否则会有text alloc…类似的错误 删除掉demo app目录下的Google Map相关的类，因为需要配置api_key,而且现在google map好像都已经完全更新了，不知道接口变了没有，要验证spatialite 是否成功并不需要展示到map上，所以删除掉MappingActivity.java和MapSelectionOverlay.java两个类文件,记得修改清单文件AndroidManifest.xml 现在已经可以编译成功并运行了。但是现在只能在32bit的安卓机上运行，因为so只有32bit的，64bit的机子会找错文件夹，需要再设置一下： 然后再运行就没有任何问题了。 spatialite-android-sdk 的使用  首先在build/outputs中找到aar文件，具体aar怎么用可以参考我的上篇博客。 下载spatialite-gui 普及一下spatialite的基础知识 spatialite&gt; select spatialite_version(); 4.0.0 spatialite&gt; select proj4_version(); Rel. 4.8.0, 6 March 2012 spatialite&gt; select geos_version(); 3.3.6-CAPI-1.7.6 spatialite&gt; select lwgeom_version(); 2.0.2 spatialite&gt; select HasIconv(); 1 spatialite&gt; select HasMathSQL(); 1 spatialite&gt; select HasGeoCallbacks(); 1 spatialite&gt; select HasProj(); 1 spatialite&gt; select HasGeos(); 1 spatialite&gt; select HasGeosAdvanced(); 1 spatialite&gt; select HasGeosTrunk(); 0 spatialite&gt; select HasLwGeom(); 1 spatialite&gt; select HasEpsg(); 1 spatialite&gt; select HasFreeXL(); 1 輸入由 WGS84 為基準的經緯度（4326 是 WGS84 2D 的 EPSG CRS SRID 編號）： spatialite&gt; select AsText(MakePoint(114.1689,22.4518,4326)); POINT(114.1689 22.4518) 將它轉換為 WGS84 UTM 50N 格網座標（32650 是 WGS84 / UTM zone 50N 的 EPSG CRS SRID 編號）： spatialite&gt; select AsText(ST_Transform(MakePoint(114.1689,22.4518,4326),32650)); POINT(208621.605201 2485587.067636) 將它轉換為 HK1980 格網座標（2326 是 Hong Kong 1980 Grid System 的 EPSG CRS SRID 編號）： spatialite&gt; select AsText(ST_Transform(MakePoint(114.1689,22.4518,4326),2326)); POINT(835447.180293 834705.40192) 利用格網座標計算大埔中心至九龍坑山的距離： spatialite&gt; select ST_Distance(MakePoint(208838.738969, 2488246.942923), MakePoint(208621.605201, 2485587.067636)); 2668.72321824495 利用經緯度計算大埔中心至九龍坑山的距離： spatialite&gt; select ST_Length(MakeLine(MakePoint(114.17052, 22.475837,4326), MakePoint(114.1689,22.4518,4326)), 1); 2666.99235712016 計算大埔中心至九龍坑山的方位角： spatialite&gt; select Degrees(ST_Azimuth(MakePoint(114.1689,22.4518,4326), MakePointZ(114.17052, 22.475837, 437.639187, 4326))); 3.85568120514838 輸出九龍坑山三角網測站的 KML： spatialite&gt; select AsKml(Cloudy Hill, description, MakePointZ( 835614.056, 837367.172, 440.8, 2326)); &lt;Placemark&gt;&lt;name&gt;Cloudy Hill&lt;/name&gt;&lt;description&gt;description&lt;/description&gt;&lt;Point&gt;&lt;coordinates&gt;114.170519962613,22.47583709798935,437.6391865937039&lt;/coordinates&gt;&lt;/Point&gt;&lt;/Placemark&gt; 點的 Union： spatialite&gt; select astext(ST_Union(MakePoint(114.17052, 22.475837,4326), MakePoint(114.1689,22.4518,4326))); MULTIPOINT(114.17052 22.475837, 114.1689 22.4518) 創建有地理數據的表，先是一般格式的欄： spatialite&gt; CREATE TABLE TestTable( id INTEGER PRIMARY KEY AUTOINCREMENT, Name TEXT NOT NULL); 創建該地理數據欄，儲存以 WGS84 為基準的點： spatialite&gt; SELECT AddGeometryColumn('TestTable', 'Geometry', 4326, 'POINT', 'XY'); 1 加入 R* index，以加快檢索：(添加索引) spatialite&gt; SELECT CreateSpatialIndex('TestTable', 'Geometry'); 1 加入點數據： spatialite&gt; insert into TestTable (Name, Geometry) VALUES (a, MakePoint(114.1689,22.4518,4326)); spatialite&gt; insert into TestTable (Name, Geometry) VALUES (b, MakePoint(114.17052,22.475837,4326)); 列出數據（Geometry 未能直接顯示）： spatialite&gt; select * from TestTable; 1|a| 2|b| 列出數據： spatialite&gt; select id, Name, AsText(Geometry) from TestTable; 1|a|POINT(114.1689 22.4518) 2|b|POINT(114.17052 22.475837) 利用 R* index 查出在 22.4518N 114.1689E, 22.4520N 114.1690E 內的點： spatialite&gt; SELECT id, Name, AsText(Geometry) FROM TestTable WHERE ROWID IN (SELECT pkid FROM idx_TestTable_Geometry WHERE pkid MATCH RTreeIntersects(114.1689,22.4518,114.1690,22.4520)); 1|a|POINT(114.1689 22.4518) 將點數據轉成 GeoHash（可以文字方式儲存於一般資料庫，以方便查詢某一點附近的其他點）： spatialite&gt; SELECT Name, GeoHash(Geometry) FROM TestTable; a|wecptzpr0ny5c1eeemw3 b|wecpy587jztypffhy099 sdk的简单使用，我直接按照demo理一下。 //上面这些获取数据库路径的代码就省略了 ... // 1. //Open the database 打开数据库 jsqlite.Database db = new jsqlite.Database(); db.open(dbFile.toString(), jsqlite.Constants.SQLITE_OPEN_READONLY); // 2. // Test prepare statements 测试下准备好了没有？我的理解就是查询一下数据库的基本状态和信息，可能真正使用时也是用不到的。 String query = SELECT name, peoples, AsText(Geometry) from Towns where peoples &gt; 350000; Stmt st = db.prepare(query); st.step(); st.close(); // 3.测试各种查询 你们也可以把我上面简单介绍的其他命令拿来测试下 // Test various queries db.exec(select Distance(PointFromText('point(-77.35368 39.04106)', 4326), PointFromText('point(-77.35581 39.01725)', 4326));,  t tcb); db.exec(SELECT name, peoples, AsText(Geometry), GeometryType(Geometry), NumPoints(Geometry), SRID(Geometry), IsValid(Geometry) from Towns where peoples &gt; 350000;,  t tcb); db.exec(SELECT Distance( Transform(MakePoint(4.430174797, 51.01047063, 4326), 32631), Transform(MakePoint(4.43001276, 51.01041585, 4326),32631));,  t tcb);  t t // 4. // Close the database 搞完了就关闭 db.close(); 最后，这里还有一个官方的tutorial，虽然很老了，但是api基本没变化，大家可以找到更多关于使用spatialite的使用方法。感兴趣的可以看下。 好了，就到这里了。 ",
      "url"      : "https://pfcstyle.github.io/2016/12/29/spatialite-android/",
      "keywords" : "[&quot;Android&quot;, &quot;spatialite-android&quot;]"
    } ,
  
    {
      "title"    : "Taking part in a group interview",
      "category" : "English",
      "content": "Key Vocabulary  Benefits: something you get from a company in addition to the money you earn. Redundant: without a job because there is no more work available for you. // not same as fire and same as lay off   I think it’s important to show who’s in charge.   If l were you, I’d just tell him that if he doesn’t calm down he’d lose any benefits he’d get when he’s made redundant.   I’m not sure I agree with you on that.   I’d say his anger is justified.   Ok, but just because it’s justified doesn’t mean it’s appropriate.   How do you know he won’t get angry in response?   I guess you don’t know, so that’s a fair point!   Lillian, what would you do?   Suggest that we reschedule this meeting for another day.   But What if he refuses?   I guess I would try Lillian’s idea of rescheduling first and if that didn’t work, only then would I try something more drastic like threaten to take away his benefits.   Only by working hard can you succeed.   Only after she died was I able to appreciate her.   Only by shouting was he able to make himself heard. Dialogue Leslie: I think it’s important to show who’s in charge. So I guess if I was the HR manager, I’d just tell him that if he doesn’t calm down he’d lose any benefits he’d get when he’s made redundant. Lillian: Really? I’m not sure I agree with you on that. I mean, if I was being made redundant I’d be pretty unhappy, too. Caleb:yeah,’ d say his anger is justified mean how would- do Leslie: Ok, but just because it’s justified doesn’t mean it’s appropriate. I’ve worked with people like that before. I mean, if his position requires him to deal with customers, do you really want to keep someone who gets angry easily? Caleb: Easily? But, being laid off is a pretty good reason to be angry. Like I was saying, how would you feel if that happened to you? Leslie: Well, unhappy, of course, but my point is that if he’s working with customers and someone gets angry with him, how do you know he won’t get angry in response? Caleb: I guess you don’t know, so that’s a fair point, but I’m really not sure that taking away his benefits is the best answer. Lillian, what would you do? Lillian: I would try to give him time to process the news and calm down. Caleb: How would you do that? Lillian: Suggest that we reschedule this meeting for another day. Leslie: But what if he refuses? Then what would you do? Caleb: Honestly, I’m not sure. I guess I would try Lillian’s idea of rescheduling first and if that didn’t work, only then would try something more drastic like threaten to take away his benefits Leslie: Yeah, that’s probably the best possible plan. Lillian: Hmm…i suppose so. But I still don’t like the idea of making his life harder by taking away his benefits. ",
      "url"      : "https://pfcstyle.github.io/2019/07/31/taking-part-in-a-group-interview/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Negotiating a better deal",
      "category" : "English",
      "content": "Key Vocabulary  Target point: the best result to make a deal Benchmark: the middle result to make a deal Resistance point: the worst result to make a deal Bargaining range: From resistance point to target point. Interests: The foundamental reason of a negotiation. Position: Current level. …Sth like that. …Sth kind of that. …Sth of that nature. …Sth along those lines. To low ball Sb. Give a very low price to sb. ",
      "url"      : "https://pfcstyle.github.io/2019/12/04/negotiating-a-better-deal/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Ansible 快速入门",
      "category" : "ansible",
      "content": "是什么 Python的一套自动化工具库 组成  Ansible 核心命令执行工具 Ansible Playbook 任务剧本（又称任务集），具有编排能力的配置文件集合，yaml Inventory 管理的主机清单，默认/etc/ansible/hosts文件 Modules 功能模块，支持自定义 Plugins 模块功能的补充，常有连接类型插件，循环插件，变量插件，过滤插件等 API 提供给第三方调用的应用程序接口 custom modules 自定义模块 安装与配置 apt-get install ansible -y ansible --version ansible配置文件优先级 // 由上到下, 优先级逐渐降低 ANSIBLE_CONFIG #环境变量 ansible.cfg #项目目录 .ansible.cfg #当前用户的家目录 /etc/ansible/ansible.cfg #默认配置文件 配置文件详解 #inventory = /etc/ansible/hosts #主机列表配置文件 #library  = /usr/share/my_modules/ #库文件存放目录 #remote_tmp  = ~/.ansible/tmp  #临时py文件存放在远程主机目录 #local_tmp = ~/.ansible/tmp  #本机的临时执行目录 #forks  = 5     #默认并发数 #sudo_user = root    #默认sudo用户 #ask_sudo_pass = True    #每次执行是否询问sudo的ssh密码 #ask_pass = True    #每次执行是否询问ssh密码 #remote_port = 22    #远程主机端口 host_key_checking = False    #跳过检查主机指纹 log_path = /var/log/ansible.log   #ansible日志 [privilege_escalation] #如果是普通用户则需要配置提权 #become=True #become_method=sudo #become_user=root #become_ask_pass=False Ansible inventory /etc/ansible/hosts是默认主机资产清单文件，用于定义被管理主机的认证信息， 例如ssh登录用户名、密码以及key相关信息。 我们可以在执行ansible命令时，动态指定inventory文件 ansible web1 -m ping -i inventory.ini 如何配置Inventory文件 主机支持主机名通配以及正则表达式，例如web[1:3].test.com代表三台主机 主机支持基于非标准的ssh端口，例如web1.test.com:6666 主机支持指定变量，可对个别主机的特殊配置，如登陆用户，密码 主机组支持指定变量[group_name:vars]，同时支持嵌套组[game:children]  场景一、基于密码连接  ```bash cat /etc/ansible/hosts #方式一、主机+端口+密码 [webservers] 10.0.0.31 ansible_ssh_port=22 ansible_ssh_user=root ansible_ssh_pass=’123456’ 10.0.0.41 ansible_ssh_port=22 ansible_ssh_user=root ansible_ssh_pass=’123456’ #方式二、主机+端口+密码 [webservers] web[1:2].yuntaoshu.com ansible_ssh_pass=’123456’ #方式三、主机+端口+密码 [webservers] web[1:2].yutaoshu.com [webservers:vars] ansible_ssh_pass=’123456’ #### 场景二、基于密钥连接，需要先创建公钥和私钥，并下发公钥至被控端 ```bash #利用非交换式工具实现批量分发公钥与批量管理服务器 ssh-copy-id -i ~/.ssh/id_rsa.pub root@172.16.1.41 ssh-copy-id -i ~/.ssh/id_rsa.pub root@172.16.1.31 #方式一、主机+端口+密钥 [group_name] 10.0.0.31:22 10.0.0.41 #方式二、别名+主机+端口+密钥 [group_name] nfs-node1 ansible_ssh_host=10.0.0.31 ansible_ssh_port=22 场景三、主机组使用方式 #方式一、主机组变量+主机+密码 [group_name1] 10.0.0.31 10.0.0.41 [group_name1:vars] ansible_ssh_pass='123456' #方式二、主机组变量+主机+密钥 [group_name2] 10.0.0.7 10.0.0.8 #定义多组，多组汇总整合 #webservers组包括两个子组[apapche,nginx] [webservers:children] [group_name1] [group_name2] 查看主机清单 #查看所有 [root@m01 ~]# ansible all --list-hosts hosts (1):  172.16.1.7 #查看某个组内的主机数 [root@client ~]# ansible web --list-hosts hosts (1):  172.16.1.7 #查看非默认配置主机清单的 [root@m01 /project1]# ansible web -i hosts --list-hosts hosts (1):  172.16.1.7 inventory内置参数 被控端首次连接容易出现问题  解决方案1 如果控制端和被控制端第一次通讯，需要确认指纹信息，如果机器特别多少的情况下怎么办？ 将 Ansible 配置文件中的 host_key_checking = False 参数注释打开即可。 但要注意ansible.cfg文件的读取顺序。   解决方案2 通过脚本来实现 ``` [root@ansible ~]# vim /server/scripts/fenfa.sh #!/bin/bash if [ -f /root/.ssh/id_rsa ];then echo “———-密钥对已经存在—————” else echo “———-正在生成密钥对—————” ssh-keygen -f /root/.ssh/id_rsa -N ‘’ &gt; /dev/null 2&gt;&amp;1 fi for i in {5,6,7,8,9,31,41,51,52} do  echo “正在操作：172.16.1.${i}”  echo “———-正在分发——–”  sshpass -p123456 ssh-copy-id -i /root/.ssh/id_rsa.pub 172.16.1.${i} -o StrictHostKeyChecking=no &gt; /tmp/ssh .log 2&gt;&amp;1 done ## Ansible Ad-Hoc ### 什么是ad-hoc模式 &gt;ad-hoc简而言之，就是“临时命令”，不会保存 &gt;ansible中有两种模式, 分别是ad-hoc模式和playbook模式 ### ad-hoc模式的使用场景 &gt;场景一，在多台机器上，查看某个进程是否启动 &gt;场景二，在多台机器上，拷贝指定日志文件到本地，等等 ### ad-hoc模式的命令使用 ![ansible-ad-hoc](/img/post/2020-12-28/ansible-ad-hoc.jpg) ### ad-hoc模式的常用模块 * Ansible执行返回-&gt;颜色信息说明 &gt;黄色：对远程节点进行相应修改 &gt;绿色：对远程节点不进行相应修改，或者只是对远程节点信息进行查看 &gt;红色：操作执行命令有异常 &gt;紫色：表示对命令执行发出警告信息（可能存在的问题，给你一下建议） 1. command命令模块 #默认模块, 执行命令 [root@m01 ~]# ansible test -a “hostname” #如果需要一些管道操作，则使用shell [root@m01 ~]# ansible test -m shell -a “ifconfig|grep eth0” -f 50 -f = /etc/ansible/ansible.cfg中forks配置 #结果返回的数量 2. script脚本模块 #编写脚本 [root@m01 ~]# mkdir -p /server/scripts [root@m01 ~]# cat /server/scripts/yum.sh #!/usr/bin/bash yum install -y iftop #在本地运行模块，等同于在远程执行，不需要将脚本文件进行推送目标主机执行 [root@m01 ~]# ansible test -m script -a “/server/scripts/yum.sh” 3. yum安装软件模块 [root@m01 ~]# ansible test -m yum -a “name=httpd state=installed” name  #指定要安装的软件包名称 state  #指定使用yum的方法  installed，present #安装软件包  removed，absent #移除软件包  latest   #安装最新软件包 4. copy文件拷贝模块 #推送文件模块 [root@m01 ~]# ansible test -m copy -a “src=/etc/hosts dest=/tmp/test.txt” #在推送覆盖远程端文件前，对远端已有文件进行备份，按照时间信息备份 [root@m01 ~]# ansible test -m copy -a “src=/etc/hosts dest=/tmp/test.txt backup=yes” #直接向远端文件内写入数据信息，并且会覆盖远端文件内原有数据信息 [root@m01 ~]# ansible test -m copy -a “content=’bgx’ dest=/tmp/test” src   #推送数据的源文件信息 dest  #推送数据的目标路径 backup  #对推送传输过去的文件，进行备份 content  #直接批量在被管理端文件中添加内容 group   #将本地文件推送到远端，指定文件属组信息 owner   #将本地文件推送到远端，指定文件属主信息 mode  #将本地文件推送到远端，指定文件权限信息 5. file文件配置模块 [root@m01 ~]# ansible test -m file -a “path=/tmp/oldboy state=directory” [root@m01 ~]# ansible test -m file -a “path=/tmp/tt state=touch mode=555 owner=root group=root” [root@m01 ~]# ansible test -m file -a “src=/tmp/tt path=/tmp/tt_link state=link” path  #指定远程主机目录或文件信息 recurse  #递归授权 state directory #在远端创建目录  touch  #在远端创建文件  link  #link或hard表示创建链接文件  absent #表示删除文件或目录  mode  #设置文件或目录权限  owner  #设置文件或目录属主信息  group  #设置文件或目录属组信息 6. service服务模块 [root@m01 ~]# ansible test -m service -a “name=crond state=stopped enabled=yes” name  # 定义要启动服务的名称 state  # 指定服务状态  started  #启动服务  stopped  #停止服务  restarted #重启服务  reloaded #重载服务 enabled  #开机自启 7. group组模块 [root@m01 ~]# ansible test -m group -a “name=oldgirl gid=888” name  #指定创建的组名 gid   #指定组的gid state  absent #移除远端主机的组  present  #创建远端主机的组（默认） 8. user模块 #创建用户指定uid和gid，不创建家目录也不允许登陆 [root@m01 ~]# ansible test -m user -a “name=oldgirl uid=888 group=888 shell=/sbin/nologin create_home=no” #将明文密码进行hash加密，然后进行用户创建 [root@m01 ~]# ansible localhost -m debug -a “msg=bgx” localhost | SUCCESS =&gt; {  “msg”: “$6$salt$WP.Kb1hMfqJG7dtlBltkj4Um4rVhch54R5JCi6oP73MXzGhDWqqIY.JkSOnIsBSOeXpKglY7gUhHzY4ZtySm41” } [root@m01 ~]# ansible test -m user -a ‘name=xlw password=$6$salt$WP.Kb1hMfqJG7dtlBltkj4Um4rVhch54R5JCi6oP73MXzGhDWqqIY.JkSOnIsBSOeXpKglY7gUhHzY4ZtySm41 create_home=yes shell=/bin/bash’ uid   #指定用户的uid group   #指定用户组名称 groups  #指定附加组名称 password  #给用户添加密码 shell   #指定用户登录shell create_home  #是否创建家目录 8.crond定时任务模块 #正常使用crond服务 [root@m01 ~]# crontab -l                 /bin/sh /server/scripts/yum.sh               #使用ansible添加一条定时任务 [root@m01 ~]# ansible test -m cron -a “minute=* hour=* day=* month=* weekday=* job=’/bin/sh /server/scripts/test.sh’” [root@m01 ~]# ansible test -m cron -a “job=’/bin/sh /server/scripts/test.sh’” 设置定时任务注释信息，防止重复，name设定 [root@m01 ~]# ansible test -m cron -a “name=’cron01’ job=’/bin/sh /server/scripts/test.sh’” 删除相应定时任务 [root@m01 ~]# ansible test -m cron -a “name=’ansible cron02’ minute=0 hour=0 job=’/bin/sh /server/scripts/test.sh’ state=absent” 注释相应定时任务，使定时任务失效 [root@m01 scripts]# ansible test -m cron -a “name=’ansible cron01’ minute=0 hour=0 job=’/bin/sh /server/scripts/test.sh’ disabled=no” 9. mount模块 [root@m01 ~]# ansible test -m mount -a “src=172.16.1.31:/data path=/data fstype=nfs opts=defaults state=present” [root@m01 ~]# ansible web -m mount -a “src=172.16.1.31:/data path=/data fstype=nfs opts=defaults state=mounted” [root@m01 ~]# ansible web -m mount -a “src=172.16.1.31:/data path=/data fstype=nfs opts=defaults state=unmounted” [root@m01 ~]# ansible web -m mount -a “src=172.16.1.31:/data path=/data fstype=nfs opts=defaults state=absent” present  # 开机挂载，仅将挂载配置写入/etc/fstab mounted  # 挂载设备，并将配置写入/etc/fstab unmounted # 卸载设备，不会清除/etc/fstab写入的配置 absent # 卸载设备，会清理/etc/fstab写入的配置 10.setup用于获取系统信息的一个模块 查看模块参数 [root@m01 ~]# ansible-doc -s setup 查看系统所有信息 [root@m01 ~]# ansible 192.16 1.31-m setup filter 对系统信息进行过滤 [root@m01 ~]# ansible 192.168.1.31 -m setup -a ‘filter=ansible_all_ipv4_addresses’ # 常用的过滤选项 ansible_all_ipv4_addresses  所有的ipv4地址 ansible_all_ipv6_addresses  所有的ipv6地址 ansible_architecture   系统的架构 ansible_date_time   系统时间 ansible_default_ipv4   系统的默认ipv4地址 ansible_distribution   系统名称 ansible_distribution_file_variety 系统的家族 ansible_distribution_major_version 系统的版本 ansible_domain    系统所在的域 ansible_fqdn     系统的主机名 ansible_hostname    系统的主机名,简写 ansible_os_family   系统的家族 ansible_processor_cores  cpu的核数 ansible_processor_count  cpu的颗数 ansible_processor_vcpus  cpu的个数 11. unarchive解压模块 01.解压远程服务器的压缩包到指定目录 创建压缩包： cd /etc &amp;&amp; tar zxvf /opt/sys.tar.gz etc/fstab etc/hosts 执行命令： [root@m01 ~]# ansible 172.16.1.31 -m unarchive -a “src=/opt/sys.tar.gz dest=/opt/ remote_src=yes” 02.把本地文件解压到目标机器指定目录 创建命令 cd / &amp;&amp; tar zcvf /opt/log.tar.gz var/log/messages [root@m01 ~]# ansible 172.16.1.31 -m unarchive -a “src=/opt/log.tar.gz dest=/opt/” 12. archive压缩模块 01.压缩单个文件 [root@m01 ~]# ansible 172.16.1.31 -m archive -a “path=/var/log/message dest=/tmp/log.tar.gz format=gz force_archi 13. ansible查看帮助方法 [root@m01 ~]# ansible-doc -l — 查看所有模块说明信息 [root@m01 ~]# ansible-doc copy — 表示指定查看某个模块参数用法信息 ``` ",
      "url"      : "https://pfcstyle.github.io/2020/12/28/ansible-base/",
      "keywords" : "[&quot;ansible&quot;]"
    } ,
  
    {
      "title"    : "Evaluating business proposals",
      "category" : "English",
      "content": "Key vocabulary  Be prepared for a lot of red tape, as building regulations are very strict around here. There aren’t enough young people in this town to support your business-try to expand your customer base. That price point seems little low for a luxury service. I’m not convinced there’s a gap in the market, since not many people are interested in comic books here. Your equipment will need insurance and regular maintenance-those are two major hidden costs, that you haven’t accounted for here. Because you are mainly delivering within the inner city, I don’t anticipate too many logistical challenges Proposals A. Organicare will market high-end skincare and cosmetics to young women aged 18-25. We will ensure our products use 100% natural ingredients sourced from countries around the world. The price point will be quite high-around $90 for a face wash-but our customers will be drawn to our luxury image. B. The $12 Haircut Bar will offer guick and simple haircuts to men of all ages at the lowest prices in the city! We can keep our prices low because we won’t provide shampoos, blow drying, styling and other services. C. Our city now has several Japanese restaurants, but we don’t have any shops selling items of Japanese pop culture-comic books. soft toys, fashion accessories, etc. J-SHOP will sell a range of these authentic Japanese products to young locals who are interested in getting in on the Japan craze. Comments  You’ll need to watch out for red tape takes a long time to get approval for importing these ingredients. There’s sure to be logistical challenges too. How many young women have this kind of money? There are hidden costs here-advertising in fashion magazines, etc. is very expensive. Nice-this price point will appeal to your target market. However, it’s critical that you maintain high quality. No one can accept a terrible haircut! I’m not convinced there’s a gap in the market for a store like this. You’ll have to look at how you can expand your customer base by selling online too. ",
      "url"      : "https://pfcstyle.github.io/2021/02/01/evaluating-business-proposals/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Talking about career paths",
      "category" : "English",
      "content": " Mark: Hey, Jane! Can I ask you a question? Jane: Sure, What’s up? Mark: Well, I’m going to be graduating soon, so I’ll be applying for jobs, but I’m not sure which jobs to choose. My parents say I should choose the company that pays the most but … Jane: But your’re worried that you’re going to end up with a boss you hate?  you’re going to get the result in the end with…   Mark: Yeah! Do you have any suggestions? Jane: Sure. Several things to keep in mind. First, do some research about the company. What are the chances that you’ll get a promotion if you stay with the company long-term? Also, where’s the company located? How long will the commute be? And of course the salary is important. Rather than thinking about which company pays the most though, find out which company pays you enough to live the life you want to live. However, none of this guarantees(there’s no promise) that you’re going to like your boss, but at least you’ll like everything else about the job if that happens. Mark: Wow! You’ve given me a lot to think about. Thanks! Jane: Glad I could be of help! ",
      "url"      : "https://pfcstyle.github.io/2021/02/02/Talking-about-career-paths/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Describing our job skills",
      "category" : "English",
      "content": "Skills  People skills John is extremely likeable and he gets along well with his colleagues. Speaking skills  Teamwork He is happy to cooperate with others.   Writing skills His reports are well organized and easy to understand.   Budget management He finishes his project without exceeding his budget.   Organization He finishes his project without going beyond his spending limit. Creativity  Problem solving When things go wrong, he relies on his teammates to find the answers.   Stress management He has difficulty working under pressure, and this can affect his work. Some describes You get along well with some of your colleague, but not all of them. Being confident is something that comes naturally to you. Your boss encourages you to think outside the box. You don’t usually take the initiative at work: you wait for the boss to tell you what to do. You need to become more efficient in your work. You have a skill that give you the ability to communicate effectively. You can cooperate with others, but you don’t like to rely on them. I am trying to stay up to date with the latest developments in my field. I’m behind on answering my emails, now I’m trying to get up to date. ",
      "url"      : "https://pfcstyle.github.io/2021/02/03/Describing-Our-Job-Skills/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Negotiating a better deal",
      "category" : "English",
      "content": " Target point: The Best result to make a deal. Benchmark: The middle result to make a deal. Resistance point: The worst result to make a deal. Bargaining range: From resistance point to target point. Interests: The foundamental reason of a negotiation. Position: Current level. ",
      "url"      : "https://pfcstyle.github.io/2021/02/04/Negotiating-A-Better-Deal/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Future Technology",
      "category" : "English",
      "content": "Prof. Gilbert: Making use of this technology will instantly benefit some of the poorest people on Earth. Drought-resistant crops will solve the problem of hunger in the developing world. Prof. Gilbert: Fine-tuning the genes of mosquitos so that they spread vaccines instead of malaria will eliminate many terrible diseases. Prof. Gilbert: And, closer to home, gene screening will enable us to find and fix health problems before a person is even born. Prof. Gilbert: Who wouldn’t want the ability to prevent their child from developing cancer? Prof. Gilbert: Being able to change the DNA of plants, animals and ourseleves will trigger a chain reaction of technological advancements, all of which will help us to overcome the challenges the future will throw at us. A: But not all the experts are so optimistic. A: Professor Goldman, fro Queen’s College, is more cautionary. Prof. Goldman: This is untested technology, and I’d warn against taking a leap into the unknown Manipulating DNA for our benefit really is ‘Playing God’, and could come back to haunt us. Prof. Goldman: Imagine we genetically engineer some crops and the changes lead to undesirable results; those changes might be impossible to reverse, and have a disastrous effect on the environment. Prof. Goldman: It’s a slippery slope, with serious consequences. Prof. Goldman: Once we start making changes to human DNA, who knows what terrible results it could have on our health in the future? Prof. Goldman: We really shouldn’t be playing around with technology we don’t fully understand yes. ",
      "url"      : "https://pfcstyle.github.io/2021/02/05/Future-Technology/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Effective presentations",
      "category" : "English",
      "content": "progress Welcome your audience Good morning, everyone. Thanks for coming. Tell audience some interesting abstract information or statistic to get people’s attention. I know that you’re all anxious to get more information about our acquisition of Sunset Computers. Offer people a ‘map’ of your presentation. I’ll begin by giving a general update. Then, I’ll be discussing out acquisition of Smoot Hawley. -ing的形式听起来不太确定并且更加友好 And I’m going to finish by talking about new projects. However, I won’t have any new financial information. Give your audience the rules for questions. During my presentation, if you have questions, please just ask them at any time(or until the end). Transitioning to the next point  As you know However … which brings us to my next point Best of all 首先 Worse yet 最糟糕的是 Now, I’d like to move on to；现在，我想转到。。。 These pie charts show… As you can clearly see … 你可以清楚看到 I’d like to draw your attentions to … Concluding a presentation  To summarize, we have a new CFO, sales are rising steadily and our merger with Smoot happens next month. To conclusion, … Ending a presentation Next steps for us all are to come up with ideas for improving morale. Email them to me. 我们所有人下面要做的是想出提高士气的主意。把它们用邮件发送给我。 I’ll take questions now. Are there any questions? Any more questions? Any other questions? If you think of other questions, just send me an email. Do you have any updates, Tom? Thank you all for coming today. ",
      "url"      : "https://pfcstyle.github.io/2021/02/06/Effective-Presentations/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "What’s the difference between @ObservedObject, @State, @Environment and @EnvironmentObject and @Binding?",
      "category" : "iOS",
      "content": "@State 只在view内部发生改变和使用，且是较为简单的数据类型。@State将变量的内存管理交给了SwiftUI。所有的view都是结构体，是标量，这意味着它们无法修改（只能重新赋值）。因此，当我们使用@State时， 我们将变量的控制权交给了SwiftUI，只要view存在，他就会一直在内存中存在。当变量发生改变时，SwiftUI也会自动重新加载。 struct ContentView: View {  @State private var score = 0  init() {  score = 1  }  // more code } @Binding 当需要读写祖先view的@State或@ObservableObject(可能其中某个属性)的属性时 struct MyView: View {  @State var isPresentingAlert = false var body: some View {  Button(action: {   self.isPresentingAlert = true  }, label: {   Text(Present an Alert)  })  .customAlert(isPresented: $isPresentingAlert) {   CustomAlertView(title: Text(Alert!))  }  }} struct CustomAlertView: View {  let title: Text  /// it needs read/write access to a State-  /// wrapped property of an ancestor view  @Binding var isBeingPresented: Bool } struct MyView: View { /// it needs to provide read/write access of /// one of its properties to a descendant view  @State var isPresentingAlert = false var body: some View {  Button(action: {   self.isPresentingAlert = true  }, label: {   Text(Present an Alert)  })  .alert(isPresented: $isPresentingAlert) {   Alert(title: Text(Alert!))  }  } } @ObservedObject 适用于自定义类型，具备多个属性和方法，或者需要跨view使用的情况。大部分情况和@State相同，只是结构更复杂。需要实现ObservableObject protocol，这意味着其内部的属性可以被SwiftUI binding. 大多数情况，我们直接使用@Published来声明内部属性，当然也可以使用combine框架实现自定义的Publisher # 自己内部初始化 class MovieViewModel: ObservableObject {  @Published var movies: [Movie] = [] // 1  // more code } struct MoviesView: View {  // 1  @ObservedObject var viewModel = MovieViewModel()  var body: some View {  List(viewModel.movies) { movie in // 2   HStack {    VStack(alignment: .leading) {    Text(movie.title) // 3a     .font(.headline)    Text(movie.originalTitle) // 3b     .font(.subheadline)    }   }  }  } } # 外部初始化（view init时） struct MyView: View { /// it is dependent on an object that can  /// easily be passed to its initializer  @ObservedObject var dessertFetcher: DessertFetcher var body: some View {  List(dessertFetcher.desserts) {   Text($0.name)  }.onAppear {   self.dessertFetcher.fetch()  }  }} extension UIViewController { func observedObjectExampleTwo() -&gt; UIViewController {  let fetcher = DessertFetcher(preferences: .init(toleratesMint: false))  let view = ObservedObjectExampleTwo(dessertFetcher: fetcher)  let host = UIHostingController(rootView: view)  return host  } }  Warning: When you use a custom publisher to announce that your object has changed, this must happen on the main thread. @EnvironmentObject ObservedObject当需要跨view共享或者是内嵌很深的view需要但又不适合自己初始化时，需要使用@EnvironmentObject。  @EnvironmentObject只支持1个实例 struct SomeChildView: View { /// it would be too cumbersome to pass that /// observed object through all the initializers /// of all your view's ancestors  @EnvironmentObject var veggieFetcher: VegetableFetcher var body: some View {  List(veggieFetcher.veggies) {   Text($0.name)  }.onAppear {   self.veggieFetcher.fetch()  }  }} struct SomeParentView: View {  var body: some View {  SomeChildView()  }} struct SomeGrandparentView: View {  var body: some View {  SomeParentView()  } } @Environment 当view依赖的不能满足ObservableObject协议时，可能是以下几种情况：  依赖的是一个值类型 依赖项仅作为协议而不是具体类型公开 依赖是一个闭包 @Environment 支持多实例 修改@Published的属性，不会引发view的重绘 struct MyView: View { /// it is dependent on a type that cannot /// conform to ObservableObject  @Environment(  .theme) var theme: Theme var body: some View {  Text(Me and my dad make models of clipper ships.)   .foregroundColor(theme.foregroundColor)   .background(theme.backgroundColor)  }} // MARK: - Dependencies protocol Theme {  var foregroundColor: Color { get }  var backgroundColor: Color { get } } struct PinkTheme: Theme {  var foregroundColor: Color { .white }  var backgroundColor: Color { .pink } } // MARK: - Environment Boilerplate struct ThemeKey: EnvironmentKey {  static var defaultValue: Theme {  return PinkTheme()  }} extension EnvironmentValues {  var theme: Theme {  get { return self[ThemeKey.self] }  set { self[ThemeKey.self] = newValue }  } } Workaround for Multiple Instances of an EnvironmentObject struct MyView: View { @DistinctEnvironmentObject(  .posts) var postsService: Microservice  @DistinctEnvironmentObject(  .users) var usersService: Microservice  @DistinctEnvironmentObject(  .channels) var channelsService: Microservice var body: some View {  Form {   Section(header: Text(Posts)) {    List(postsService.content, id:   .self) {    Text($0)    }   }   Section(header: Text(Users)) {    List(usersService.content, id:   .self) {    Text($0)    }   }   Section(header: Text(Channels)) {    List(channelsService.content, id:   .self) {    Text($0)    }   }  }.onAppear(perform: fetchContent)  }} // MARK: - Property Wrapper To Make This All Work @propertyWrapperstruct DistinctEnvironmentObject&lt;Wrapped&gt;: DynamicProperty where Wrapped : ObservableObject {  var wrappedValue: Wrapped { _wrapped }  @ObservedObject private var _wrapped: Wrapped init(_ keypath: KeyPath&lt;EnvironmentValues, Wrapped&gt;) {  _wrapped = Environment&lt;Wrapped&gt;(keypath).wrappedValue  }} // MARK: - Wherever You Create Your View Hierarchy MyView()  .environment(  .posts, Microservice.posts)  .environment(  .users, Microservice.users)  .environment(  .channels, Microservice.channels) ",
      "url"      : "https://pfcstyle.github.io/2021/02/07/SwiftUI-Diff-Property-Wrapper/",
      "keywords" : "[&quot;iOS&quot;, &quot;Swift&quot;, &quot;SwiftUI&quot;, &quot;Property Wrapper&quot;, &quot;@ObservedObject&quot;, &quot;@State&quot;, &quot;@Environment&quot;, &quot;@EnvironmentObject&quot;, &quot;@Binding&quot;]"
    } ,
  
    {
      "title"    : "kubernetes 教程（一）",
      "category" : "kubernetes",
      "content": "Kubernetes能提供什么 服务发现和负载均衡  存储编排 Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。 自动部署和回滚  自动完成装箱计算 Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。   自我修复 Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器   密钥与配置管理 Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。 Kubernetes集群部署图  Pod：最小的调度分配单元，可包含一组容器和卷组成，同一个Pod的容器组共享同一个网络命名空间; ReplicationController/ReplicateSet: 用于控制Pod副本数量，保证Pod始终运行; StatefulSet：类似ReplicateSet，但StatefulSet提供Pod状态保持，在重新调度后保留他们的标识和状态，适合数据库等有状态应用场景; DeamonSet： 保证在所有群集节点上运行一个Pod; Service: 为一组功能相同的Pods提供单一不变的接入点，解耦Pods伸缩能力; Deployment：类似ReplicationController/ReplicateSet， 增加滚动升降级策略和能力; ConfigMap：配置选项，支持配置从Pod解耦分离; Secret：类似ConfigMap，用于敏感数据保存; 重要组件 集群中包含多个节点，分为主节点和工作节点。 工作节点上用于负载应用的单元称为Pod,主节点用来管理工作节点和Pod. 控制面板组件（主节点） 对集群做出全局决策，以及检测和响应集群事件。每一个主节点同时也是node kube-apiserver Kubernetes的api服务，可以用来动态操作kubernetes，支持伸缩扩展。 etcd 保存Kubernetes集群数据的后台键值数据库 kube-scheduler 用来调度Pod及Pod的资源 kube-controller-manager 每一个控制器应该是一个进程，但为了降低复杂性，他们被编译到一个应用中，并运行在一个进程中  节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。 副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。 端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。 服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌  cloud-controller-manager  用于链接管理云提供商的应用编程接口，本地集群不需要 节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除 路由控制器（Route Controller）: 用于在底层云基础架构中设置路由 服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器 Node组件 Kubelet 每个工作节点上的代理，通过接收PodSpecs来管理容器，并保证安全的运行在Pod中 Kube-proxy 每个工作节点上运行的网络代理，维护节点网络规则 Container Runtime 负责运行容器的软件，如Docker、Containerd等任何实现Kubernetes CRI（容器运行环境接口）的容器软件 插件 使用Kubernetes资源提供集群级别功能，其命名空间域属于kubu-system命名空间。常用插件： DNS 几乎所有Kubernetes集群都应该有集群DNS用于做域名服务 仪表盘 Kubernetes集群通用的、基于WEb的用户界面，可以管理集群 容器资源监控 集群级别日志 ",
      "url"      : "https://pfcstyle.github.io/2021/02/08/kubernetes-1-core-concept/",
      "keywords" : "[&quot;k8s&quot;, &quot;kubernetes&quot;, &quot;教程&quot;]"
    } ,
  
    {
      "title"    : "kubernetes 组件版本偏差策略",
      "category" : "kubernetes",
      "content": "版本偏差  多个 kube-apiserver 实例小版本号最多差1 kubelet 版本号不能高于 kube-apiserver，最多可以比 kube-apiserver 低两个小版本。 kube-controller-manager、kube-scheduler 和 cloud-controller-manager 版本不能高于 kube-apiserver 版本号 kubectl 可以比 kube-apiserver 高一个小版本，也可以低一个小版本。 组件升级顺序  kube-apiserver kube-controller-manager、kube-scheduler 和 cloud-controller-manager Kubelet Kube-proxy ",
      "url"      : "https://pfcstyle.github.io/2021/02/08/kubernetes-components-version-strategy/",
      "keywords" : "[&quot;k8s&quot;, &quot;kubernetes&quot;]"
    } ,
  
    {
      "title"    : "kubernetes Daemonset",
      "category" : "kubernetes",
      "content": "守护进程集包含存储进程、日志收集进程、节点监控进程、和Pods管理（创建与回收）进程。 DaemonSet可以只有一个，也可以根据不同的daemon划分为多个。这些进程都以Pods的形式运行 Spec 必需字段 apiVersion, kind, metadata等通用字段 template, 这是一个pod template,其配置与pod几乎完全一样，除了没有apiVersion和kind selector,1.8开始，必须指定来匹配template的label，否则会报错 matchLabels - 匹配template的label matchExpressions - 通过指定key, values列表和关联key-value的操作，来构建更复杂的匹配 在指定的node上运行Pods 如果你指定一个.spec.template.spec.nodeSelector, 那么DaemonSet controller会在匹配的node上创建相关的Pods。如果指定spec.template.spec.affinity，那么会在亲和度匹配的node上创建Pods。如果什么都没有指定，那么将会在所有的node上创建。 Spec Example apiVersion: apps/v1 kind: DaemonSet metadata: name: fluentd-elasticsearch namespace: kube-system labels:  k8s-app: fluentd-logging spec: selector:  matchLabels:  name: fluentd-elasticsearch template:  metadata:  labels:  name: fluentd-elasticsearch  spec:  tolerations:  # this toleration is to have the daemonset runnable on master nodes  # remove it if your masters can't run pods  - key: node-role.kubernetes.io/master  effect: NoSchedule  containers:  - name: fluentd-elasticsearch  image: quay.io/fluentd_elasticsearch/fluentd:v2.5.2  resources:   limits:   memory: 200Mi   requests:   cpu: 100m   memory: 200Mi  volumeMounts:  - name: varlog   mountPath: /var/log  - name: varlibdockercontainers   mountPath: /var/lib/docker/containers   readOnly: true  terminationGracePeriodSeconds: 30  volumes:  - name: varlog  hostPath:   path: /var/log  - name: varlibdockercontainers  hostPath:   path: /var/lib/docker/containers Daemon Pods如何调度 一般情况下，pods由Kubernetes调度器调度，但是Daemon pods被DaemonSet controller创建并调度。这会导致两个问题： 不一致的Pod表现：一般的Pods会以Pending的状态创建，但是DaemonSet pods不会 Pod preemption被默认的调度器控制。当抢占启用时，DaemonSet controller会做出调度决定，而不考虑pod的优先级和抢占逻辑 可以通过添加NodeAffinity项到DaemonSet Pods可以让其使用默认的调度器 nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution:  nodeSelectorTerms:  - matchFields:  - key: metadata.name  operator: In  values:  - target-host-name 另外，node.kubernetes.io/unschedulable:NoSchedule toleration会自动添加到DaemonSet Pods上，从而使默认的调度器忽略unschedulable的Nodes ",
      "url"      : "https://pfcstyle.github.io/2021/02/08/kubernetes-daemonset/",
      "keywords" : "[&quot;k8s&quot;, &quot;kubernetes&quot;, &quot;daemonset&quot;]"
    } ,
  
    {
      "title"    : "Solving problem",
      "category" : "English",
      "content": "Key vocabulary  Don’t let negative people get in the way of your dream - if you really want it, go for it. Their marriage has been in a bad way recently, and I’m worried they might divorce. I have way too many problems of my own to deal with right now - I can’t promise I’ll be able to help. I can’t tell you the way forward, you need to find it for yourself. Her parents spoil her, and she always gets her own way. Dialogue  John: You’ve all heard of a midlife crisis, but what about a quarter-life crisis? Youth counsellor Helen Fern says more young people are experiencing one. Helen, what does a quarter-life crisis look like? Helen: Well it varies, John, but what we typically see is someone around 24, 25, recently graduated and usually in their first job. And things are tougher than they expected. Their finances are in a bad way with the student loan and rent increases, their jobs are often a lot less creative or enjoyable than they’d hoped for, and then of course with no children yet and no sense of career, they might be feeling quite… well, lost. So it’s a time of facing up to reality-you thought you’d have your own way with life, and now it’s not all happenging, or centainly not the way you imagined. John: So there you are - you’re 25, these things are all getting in the way of your dreams - how do you get through it? Helen: So, unlike mid-life crises - which tend to come from looking back on our lives - with a quarter-life crisis people are often comparing themselves, whether that’s to TV characters, or our friends, or even our own ideas about what our twenties should have been like. And so the way forward, is firstly to stop doing that, and start with your life as it is now. think about your true values - many young people want the freedom to travel, but if you’d rather focus on family and home, that’s fine too. John: And then do it. Helen: And do it -but start with small steps. If your goal is to see the world , you can begin by researching travel routes and saving a little money each week. But I will say, if you feel it’s time you made a big change - now’s the moment to do it. There are way too many people out there with regrets about their twenties, and they usually regret the things they didn’t do, not the things they did. ",
      "url"      : "https://pfcstyle.github.io/2021/02/09/solving-problems-dealing-with-life-changes/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Summarizing industry trends",
      "category" : "English",
      "content": "Key vocabulary  Media companies are moving away from newspapers and magazines, as not many people buy them anymore. There used to be a lot of book shops around here, but they went out of business. The first company to bring out a self-driving car will really shake up the automotive industry. Younger travelers are getting bored with places like the Maldives or Bali. They’re starting to seek out new destinations. Dialogue  Jocelyn: Isaac, you were saying earlier that we’re about to deal with a different kind of client in this industry. What exactly did you mean by that? Isaac: What we’re seeing now is that young professionals are coming in with the same questions, but they’ re looking for a different set of answers. Normally, our older, traditional clients-they come in and ask what’s available and we reply, you know, stocks and bonds, funds, savings accounts at the bank. Just different ways of making money. But the younger ones, they want to do good things, they’re seeking out ways to help the world. So in the future we’ll no longer be saying ‘stocks and bonds’, we’ll be saying ‘Look, if you’re worried about the environment, choose funds A or B, if you want to support the arts, go with X or Y.’ Bob: So, you’re saying that younger investors aren’t concerned about financial returns? Isaac: Oh, don’t get me wrong. Making money will continue to be the main reason people come to us. And that goes for young people too. But it’s not just about meeting their family responsibilities anymore-there’s this shift toward life experiences, making their dreams come true. So, I think financial advisors will start to bring out new kinds of advertising. And we’ll be moving away from this image of the middle-aged guy and his family, and they’re all smiling, you know - ‘Oh, I’m sending my kids to college.’ It’ll be much more personal than that. It’ll be about the year abroad in South America, or the vegetarian restaurant they always dreamed of opening. And it’s gonna be our job to say ‘Yeah, we can make that happen.’ Jocelyn: Will this also affect how young people manage their finances? Isaac: Absolutely. They’re going to shake up the way we do things in that area. A 25-year-old doesn’t want a report coming in the mail twice a year. They want to open their phone and check their finances at 2: 00am, and change their investment settings too if they feel like it. And we can expect to see new apps that help them with this. Over time, the companies that rely on the older methods will quite simply go out of business. ",
      "url"      : "https://pfcstyle.github.io/2021/02/16/summarizing-industry-trends/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Attending a meeting",
      "category" : "English",
      "content": "Key language What types of meetings are they? 1) share information, coordinate cross-department activities and projects, make announcements.(All-hands / staff meetings) 2) share problems, collect as many ideas as possible.(Brainstorming meetings) 3) assign tasks, decide methods, define results, solve problems.(Project meetings) 4) usually no more than 10 minutes, plan the day, prepare for daily tasks, align high-priority tasks for the day.(Stand-up meetings) 5) strengthen relationships, conduct group activities, develop trust amongst all employees.(Teambuilding meetings) 6) ensure all know what’s happening and who is responsible, share information, coordinate next steps.(Update meetings) ## Are these good tips for effective meetings? All are good tips. 1) Start and finish the meeting on time. 2) Make sure the meeting is necessary. 3) Make sure everyone participates in the meeting 4) Have an agenda and stick to it. 5) Plan ahead and prepare. Dialogue  Tammy: Shall we start? Does everyone know why we’re having this meeting? All employees: Umm, not really… Tammy: Oh, ok, not to worry. It’ll be clearer soon enough. There are a number of issues we need to talk about. I’m sure everyone is aware that the marketing and sales teams will merge into one team soon. So, the first item is, what can we do to maintain morale and ensure a smooth transition? This is the biggest challenge we’re facing. What are your thoughts? David: Err… As an IT engineer, I’m not quite sure what I can do to help with this problem. Maybe Jane has some ideas? Jane: Well, our sales team’s biggest concern is job cutting. Tammy: About that, I’m afraid I can’t make any promises, and I don’t know what rumors have been going around, but there’s no plan for job cutting as far as I’m aware. Dan: That’s good news for both teams. When will this happen? Tammy: We’re aiming to complete the process by the end of next month, and will keep everyone informed. Jane: I’m sorry to say that this timeline is a real challenge for us. Dan: I’m with Jane on that. That’s a bit soon. Tammy: I hear what you’re saying. However, I’m afraid that’s no longer open for discussion. The decision has been made by the board of directors. Jane: What?! So we’ll just have to deal with it? Hmm, ok fine! Let’s talk about the next item then. Tammy: Not yet, We still need to figure out how to make sure the transition goes smoothly… ",
      "url"      : "https://pfcstyle.github.io/2021/02/17/attending-a-meeting/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "English in the modern world",
      "category" : "English",
      "content": "Key vocabulary  Mother tongue: A person’s first language. Bilingual[ˌbaɪˈlɪŋɡwəl]: Able to speak two language. Lingua franca: A common language used between people who don’t share the same first language Prestige dialect: A variety of a language with high social status Sociolinguistic[ˌsoʊsioʊlɪŋˈɡwɪstɪk]: Referring to the relationship between society, social ideas and how languages are used. Multilingual[ˌmʌltiˈlɪŋɡwəl]: Able to speak many languages. Article  Dean Harrison believes the old ways aren’t working anymore and calls for a new ‘world English’. Imagine, for a moment, just a few of the cross-cultural conversations taking place across the globe right now. A Spanish architect steps off the plane in Berlin and greets his new coworkers from an international design firm. In Guangdong, China, a local export agent is on the phone discussing shipping options with an importer based in Greece. At a beach resort in Indonesia, a Russian tourist negotiates a taxi fare for her trip across the island. All these people share two things in common which will powerfully shape global communication in the years to come. Firstly, there’s a very good chance they are all speaking English. Secondly - and a far more significant development as far as language learning is concerned - not a single person involved speaks English as their mother tongue. It is now a global lingua franca. It all used to be much simpler. English lessons would present a model of native English (typically a prestige dialect, such as ‘BBC English’or’standard American’) and students would do their best to copy its pronunciation features, grammatical structures and so on. The best learners were those who most closely approximated the speech patterns of these dialects and their hearts would swell with pride anytime they heard the words, ‘Wow! You sound exactly like a native speaker!’ But consider this simple fact illustrated by the examples above: most English communication around the world now occurs between non-native speakers. What importance does an American or British model have for conversations like these? ‘Sounding native’ is not the mark of success here. Rather, the ability to follow a variety of English dialects and make your meaning clear in a range of contexts is now what matters. Besides, non-native speakers now outnumber native speakers of English 4-to-1. In terms of global communication, native speakers don’t’own’this language anymore and they can’t expect everyone else to follow their ways. English learners should be free to develop their own style, mixing features of their first language with features of the new. After all, English now belongs to non-native speakers as much as it belongs to anyone else. Soon we will open up to the truly global and democratic English of the 21st century. ",
      "url"      : "https://pfcstyle.github.io/2021/02/18/english-in-the-modern-world/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Android平台JS引擎对比",
      "category" : "Android",
      "content": "公司准备推出一个具备类似微信小程序的Mobile平台类APP, 经过调研，小程序架构都是渲染层与逻辑层分离的（小程序技术单开文章进行分析），而逻辑层其实就是一个JS引擎，那么JS引擎的选择就显得至关重要。因此，特别对目前Android平台上比较流行的JS引擎做一个对比。 比较对象  js-evaluator-for-android: 对native android webview的封装 J2V8: 对Google V8引擎做的java封装 duktape-android:基于Duktape JS引擎做的封装 测试条目  初始化：循环初始化创建各个JS引擎，比较初始化效率 循环：循环执行字符串比较，对比执行效率 加载：加载一个大小为174k的json文件，比较加载效率 模型：执行一个复杂的计算模型，对比执行效率 坑点：js-evaluator-for-android是懒加载，在初始化时没有做任何事情，只有当执行js时才会真正初始化webview，而这也会导致后续所有的测试都不准确。因此，在初始化测试时，需要手动调用getWebViewWrapper并计入初始化时间；在进行其他测试时，也都需要手动调用getWebViewWrapper之后再开始执行。 完整测试代码在Github 测试结果 对比总结       优点  缺点  大小(默认全ABI)     Webview  没有依赖，不增加额外大小  效率低，不能执行大JS代码（大于1M）  0    J2V8  效率最高，使用方便  初始化较慢，对于apk大小增幅较大，目前仅有x64,x86,armv7和arm64v8类型ABI  92M    Duktape  初始化快，体积小，具备全平台类型ABI  运行较J2V8慢  2.45M   ",
      "url"      : "https://pfcstyle.github.io/2021/02/19/compare-v8-webview-duktape-android/",
      "keywords" : "[&quot;JS Engine&quot;, &quot;J2V8&quot;, &quot;V8&quot;, &quot;Android&quot;, &quot;Webview&quot;, &quot;Duktape&quot;]"
    } ,
  
    {
      "title"    : "What I read",
      "category" : "English",
      "content": "Dialogue  Chen: Hey Harry, I was reading this book on English history that you told me about the other day and I was wondering-what legends are there in England? Harry: Well, I can think of one really famous one. There are many versions of this story and it’s set hundreds of years ago. They’ve even made a few films about it. Chen: Yeah? Okay, go for it. Harry: So, there’s this guy called Robin Hood. He’s this amazing archer who lives in a place called Sherwood Forest. Anyway, the rightful king of England at the time, Richard, goes off to war, and the evil King John, rules England in his place. He gets this other guy, the Sheriff of Nottingham to help him get more money from the poor. The Sheriff is also a bad guy in the story and he raises taxes so that he can make as much money as possible from the poor people. Chen: Ah, think I may have heard this story. Carry on. Harry: Basically, the poor people in the land find it difficult to survive as all their money’s been taken in the Sheriff’s taxes, you know? So, one day Robin thinks to himself “I need to do something here”, so, with a group of guys known as his Merry Men he starts to steal from the rich and give to the poor. He sounds like a bad guy, right? Well it turns out that he’s the hero of the story. Chen: Okay, so what happens next? Harry: To cut a long story short, the Sheriff of Nottingham tries to catch Robin Hood and offers anyone who helps him a big reward This Robin Hood guy, however, is too good for him and he ends up defeating the Sheriff and giving the poor back their money. In the end, the rightful King, King Richard, returns to Sherwood Forest and peace and order are restored in the land. You know Chen, I don’t think I know any legends in China, but I guess there must be loads… Chen: Oh yeah. I can think of four in particular… ",
      "url"      : "https://pfcstyle.github.io/2021/02/19/what-i-read/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Communicating Clearly",
      "category" : "English",
      "content": "Example  A po’boy  Let’s have a po’boy for launch!  A po’boy? Is that a kind of sandwich?  Yes, it’s a traditional submarine sandwich.   Key grammar  It’s a way of greeting someone, commonly used in Japan. It’s what you need if you want to travel to another country. It’s kind of a dog, but it’s a little bigger and lives in the wild. It’s the way you feel when you do something wrong and feel bad about it. It’s where you can go to play card games and win money. Dialogue  Frances: Yeah, I’m kind of nervous about my first day. Do you have any idea what it will be like? Martin: Well, because you’re an overseas student I’m not sure, but I think you’ll probably start off with a powhiri in the morning, and then youu can go for walk around campus after lunch. Frances: Oh yeah, my agent told me about that, but what exactly is a powhiri? Martin: It’s a kind of welcoming ceremony with speeches, dancing, singing, that kind of thing. It can be a little intimidating at first, but just follow the instructions and I’m sure you’ll be fine. Frances: And where will that be held? Martin: Oh they always hold that at the marae. Frances: The marae? Is that a kind of church? Martin: More of a town hall, I guess. It’s where people go to perform ceremonies, have meetings, or even do some crafts or community activities. Frances: Well, I’m looking forward to checking that out. Martin: But, I would just say be careful about how you behave there. In New Zealand we have this idea of mana- it’s kind of like a source of authority. And that’s really important on the marae. Frances: So it’s like a law? Martin: Hmm, not really, it’s more spiritual. It’s a way of showing respect to a special person or place Frances: So will I have to do anything special? Martin: Oh, no, for the powhiri it’s just basic courtesy stuff really. Turn your phone off, stay quiet while they’re giving the speeches, you know, don’t wander off, that kind of thing. Frances: Well, my agent told me we’d have guides, so I guess I’ll just do what they say. Martin: Yeah, don’t worry, I’m sure you’ll have a great time! ",
      "url"      : "https://pfcstyle.github.io/2021/02/20/communicating-clearly/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Combine详解（1）",
      "category" : "iOS",
      "content": "Combine基础  Publisher是发布者，作为数据生产者，会定义一个Output和Failure类型。 Subscriber是订阅者，作为数据消费者，会定义一个Input合Failure类型。 Operator是操作者，可以更改Publisher Output类型，产生新的Publisher。 Publisher的Output类型和Subsciber的Input类型需要相同 订阅操作是通过Publisher.subscribe(Subscriber)来完成的 获取到Subscribtion(Publisher.subscibe()返回)实例，可以调用.cancel()取消 sub?.cancel() 内置Subscriber  sink(receiveCompletion:receiveValue:): 常用于publisher和sink一起执行的时候，比如request请求，返回的response会在sink中处理 assign(to:on:): 通过key path将收到的值赋值到model // publisher之后直接sink let sub = NotificationCenter.default  .publisher(for: NSControl.textDidChangeNotification, object: filterField)  .sink(receiveCompletion: { print ($0) },   receiveValue: { print ($0) }) let sub = NotificationCenter.default  .publisher(for: NSControl.textDidChangeNotification, object: filterField)  .map( { ($0.object as! NSTextField).stringValue } )  .assign(to:   MyViewModel.filterString, on: myViewModel) 通过operator定制publisher let sub = NotificationCenter.default  .publisher(for: NSControl.textDidChangeNotification, object: filterField)  .map( { ($0.object as! NSTextField).stringValue } )  // 过滤非字母和数字字符  .filter( { $0.unicodeScalars.allSatisfy({CharacterSet.alphanumerics.contains($0)}) } )  // 防抖  .debounce(for: .milliseconds(500), scheduler: RunLoop.main)  // receive方法可以让combine在指定线程里调用subscriber  .receive(on: RunLoop.main)  .assign(to:  MyViewModel.filterString, on: myViewModel) share() operator 大多publishers都是struct, 是值类型，每一次订阅，实际上都是订阅了一个副本。share operator则可以赋予它们引用语义。 // PassthroughSubject是class类型，但是经过scan operator之后生成的是struct类型 let subject = PassthroughSubject&lt;String, Never&gt;() // 这里每次emit value, 第一个参数都会累加 let publisher = subject.scan((0, ), { ($0.0 + 1, $1) }) // subscribe一个 let c1 = publisher.sink { print(c1:, $0) } subject.send(a) subject.send(b) // output c1: (1, a) c1: (2, b) // 再次subscribe let c2 = publisher.sink { print(c2:, $0) } subject.send(c) // output 可以发现，对两个subscriber来说，是两个struct, 上述的第一个参数会从0重新开始累加 c1: (3, c) c2: (1, c) // 如果加上share publisher = subject.scan((0, ), { ($0.0 + 1, $1) }).share() // output c1: (3, c) c2: (3, c) Connectable Publishers 有时会遇到如下图的问题，多个subscriber订阅同一个publisher，新的subscriber在订阅时，publisher可能已经emit一部分数据了。为了保证所有的subsciber都订阅以后publisher再开始执行，这就需要用到Connectable Publishers. 想要生成Connectable Publishers，只需要让publisher执行makeConnectable()operator即可，如下代码所示。当所有的subscriber都注册好之后，执行.connect函数即可让publisher开始执行 let url = URL(string: https://example.com/)! let connectable = URLSession.shared  .dataTaskPublisher(for: url)  .map() { $0.data }  .catch() { _ in Just(Data() )}  .share()  .makeConnectable() cancellable1 = connectable  .sink(receiveCompletion: { print(Received completion 1:   ($0).) },   receiveValue: { print(Received data 1:   ($0.count) bytes.) }) DispatchQueue.main.asyncAfter(deadline: .now() + 1) {  self.cancellable2 = connectable  .sink(receiveCompletion: { print(Received completion 2:   ($0).) },   receiveValue: { print(Received data 2:   ($0.count) bytes.) }) } DispatchQueue.main.asyncAfter(deadline: .now() + 2) {  self.connection = connectable.connect() } 另外有一些内置的Connectable Publisher, 如Publishers.Multicast和Timer.TimerPublisher, 这些必须手动调用.connect()才可以执行，有时也会造成问题。这时，可以调用.autoconnect(), 那么subscriber可以立刻执行。 let cancellable = Timer.publish(every: 1, on: .main, in: .default)  .autoconnect()  .sink() { date in  print (Date now:   (date)) } 可以调用.cancel()取消publisher Subscriber控制接收Publisher elements的数量 有两种方法 request(_:) 当publisher调用subscriber的receive(:)方法时返回一个新的demand 常用的sink和assign默认是声明了unlimiteddemand， 一旦声明了unlimited就无法再更改了。 // Publisher: Uses a timer to emit the date once per second. let timerPub = Timer.publish(every: 1, on: .main, in: .default)  .autoconnect() // Subscriber: Waits 5 seconds after subscription, then requests a // maximum of 3 values. class MySubscriber: Subscriber {  typealias Input = Date  typealias Failure = Never  var subscription: Subscription?  func receive(subscription: Subscription) {  print(published      received)  self.subscription = subscription  DispatchQueue.main.asyncAfter(deadline: .now() + 5) {   // request请求新的demand, 可以累加   subscription.request(.max(3))  }  }  func receive(_ input: Date) -&gt; Subscribers.Demand {  print(  (input)     (Date()))  // 直接返回新的Demand  return Subscribers.Demand.none  }  func receive(completion: Subscribers.Completion&lt;Never&gt;) {  print (--done--)  } } // Subscribe to timerPub. let mySub = MySubscriber() print (Subscribing at   (Date())) timerPub.subscribe(mySub) // Output Subscribing at 2019-12-09 18:57:06 +0000 published      received 2019-12-09 18:57:11 +0000   2019-12-09 18:57:11 +0000 2019-12-09 18:57:12 +0000   2019-12-09 18:57:12 +0000 2019-12-09 18:57:13 +0000   2019-12-09 18:57:13 +0000 通过Back-Pressure(反压) Operator控制Unlimited Demand 不自定义Subscriber也是可以控制需求的（作用到publisher上）  buffer(size:prefetch:whenFull:)： 控制到一个固定数量，当数量满了之后，可以选择报错，丢弃等操作   debounce(for:scheduler:options:)： 防抖，当publisher停止publish达到某个时间后才会收到数据   throttle(for:scheduler:latest:)： 减流，会有一个最大产生数据的速率，如果收到太多，会只发送最新或最老的数据   collect(:)和collect(:options:)： 将指定数量或时间的所有元素打包成一个数组一次性发送给订阅者  ",
      "url"      : "https://pfcstyle.github.io/2021/02/24/iOS-combine1/",
      "keywords" : "[&quot;iOS&quot;, &quot;Swift&quot;, &quot;Combine&quot;]"
    } ,
  
    {
      "title"    : "SwiftUI布局基础",
      "category" : "iOS",
      "content": "布局基础规则  默认，SwiftUI允许每个视图根据其渲染的容器选择自己的大小，然后将其居中于其父对象中。 Modifier实际上是将调用的视图包装到了另外一个视图中 ",
      "url"      : "https://pfcstyle.github.io/2021/02/26/iOS-swiftui-layout-base-rule/",
      "keywords" : "[&quot;iOS&quot;, &quot;Swift&quot;, &quot;SwiftUI&quot;, &quot;Layout&quot;]"
    } ,
  
    {
      "title"    : "Swift Type-Erasure(类型抹除)",
      "category" : "iOS",
      "content": "什么是Type-Erasure swift中在引用一些通用协议时，往往需要用到type erasure。它使我们能够更轻松地与通用协议进行交互，这些通用协议对将要实现它们的各种类型具有特定的要求。 常见的： struct ContentView: View {  var body: AnyView {  AnyView(Text(Hello, world!))  } } // 当然，5.1之后有更简单的写法(Opaque return types) struct ContentView: View {  var body: some View {  Text(Hello, world!)  } } 实例 以Equatable标准库中的协议为例。由于都是为了使相等类型的两个值能够按相等性进行比较，因此它使用元Self类型作为其唯一方法要求的参数 protocol Equatable {  static func ==(lhs: Self, rhs: Self) -&gt; Bool } 这种方法的优点在于，它不可能意外地比较两个不相关的相等类型（例如User和String），但是，它也使得它不可能被引用Equatable为独立协议（例如创建类似的数组[Equatable]），因为为了能够使用它，编译器需要知道确切的确切类型实际上符合该协议。 当协议包含关联类型时，也是如此。例如，在这里我们定义了一个Request协议，使我们能够在单个统一的实现后隐藏各种形式的数据请求（例如网络调用，数据库查询和缓存提取）： protocol Request {  associatedtype Response  associatedtype Error: Swift.Error typealias Handler = (Result&lt;Response, Error&gt;) -&gt; Void func perform(then handler: @escaping Handler) } 上面的方法为我们提供了相同的权衡方法，Equatable它非常强大，因为它使我们能够为任何类型的请求创建通用的抽象，但是这也使得无法直接引用Request协议本身，如下所示： class RequestQueue {  // Error: protocol 'Request' can only be used as a generic  // constraint because it has Self or associated type requirements  func add(_ request: Request,   handler: @escaping Request.Handler) {  ...  } } 解决上述问题的一种方法是准确执行错误消息中所说的内容，而不是Request直接引用，而是将其用作一般约束： class RequestQueue {  func add&lt;R: Request&gt;(_ request: R,     handler: @escaping R.Handler) {  ...  } } 上面的方法起作用了，因为现在编译器能够保证传递handler的确实与Request传递的实现兼容request—因为它们都基于泛型R，而泛型又被限制为与一致Request。 但是，尽管我们解决了方法签名问题，但实际上仍然无法对传递的请求做很多工作，因为我们无法将其存储为Request属性或[Request]数组的一部分，这将使得继续建立RequestQueue。那么，type-erasure该出场了。 通用包装器类型 我们将探讨的第一种类型擦除实际上并不涉及擦除任何类型，而是将它们包装在一个我们可以更容易引用的泛型类型中。继续构建RequestQueue，我们将首先创建该包装器类型，该包装器类型将捕获每个请求的perform方法作为闭包，以及在请求完成后应调用的handler方法： // This will let us wrap a Request protocol implementation in a // generic has the same Response and Error types as the protocol. struct AnyRequest&lt;Response, Error: Swift.Error&gt; {  typealias Handler = (Result&lt;Response, Error&gt;) -&gt; Void let perform: (@escaping Handler) -&gt; Void  let handler: Handler } 接下来，实现RequestQueue，为其添加Response和Error类型的泛型，这样编译器可以将泛型类型和associatetype对齐，从而允许我们对Request存储和引用。  这个实现时线程不安全的，我们只用来说明类型抹除的问题 class RequestQueue&lt;Response, Error: Swift.Error&gt; {  private typealias TypeErasedRequest = AnyRequest&lt;Response, Error&gt; private var queue = [TypeErasedRequest]()  private var ongoing: TypeErasedRequest? // We modify our 'add' method to include a 'where' clause that  // gives us a guarantee that the passed request's associated  // types match our queue's generic types.  func add&lt;R: Request&gt;(  _ request: R,  handler: @escaping R.Handler  ) where R.Response == Response, R.Error == Error {  // To perform our type erasure, we simply create an instance  // of 'AnyRequest' and pass it the underlying request's  // 'perform' method as a closure, along with the handler.  let typeErased = AnyRequest(   perform: request.perform,   handler: handler  )  // Since we're implementing a queue, we don't want to perform  // two requests at once, but rather save the request for  // later in case there's already an ongoing one.  guard ongoing == nil else {   queue.append(typeErased)   return  }  perform(typeErased)  } private func perform(_ request: TypeErasedRequest) {  ongoing = request  request.perform { [weak self] result in   request.handler(result)   self?.ongoing = nil   // Perform the next request if the queue isn't empty   ...  }  } } 闭包实现 使用闭包擦除类型时，其思想是捕获在闭包内部执行操作所需的所有类型信息，并使闭包仅接受非通用（甚至Void）输入。这样一来，我们就可以引用，存储和传递该功能，而无需实际知道其内部发生了什么—从而为我们提供了更大的灵活性。当然，这样实现会让代码变得难以调试，但优点是方便，而且可以完全封装类型信息。 class RequestQueue {  private var queue = [() -&gt; Void]()  private var isPerformingRequest = false func add&lt;R: Request&gt;(_ request: R,     handler: @escaping R.Handler) {  // This closure will capture both the request and its  // handler, without exposing any of that type information  // outside of it, providing full type erasure.  let typeErased = {   request.perform { [weak self] result in    handler(result)    self?.isPerformingRequest = false    self?.performNextIfNeeded()   }  }  queue.append(typeErased)  performNextIfNeeded()  } private func performNextIfNeeded() {  guard !isPerformingRequest &amp;&amp; !queue.isEmpty else {   return  }  isPerformingRequest = true  let closure = queue.removeFirst()  closure()  } } 外部类型抹除 目前，我们都是在内部实现类型抹除，外部调用者不会关心到这个问题。但是，有时在将协议实现传递给API之前进行一些轻量级转换，可以简化更多工作，而且可以更整齐的封装抹除代码。 对我们这个例子来说，可以要求每一个request在添加到队列之前进行专门化管理，这就衍变出了RequestOperation struct RequestOperation {  fileprivate let closure: (@escaping () -&gt; Void) -&gt; Void func perform(then handler: @escaping () -&gt; Void) {  closure(handler)  } } 类似于闭包实现，我们将其放在extension中 extension Request {  func makeOperation(with handler: @escaping Handler) -&gt; RequestOperation {  return RequestOperation { finisher in   // We actually want to capture 'self' here, since otherwise   // we risk not retaining the underlying request anywhere.   self.perform { result in    handler(result)    finisher()   }  }  } } 那么，我们的RequestQueue就可以更加专注于队列的实现，不用关心类型擦除了： class RequestQueue {  private var queue = [RequestOperation]()  private var ongoing: RequestOperation? // Since the type erasure now happens before a request is  // passed to the queue, it can simply accept a concrete  // instance of 'RequestOperation'.  func add(_ operation: RequestOperation) {  guard ongoing == nil else {   queue.append(operation)   return  }  perform(operation)  } private func perform(_ operation: RequestOperation) {  ongoing = operation  operation.perform { [weak self] in   self?.ongoing = nil   // Perform the next request if the queue isn't empty   ...  }  } } 当然，在调用RequestQueue时，就要求我们手动将Request转换为RequestOption了。 ",
      "url"      : "https://pfcstyle.github.io/2021/02/28/swift-type-erased/",
      "keywords" : "[&quot;iOS&quot;, &quot;Swift&quot;, &quot;type-erasure&quot;]"
    } ,
  
    {
      "title"    : "Re-Add storyboard",
      "category" : "iOS",
      "content": "Storyboard AppDelegate可以什么逻辑都没有 SceneDelegate可以什么相关逻辑都没有 Info.plist Storyboard设置  Xib  Xib-&gt;File’s Owner-&gt;右侧identify inspect-&gt;Class选项选择自己的ViewController Xib-&gt;左侧根View-&gt;右侧Connection inspect-&gt;Referencing Outlets-&gt;连线到File’s Owner ",
      "url"      : "https://pfcstyle.github.io/2021/03/08/iOS-readd-storyboard-xib/",
      "keywords" : "[&quot;iOS&quot;, &quot;Swift&quot;, &quot;Storyboard&quot;]"
    } ,
  
    {
      "title"    : "Giving lifestyle advice",
      "category" : "English",
      "content": "Key phrases  do exercise quit smoking drink more water eat healthier food get enough sleep go jogging balance life and work drink in moderation reduce stress key sentence  You had better practice speaking every day had better, it’s a very formal phrase and its mood is very strong. If your boss say you’d better do something, it’s mean you must do it! It’s a good idea to review your classes within 24 hours. You might want to give yourself small rewards for following a plan. You have to have a plan. You should definitely listen to feedback. Dialogue  Doris: You know, I really envy you Maureen. You can drink lattes, eat cake, and still fit into the same skinny jeans you had when you were 21. Maureen: Well that’s not quite true. I do a lot of exercise. If I didn’t I’d be the size of bus. Doris: Really? What do you do? Maureen: Oh, all sorts. You know, since Carlito decided to quit smoking and only drink in moderation, we spend every moment together doing something healthy. Doris: Oh, I envy you even more now. Basil and I never do anything active, he thinks you can only be healthy by being boring and eating healthier food, so we’re becoming fat and lazy. Maureen: Hmm, that doesn’t sound like Basil. He used to enjoy jogging in the evening didn’t he? Doris: Yeah, but then he started working the late shift, and he says he doesn’t get enough sleep. It’s so difficult to balance life and work these days. Maureen: I know what you mean. But if you want to be happy, you had better make some changes in your life. Doris: I know, but don’t know how Can you give me some advice? Maureen: Hmm, well… It’s good idea to make changes slowly. You might want to eat more fruit and vegetables, and drink more water-staying hydrated is really important and gives you energy. Doris: Yes, it’s hard to exercise when you’re tired all the time. Can drinking water really help? Maureen: Oh yes! You have to drink water, especially when you exercise. But you know what you should really do? Laugh! Seriously, it’s proven to reduce stress, which is about the worst thing for you! Laughter really is the best medicine. ",
      "url"      : "https://pfcstyle.github.io/2021/03/11/giving-lifestyle-advice/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Reminiscing",
      "category" : "English",
      "content": "The order of telling a personal anecdote  Lead-in: That reminds me of my first trep abroad. Background: I had never travelled outside of my city before, but I’d always dreamed of… Main events: At first, I was so confused. I didn’t even know how to cross the street. Outcome: Since then, I’ve always looked for opportunities to experience nwe cultures. Hand-over: How about you, John? Have you ever been to San Francisco? Dialogue  James: It was - it was pretty crazy, I’ll never forget that first time I saw my new school and just thought, huh, my life is about to change in a really big way… Lucy: Those kinds of moments really do stick with you. James: And how about you two? Did you experience something like that? Maria: I still remember my own first time abroad. I would’ve been I guess sixteen years old and- it was my friend’s idea originally-we decided to apply for this student exchange program- Lucy: Oh! They started offering those at my school and I- Maria: And, and, and, I mean, I’d always wanted to go overseas, but I’d never thought about actually doing that in high school. So the strange thing was, we both applied together, and I did it just for fun, but in the end I got in, so, off I went to Brazil! James: Brazil? Wow, that’s a long way to go. I heard life is pretty relaxed there Maria: Yes- James: -and that- Maria:- althoughhh, it certainly wasnt’ relaxing for me when first arrived. I mean, you anticipate some culture shock and all that, but then part of you thinks, that’s for other people,not for me. I’ll be fine. But as soon as I arrived, it was just - every little thing. Lucy: Language issues? Maria: Well, the language side of things was actually OK, because in the area I lived most people spoke some English. It was more like-i don’t know-every time I met someone, they’d hug and kiss me on the cheeks. I felt this pressure to be very close friends straight away. James: I guess the beaches made up for that, though, right? Maria: The beaches were great-yeah, weekend after weekend, swimming, surfing, whatever we wanted to do. But when I look back, it was much more than a long holiday. I guess it’s more the-how can I put it? It’s the way it’s changed my outlook or my way of thinking about what’s- Lucy: -what’s important in life. Maria: Mm, before then it was just family, job, I didn’t really think much beyond that. Now really make sure I’m living my life on my own terms. James: Well, that’s what matters, right. Maria: Yep. Anyway, what about you, Lucy? Were you saying that you went on a student exchange too? Lucy: Well, it wasn’t an exchange as such, but yes, when I was…. ",
      "url"      : "https://pfcstyle.github.io/2021/03/11/reminiscing/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Giving a speech in the workspace",
      "category" : "English",
      "content": "Key Vocabulary  show contract: instead, on the contrary, at the same time, nevertheless Add to an idea: indeed, furthermore, in addition, moreover Show effects and results: therefore, consequently, thus Restate your ideas briefly: in summary, essentially, in conclusion Sample speech The future of America is with its people, the fighters who are willing to sacrifice to make their dreams come true. True optimists are not those who deny the harsh difficulties we face. Optimists are those who recognize challenges and work hard to overcome them. I seek to create an America where the hopeful will not be disappointed. And the future is with the children. We must invest in our children by giving them the best education. We need to establish a safe environment for our children. They are the future leaders, doctors, teachers, and parents. We can’t deny our children the hope in the future they deserve. We must listen to their dreams and give them tools and resources to see those dreams come to fruition. I want to create an America for the children. We must not neglect the elderly. We should take care of those who have taken care of us. I believe in a future that is welcoming to all generations. A vote for me is vote for optimism; it is vote for the future. promise to strive for that better future that includes all of us. As we learn from the past, and dream of the future, I believe that we can build America as it was always meant to be. Sample speech(with discourse markers added) The future of America is with its people. Moreover, it is with the hopeful, those who believe in the immense possibilities of our nation. In addition, it is with the fighters, the ones who are willing to sacrifice to bring forth the dream that they have for the future. Indeed, the true optimists are not those who deny the harsh difficulties we face at the moment: on the contrary, they are the people who recognize the daunting challenges before them, and nevertheless press on to overcome them. In summary, they are the core of what America can be, what America should be, what America will be. Therefore, I seek to create an America where the hopeful will not be disappointed. The future of America is with its children. Consequently, we must invest in our children by giving them the best education possible. Furthermore, we must invest in our society in order to establish a safe and secure environment where the leaders, doctors, teachers, and parents of our future can be nurtured. We must not deny our children the hope in the future that they deserve; instead, we must listen to the dreams of their youth, and give them the tools and resources to see those dreams come to fruition. Thus, I seek to create an America that belongs to the children. At the same time, in our effort to honor the youth, we must not neglect the elderly. Indeed, we cannot fail to take care of those who have taken care of us. Essentially, I seek to create a future that is welcoming to all generations. In conclusion, a vote for me is a vote for optimism, a vote for hope, it is a vote for the future. I promise to strive for that better future that includes the children, the youth, and the elderly. As we learn from the past, and dream of the future, I believe that we can build America as it was always meant to be. ",
      "url"      : "https://pfcstyle.github.io/2021/03/12/giving-a-speech-in-the-workspace/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "redacted modifier",
      "category" : "SwfitUI",
      "content": "struct ArticleView: View {  var iconName: String  var title: String  var authorName: String  var description: String var body: some View {  VStack(alignment: .leading) {   HStack {    Image(systemName: iconName)    .foregroundColor(.white)    .padding()    .background(Circle().fill(Color.secondary))    VStack(alignment: .leading) {    Text(title).font(.title)    Text(By + authorName)     .font(.subheadline)     .foregroundColor(.gray)    }   }   Text(description).padding(.top)  }  .padding()  } } let placeholder = ArticleView(  iconName: doc,  title: Placeholder,  authorName: Placeholder author,  description: String(repeating: Placeholder , count: 5) ) .redacted(reason: .placeholder) struct RedactingView&lt;Input: View, Output: View&gt;: View {  var content: Input  var modifier: (Input) -&gt; Output @Environment(  .redactionReasons) private var reasons var body: some View {  if reasons.isEmpty {   content  } else {   modifier(content)  }  } } extension View {  func whenRedacted&lt;T: View&gt;(  apply modifier: @escaping (Self) -&gt; T  ) -&gt; some View {  RedactingView(content: self, modifier: modifier)  } } struct ArticleView: View {  ... var body: some View {  VStack(alignment: .leading) {   HStack {    Image(systemName: iconName)    .foregroundColor(.white)    .whenRedacted { $0.hidden() }    .padding()    .background(Circle().fill(Color.secondary))    ...   }   Text(description).padding(.top)  }  .padding()  } } struct ArticleView: View {  ... var body: some View {  VStack(alignment: .leading) {   HStack {    Image(systemName: iconName)    ...    VStack(alignment: .leading) {    Text(title).font(.title).unredacted()    ...    }   }   Text(description).padding(.top)  }  .padding()  } } ",
      "url"      : "https://pfcstyle.github.io/2021/03/13/redacting/",
      "keywords" : "[&quot;redacted&quot;, &quot;iOS&quot;]"
    } ,
  
    {
      "title"    : "Loading states of SwiftUI views",
      "category" : "SwfitUI",
      "content": "自加载View 这是一种最为简单的情况，在view中调用异步数据加载并更新到view上去。下面的实例代码中，我们假设有一个异步的loader,通过view的生命周期函数调用loader并更新。 struct ArticleView: View {  var articleID: Article.ID  var loader: ArticleLoader  @State private var result: Result&lt;Article, Error&gt;? var body: some View {  switch result {  case .success(let article):   // Rendering our article content within a scroll view:   ScrollView {    VStack(spacing: 20) {    Text(article.title).font(.title)    Text(article.body)    }    .padding()   }  case .failure(let error):   // Showing any error that was encountered using a   // dedicated ErrorView, which runs a given closure   // when the user tapped an embedded Retry button:   ErrorView(error: error, retryHandler: loadArticle)  case nil:   // We display a classic loading spinner while we're   // waiting for our content to load, and we start our   // loading operation once that view appears:   ProgressView().onAppear(perform: loadArticle)  }  } private func loadArticle() {  loader.loadArticle(withID: articleID) {   result = $0  }  } } ViewModel 但是上面不是一种好的方式，因为当我们有更多的异步请求时，这些代码就会变得非常混乱，甚至出现很多层case嵌套的情况。这时候，ArticleViewModel就可以出场了，它本质是一个ObservableObject。 class ArticleViewModel: ObservableObject {  enum State {  case idle  case loading  case failed(Error)  case loaded(Article)  } @Published private(set) var state = State.idle  private let articleID: Article.ID  private let loader: ArticleLoader init(articleID: Article.ID, loader: ArticleLoader) {  self.articleID = articleID  self.loader = loader  } func load() {  state = .loading  loader.loadArticle(withID: articleID) { [weak self] result in   switch result {   case .success(let article):    self?.state = .loaded(article)   case .failure(let error):    self?.state = .failed(error)   }  }  } } 接下来，我们使用@ObservedObject属性包装器来使用这个ViewModel struct ArticleView: View {  @ObservedObject var viewModel: ArticleViewModel var body: some View {  switch viewModel.state {  case .idle:   // Render a clear color and start the loading process   // when the view first appears, which should make the   // view model transition into its loading state:   Color.clear.onAppear(perform: viewModel.load)  case .loading:   ProgressView()  case .failed(let error):   ErrorView(error: error, retryHandler: viewModel.load)  case .loaded(let article):   ScrollView {    VStack(spacing: 20) {    Text(article.title).font(.title)    Text(article.body)    }    .padding()   }  }  } } 通用模型封装 上面我们已经成功地将网络请求逻辑和视图地更新逻辑分离开了，这让我们可以更加专注地投入与对应地逻辑开发中。接下来我们可以更近一步，从中抽象出一套异步请求通用的模式出来。 状态封装 首先我们发现State枚举其实不止适用于Article，对于所有的异步请求几乎都适用。 enum LoadingState&lt;Value&gt; {  case idle  case loading  case failed(Error)  case loaded(Value) } LoadableObject 接下来，我们从ArticleViewModel中抽象出加载数据的ViewModel的通用模型 protocol LoadableObject: ObservableObject {  associatedtype Output  var state: LoadingState&lt;Output&gt; { get }  func load() } AsyncContentView 到这里结束了吗？其实还没有，我们同样可以对适用异步请求的View进行统一抽象。这样我们就可以统一对我们的加载视图进行管理了。 struct AsyncContentView&lt;Source: LoadableObject, Content: View&gt;: View {  @ObservedObject var source: Source  var content: (Source.Output) -&gt; Content var body: some View {  switch source.state {  case .idle:   Color.clear.onAppear(perform: source.load)  case .loading:   ProgressView()  case .failed(let error):   ErrorView(error: error, retryHandler: source.load)  case .loaded(let output):   content(output)  }  } } 这样我们只需要对每一个content闭包返回一个单视图，就可以很完美的工作了。不过，我们还可以做的更好一点，那就是使用@ViewBuilder属性包装器来让这闭包可以支持完整的SwfitUI’s DSL功能了 struct AsyncContentView&lt;Source: LoadableObject, Content: View&gt;: View {  @ObservedObject var source: Source  var content: (Source.Output) -&gt; Content init(source: Source,  @ViewBuilder content: @escaping (Source.Output) -&gt; Content) {  self.source = source  self.content = content  }  ... } 接下来我们看如何使用,重新实现ArticleView struct ArticleView: View {  @ObservedObject var viewModel: ArticleViewModel var body: some View {  AsyncContentView(source: viewModel) { article in   ScrollView {    VStack(spacing: 20) {    Text(article.title).font(.title)    Text(article.body)    }    .padding()   }  }  } } Combine + SwfitUI SwiftUI经常会与Combine一起适配使用，因为这两个框架都遵循非常相似的声明式语法和数据驱动设计模式。 所以，与其让我们的视图遵循经典的单次一对一加载渲染模式，不如使用数据驱动的模式，来让数据随着app的状态变化可以持续的反馈到视图去,这就是flux。 接下来，我们使用Combine publisher来实现LoadableObject，然后使用其来加载和更新发布的状态。 class PublishedObject&lt;Wrapped: Publisher&gt;: LoadableObject {  @Published private(set) var state = LoadingState&lt;Wrapped.Output&gt;.idle private let publisher: Wrapped  private var cancellable: AnyCancellable? init(publisher: Wrapped) {  self.publisher = publisher  } func load() {  state = .loading  cancellable = publisher   .map(LoadingState.loaded)   .catch { error in    Just(LoadingState.failed(error))   }   .sink { [weak self] state in    self?.state = state   }  } } 接下来，通过Swift的泛型能力，我们队AsyncContentView进行改造。 extension AsyncContentView {  init&lt;P: Publisher&gt;(  source: P,  @ViewBuilder content: @escaping (P.Output) -&gt; Content  ) where Source == PublishedObject&lt;P&gt; {  self.init(   source: PublishedObject(publisher: source),   content: content  )  } } 再看下ArticleView如何实现。 struct ArticleView: View {  var publisher: AnyPublisher&lt;Article, Error&gt; var body: some View {  AsyncContentView(source: publisher) { article in   ScrollView {    VStack(spacing: 20) {    Text(article.title).font(.title)    Text(article.body)    }    .padding()   }  }  } } struct ArticleListView: View {  @ObservedObject var viewModel: ArticleListViewModel  var body: some View {  List(viewModel.articlePreviews) { preview in   NavigationLink(preview.title    destination: ArticleView(    publisher: viewModel.publisher(for: preview.id)    )   )  }  } } 大家可能会疑惑loader去哪里了，什么时候加载数据呢？实际上，在这里publisher取代了loader的位置，这里就要求你的网络请求需要返回一个publisher对象，而这，恰恰是当下比较流行的网络加载库已经做好的事。 支持自定义的Loading View struct AsyncContentView&lt;Source: LoadableObject,     LoadingView: View,     Content: View&gt;: View {  @ObservedObject var source: Source  var loadingView: LoadingView  var content: (Source.Output) -&gt; Content init(source: Source,  loadingView: LoadingView,  @ViewBuilder content: @escaping (Source.Output) -&gt; Content) {  self.source = source  self.loadingView = loadingView  self.content = content  } var body: some View {  switch source.state {  case .idle:   Color.clear.onAppear(perform: source.load)  case .loading:   loadingView  case .failed(let error):   ErrorView(error: error, retryHandler: source.load)  case .loaded(let output):   content(output)  }  } } // 为了更进一步的方便使用，我们通过extension来增加默认加载视图地能力。 typealias DefaultProgressView = ProgressView&lt;EmptyView, EmptyView&gt; extension AsyncContentView where LoadingView == DefaultProgressView {  init(  source: Source,  @ViewBuilder content: @escaping (Source.Output) -&gt; Content  ) {  self.init(   source: source,   loadingView: ProgressView(),   content: content  )  } } 最后，我们再看看ArticleView。我们为其添加了自定义的占位加载视图，在Article加载时，就可以显示我们自定义的占位图。 extension ArticleView {  struct ContentView: View {  var article: Article  var body: some View {   VStack(spacing: 20) {    Text(article.title).font(.title)    Text(article.body)   }   .padding()  }  } struct Placeholder: View {  var body: some View {   ContentView(article: Article(    title: Title,    body: String(repeating: Body, count: 100)   )).redacted(reason: .placeholder)  }  } } struct ArticleView: View {  var publisher: AnyPublisher&lt;Article, Error&gt; var body: some View {  ScrollView {   AsyncContentView(    source: publisher,    loadingView: Placeholder(),    content: ContentView.init   )  }  } } 最后的最后，这是MVVM设计模式吗？ 答案是：是的。这就是MVVM，只是我们这里并没有给出Article Model的实现。 ",
      "url"      : "https://pfcstyle.github.io/2021/03/14/handling-loading-states-within-swiftui-views/",
      "keywords" : "[&quot;SwiftUI&quot;, &quot;iOS&quot;, &quot;Combine&quot;]"
    } ,
  
    {
      "title"    : "Practicing for a job interview",
      "category" : "English",
      "content": "Key grammar  I’d like to know if there is a canteen on the premises? Could you tell me if you provide a car? Would you mind telling me where you studied? May I ask what your rules for sick leave are? Do you mind me asking what the salary is? I was wondering if you’d mind telling me the start date? B: Example questions:  May I ask what my main duties will be?  Mostly answering the phone and making coffee. Would you mind telling me if overtime is paid?  Yes, overtime is paid. May I ask when you will be able to confirm whether or not I’ve got the job?  Probably the beginning of August. Could you tell me if I will receive training?  Yes, there’s a full training program. Could you tell me what the salary is? 50,000 per month. General type salary dress code colleagues training start date pension company car promotion responsibilities paid overtime ",
      "url"      : "https://pfcstyle.github.io/2021/03/15/practicing-for-a-job-interview/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Discussing gender",
      "category" : "English",
      "content": "Key grammar When you say it’s ‘common knowledge’:  - are you sure about that?  - are you referring to the financial scandal?  - what exactly do you mean?  - I don’t think that’s quite right  - do you mean that everyone knows?  Hang on a second: Stopping a speaker in order to challenge their ideas You mean to say that: Checking if you understand the other person’s ideas But there again, …: Reminding someone if a point you have made previously I’ll tell you what, though: introducing your own point Coming back to your point…: Returning to an argument the other speaker made. Dialogue Melissa: Did you see that interview on BNN about the new foreign minister? Terrible. Winston: What was wrong with it? Melissa: Oh, it was just the questions they were asking, the way they describe her. What she likes to wear, how often she’s changed her hairstyle, what kind of a mother she is - I mean, why should any of that matter? Winston: Well, I guess they’re trying to build up a character profile, aren’t they? And that’s part of what you’d want to know about someone like that. Melissa: You mean to say that if it were a man in that position you’d be interested in what type of suit he wears? Which kind of school he sends his kids to? Winston: Well, not necessarily, but then again maybe people are interested in learning different things about different types of politicians. Melissa: I’ll tell you what, though. You see a lot more of this stuff about women than you do about men. There’s definitely a tendency to - Winston: Well, hang on a second. When you say ‘a lot more’-I mean, are you sure about that? They were talking about the prime minister the other day-showing how much his hair has gone grey, and all the wrinkles and things he’s got since he was first elected And I’m pretty sure he’s a man. Melissa: Yes, but you’ve got to look at the overall picture, don’t you? One news story about his grey hair two hundred about his politics. But with the women, it’s just incessant, the focus on their image, on their personal lives. They can barely get a word in about what their actual policies are. Winston: But there again-i mean, what if that’s just what people want to know? Melissa: Well, it’s certainly not what I want to know. She’s going to be in charge of our foreign policy. There’s much more to worry about than her thoughts on motherhood. But, uh, coming back to your point-i do think if that is what people want to know, then it’s part of a cycle where we’re told that’s what’s important about women, so that’s what we expect to hear about them. There’s no reason that should be the case, though, and the media could play a role in changing things. ",
      "url"      : "https://pfcstyle.github.io/2021/03/17/discussing-gender/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Doing a SWOT analysis",
      "category" : "English",
      "content": " Strengths  locally owned  low employee turnover  good locations for store within the city  fast delivery times  good customer service  positive reputation  What advantages does your organization have?  What strengths would others say your company has?  What specialized markets or innovative technology can your company take advantage of?  What do you do better than your competitors?  What unique resources can you draw on that others can’t?   Weakness  not the market leader  not well known compared to competitors  more expensive prices, smaller selection  relies on word of mouth for advertising  what could be better about your company?  What are some of your competrors’’ weaknesses?   Opportunities  the two major competitors attack each other intheir ads  overall the econonmy is doing well  small increase in home-buyers in recent years  What are some market trends you could take advantage of?  What are some challenges your  What might be changing about your company? Your competitor?   Threats  all companies target the same demographics  competitors are stable  What are your competitors doing?  What are some challenges your company faces?  What does your company need to avoid?  What might be some effects that your company has no control over   Dialogue Taylor:okay, so that covers opportunities box, now on to our weaknesses. Jade: Um, I’m sorry but where do I put eco-friendly appliances? Dylan: Oh that’s a strength, you should put it here. Jade: Great, thanks! Taylor: Wait, that isn’t really a strength. It’s more like an opportunity. Dylan: Hmmm .. I see what you mean. Jade: Why? Taylor: Strengths are more internal opportunities are external. Dylan: Yeah, put it here instead. Jade: Okay. But aren’t we selling those appliances? That’s internal, isn’t it? Dylan: That is one way of looking at it, but ask yourself- do we ultimately have any control of how eco-friendly the appliances are? Are we the ones making those appliances? Jade: No, I guess not… So external things are things we have no control over? Taylor: That’s right. Okay, now how about our weaknesses? Dylan: Our loans? Taylor: Yep, and let’s not forget that we’ve only been in business for two years so that also affects things. Dylan: True. Were you going to add something, Jade? Jade: Ummm .. the vehicle gas mileage law? Taylor: Well- Dylan: But-you first. Taylor: Thanks. So, is that something that’s really internal? Jade: Well, we’ll have to get new vehicles, we’ll have control over which vehicles we get and why. That’s internal. Taylor: Yes, that’s true, and purchasing new vehicles could be listed as a weakness But also consider that it’s the new law that’s forcing us to buy these vehicles in the first place. Jade: Oh! And we don’t have any control over the law. So the law is a threat, but the purchase of vehicles is a weakness. Dylan: That’s right! Jade: Great! And I put that here. Taylor: Exactly. Anything else? Dylan: Hmmm… What about-? ",
      "url"      : "https://pfcstyle.github.io/2021/03/18/doing-a-swot-analysis/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "Changing the topic",
      "category" : "English",
      "content": "Dialogue Jonathan: It was a nice day today, wasn’t it? Linda: Yes, it really was. I love these sunny spring days. Which reminds me: if it’s like this tomorrow, I’m going to go to the beach. Jonathan: Oh, you like the beach? I love the beach! Did I tell you?- I took surfing lessons a couple of years ago. I can’t wait to get back out there! Linda: Wow, I could never go surfing. I really admire anyone for doing something so exciting and risky. The most dangerous thing I ever do is ride a bike in the city. Jonathan: Well, I would be scared to do that with all the crazy drivers around. Linda: I know exactly what you mean- there are some crazy drivers out there. Jonathan: Speaking of which, have you noticed how much more traffic there is lately? I remember when the streets used to be so quiet and peaceful. It was much more romantic here a couple of years ago. Linda: I feel exactly the same way! ",
      "url"      : "https://pfcstyle.github.io/2021/03/19/changing-the-topic/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "-[** copyWithZone:] unrecognized selector sent to instance",
      "category" : "iOS",
      "content": "很多OC的class, 内部属性声明使用的@property (nonatomic, copy),导致在赋值使用时，自动调用copyWithZone:方法，如果这时传入的对象没有实现这个方法，就会报找不到的错误。 解决方法 第一种方法：实现copyWithZone class SparkAppService: NSCopying{  var vendorId: NSCopying  func copy(with zone: NSZone? = nil) -&gt; Any {  let c = SparkAppService()  c.vendorId = self.vendorId.copy(with: zone) as! NSCopying  return c  } } 第二种方法：继承NSObject @objc class SparkAppService: NSObject{  override init() {  super.init()  } } ",
      "url"      : "https://pfcstyle.github.io/2021/03/20/iOS-swift-copy/",
      "keywords" : "[&quot;iOS&quot;, &quot;copyWithZone&quot;, &quot;NSCopying&quot;]"
    } ,
  
    {
      "title"    : "Apologizing",
      "category" : "English",
      "content": "Key phrases for apologize  I’m asfully sorry for the terrible. I do regret making irated I terribly sorry for …. I shouldn’t have treated you like this. I’m so sorry I should have taken (this) into consideration. I’m so sorry, that was not intentional I didn’t intend to do that. My apologies I didn’t realize what I was doing; Look, I know it was wrong of me to be like that; I guess I could’ve done (more to support you in front of the boss); Would you please forgive me?; I promise I’ll make it up to you. I guess I could have been (more aware of what I was saying.) I shouldn’t say that in public. Can we talk about this in private. Do this in a more graceful way. I just did that on impulse. It’s not JUST your responsibility. I didn’t mean to say something bad ABOUT you. I realize that I shouldn’t HAVE said those things in public. Thank you for your forgiveness For presenting angry You really EMBARRASED ME in the meeting. The made me so irrated I don’t think you TOOK me into consideration at all. I really don’t want to experience such a situation again it made the design look so RIDICULOUS You made me look so bad You really shouldn’t say that in public You made me feel so stupid You have MADE ME LOSE FACE with everyone ",
      "url"      : "https://pfcstyle.github.io/2021/03/20/Apologizing/",
      "keywords" : "[&quot;English&quot;, &quot;Communicating&quot;]"
    } ,
  
    {
      "title"    : "kubernetes 问题汇总",
      "category" : "kubernetes",
      "content": "突然所有服务无法访问 因为是使用的公司虚拟机集群搭建的k8s集群，发现公司虚拟机即使配置了静态ip，仍然会发生改变！所以重新apply一下静态ip配置，恢复原ip即可。 # ubuntu18 sudo netplan apply ",
      "url"      : "https://pfcstyle.github.io/2021/03/23/kubernetes-problem-collection/",
      "keywords" : "[&quot;k8s&quot;, &quot;kubernetes&quot;, &quot;坑&quot;]"
    } ,
  
    {
      "title"    : "Badminton",
      "category" : "Hobbies",
      "content": "视频  李在福《Play To Win》完整版   李在福《追球》全集 图文  超全羽毛球技术图解 公众号  和蔡赟聊羽毛球 微信号：caiyunliaoyumaoqiu   羽毛球 微信号：yu-mao-qiu  ",
      "url"      : "https://pfcstyle.github.io/wiki/badminton/",
      "keywords" : "羽毛球"
    } 
  
]

